三个目标:
	第一:
			pipefd转换为管道中的数据, 并且被接受, 处理
			test_pool_0.cpp
				例如:
						对管道中的写端(注册可写事件), 并每次都会返回(epoll_wait), 检测其中有
					EPOLLOUT && strlen(fd_buffer) != 0, 可以得出其中每次都会检测其中有事件的
					发生, (可以提高效率), 再将其写入到管道中, 其中管道已经被注册()可读事件,
					将会检测出, 并加入到epoll事件集中.
						缺点:
							有一个中间fd_buffer的存在,
							每次都会返回(EPOLLOUT), 每次都会被判断下,
							增加了一次fd的中转处理, 效率降低
						有点:
							每次epoll_wait都会返回, 系统反应及时, 形成了一种类似于非阻塞模式.
							管道的作用起到了, 但没有发挥较大作用.
	第二:
			在一的基础上, 对其进行优化数据, 不采用事件机制, 
			test_pool_1.cpp
				例如:
						此时不用管道的写端(注册EPOLLOUT)的fd, 减小了每次事件的触发, 提高了效率.
					只是, 每次有连接的事件的时候, 将直接写入到管道中, 不会直接写入中转区, 将引发
					一种EPOLLIN的触发, 从而起到了效果.
						优点:
							减少了事件的触发, 提高了效率,
							销毁资源的,
							加入线程的单例模式,(初始第一步)

	第三:
			是双端管道的适用性, 进行测试, sockpair; 用epoll来注册事件机制.
			test_pool_2.cpp
				例如:
					对socketpair中会出现两个文件描述符, sockpair[0], sockpair[1],我们对其
				进行了, 两端都可以进行读写, 但是只能由:一端写入再有另一端读出, 同理, 另一端
				也是如此, 入./sockpair目录下所说那样, 并且, 我们可以对其进行设置, 非阻塞模式
				注册EPOLL的事件(操作). 
			
	第四:
			在线程中, 应该定义全局的日志, 和锁系统, 其他要用的时候传入, 引用，这是为了传入线程安全
		机制,
