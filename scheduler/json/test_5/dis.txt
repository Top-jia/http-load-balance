
test_json:     file format elf32-i386


Disassembly of section .init:

08049544 <_init>:
 8049544:	55                   	push   %ebp
 8049545:	89 e5                	mov    %esp,%ebp
 8049547:	53                   	push   %ebx
 8049548:	83 ec 04             	sub    $0x4,%esp
 804954b:	e8 00 00 00 00       	call   8049550 <_init+0xc>
 8049550:	5b                   	pop    %ebx
 8049551:	81 c3 40 6e 00 00    	add    $0x6e40,%ebx
 8049557:	8b 93 fc ff ff ff    	mov    -0x4(%ebx),%edx
 804955d:	85 d2                	test   %edx,%edx
 804955f:	74 05                	je     8049566 <_init+0x22>
 8049561:	e8 4e 00 00 00       	call   80495b4 <__gmon_start__@plt>
 8049566:	e8 45 02 00 00       	call   80497b0 <frame_dummy>
 804956b:	e8 00 47 00 00       	call   804dc70 <__do_global_ctors_aux>
 8049570:	58                   	pop    %eax
 8049571:	5b                   	pop    %ebx
 8049572:	c9                   	leave  
 8049573:	c3                   	ret    

Disassembly of section .plt:

08049574 <sprintf@plt-0x10>:
 8049574:	ff 35 94 03 05 08    	pushl  0x8050394
 804957a:	ff 25 98 03 05 08    	jmp    *0x8050398
 8049580:	00 00                	add    %al,(%eax)
	...

08049584 <sprintf@plt>:
 8049584:	ff 25 9c 03 05 08    	jmp    *0x805039c
 804958a:	68 00 00 00 00       	push   $0x0
 804958f:	e9 e0 ff ff ff       	jmp    8049574 <_init+0x30>

08049594 <open@plt>:
 8049594:	ff 25 a0 03 05 08    	jmp    *0x80503a0
 804959a:	68 08 00 00 00       	push   $0x8
 804959f:	e9 d0 ff ff ff       	jmp    8049574 <_init+0x30>

080495a4 <__cxa_atexit@plt>:
 80495a4:	ff 25 a4 03 05 08    	jmp    *0x80503a4
 80495aa:	68 10 00 00 00       	push   $0x10
 80495af:	e9 c0 ff ff ff       	jmp    8049574 <_init+0x30>

080495b4 <__gmon_start__@plt>:
 80495b4:	ff 25 a8 03 05 08    	jmp    *0x80503a8
 80495ba:	68 18 00 00 00       	push   $0x18
 80495bf:	e9 b0 ff ff ff       	jmp    8049574 <_init+0x30>

080495c4 <realloc@plt>:
 80495c4:	ff 25 ac 03 05 08    	jmp    *0x80503ac
 80495ca:	68 20 00 00 00       	push   $0x20
 80495cf:	e9 a0 ff ff ff       	jmp    8049574 <_init+0x30>

080495d4 <strtod@plt>:
 80495d4:	ff 25 b0 03 05 08    	jmp    *0x80503b0
 80495da:	68 28 00 00 00       	push   $0x28
 80495df:	e9 90 ff ff ff       	jmp    8049574 <_init+0x30>

080495e4 <_ZNSt8ios_base4InitC1Ev@plt>:
 80495e4:	ff 25 b4 03 05 08    	jmp    *0x80503b4
 80495ea:	68 30 00 00 00       	push   $0x30
 80495ef:	e9 80 ff ff ff       	jmp    8049574 <_init+0x30>

080495f4 <write@plt>:
 80495f4:	ff 25 b8 03 05 08    	jmp    *0x80503b8
 80495fa:	68 38 00 00 00       	push   $0x38
 80495ff:	e9 70 ff ff ff       	jmp    8049574 <_init+0x30>

08049604 <memset@plt>:
 8049604:	ff 25 bc 03 05 08    	jmp    *0x80503bc
 804960a:	68 40 00 00 00       	push   $0x40
 804960f:	e9 60 ff ff ff       	jmp    8049574 <_init+0x30>

08049614 <__libc_start_main@plt>:
 8049614:	ff 25 c0 03 05 08    	jmp    *0x80503c0
 804961a:	68 48 00 00 00       	push   $0x48
 804961f:	e9 50 ff ff ff       	jmp    8049574 <_init+0x30>

08049624 <__assert_fail@plt>:
 8049624:	ff 25 c4 03 05 08    	jmp    *0x80503c4
 804962a:	68 50 00 00 00       	push   $0x50
 804962f:	e9 40 ff ff ff       	jmp    8049574 <_init+0x30>

08049634 <_ZNSt8ios_base4InitD1Ev@plt>:
 8049634:	ff 25 c8 03 05 08    	jmp    *0x80503c8
 804963a:	68 58 00 00 00       	push   $0x58
 804963f:	e9 30 ff ff ff       	jmp    8049574 <_init+0x30>

08049644 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>:
 8049644:	ff 25 cc 03 05 08    	jmp    *0x80503cc
 804964a:	68 60 00 00 00       	push   $0x60
 804964f:	e9 20 ff ff ff       	jmp    8049574 <_init+0x30>

08049654 <free@plt>:
 8049654:	ff 25 d0 03 05 08    	jmp    *0x80503d0
 804965a:	68 68 00 00 00       	push   $0x68
 804965f:	e9 10 ff ff ff       	jmp    8049574 <_init+0x30>

08049664 <memcpy@plt>:
 8049664:	ff 25 d4 03 05 08    	jmp    *0x80503d4
 804966a:	68 70 00 00 00       	push   $0x70
 804966f:	e9 00 ff ff ff       	jmp    8049574 <_init+0x30>

08049674 <strlen@plt>:
 8049674:	ff 25 d8 03 05 08    	jmp    *0x80503d8
 804967a:	68 78 00 00 00       	push   $0x78
 804967f:	e9 f0 fe ff ff       	jmp    8049574 <_init+0x30>

08049684 <close@plt>:
 8049684:	ff 25 dc 03 05 08    	jmp    *0x80503dc
 804968a:	68 80 00 00 00       	push   $0x80
 804968f:	e9 e0 fe ff ff       	jmp    8049574 <_init+0x30>

08049694 <malloc@plt>:
 8049694:	ff 25 e0 03 05 08    	jmp    *0x80503e0
 804969a:	68 88 00 00 00       	push   $0x88
 804969f:	e9 d0 fe ff ff       	jmp    8049574 <_init+0x30>

080496a4 <_ZNSolsEPFRSoS_E@plt>:
 80496a4:	ff 25 e4 03 05 08    	jmp    *0x80503e4
 80496aa:	68 90 00 00 00       	push   $0x90
 80496af:	e9 c0 fe ff ff       	jmp    8049574 <_init+0x30>

080496b4 <sscanf@plt>:
 80496b4:	ff 25 e8 03 05 08    	jmp    *0x80503e8
 80496ba:	68 98 00 00 00       	push   $0x98
 80496bf:	e9 b0 fe ff ff       	jmp    8049574 <_init+0x30>

080496c4 <strncmp@plt>:
 80496c4:	ff 25 ec 03 05 08    	jmp    *0x80503ec
 80496ca:	68 a0 00 00 00       	push   $0xa0
 80496cf:	e9 a0 fe ff ff       	jmp    8049574 <_init+0x30>

080496d4 <_ZSt4endlIcSt11char_traitsIcEERSt13basic_ostreamIT_T0_ES6_@plt>:
 80496d4:	ff 25 f0 03 05 08    	jmp    *0x80503f0
 80496da:	68 a8 00 00 00       	push   $0xa8
 80496df:	e9 90 fe ff ff       	jmp    8049574 <_init+0x30>

080496e4 <__gxx_personality_v0@plt>:
 80496e4:	ff 25 f4 03 05 08    	jmp    *0x80503f4
 80496ea:	68 b0 00 00 00       	push   $0xb0
 80496ef:	e9 80 fe ff ff       	jmp    8049574 <_init+0x30>

080496f4 <tolower@plt>:
 80496f4:	ff 25 f8 03 05 08    	jmp    *0x80503f8
 80496fa:	68 b8 00 00 00       	push   $0xb8
 80496ff:	e9 70 fe ff ff       	jmp    8049574 <_init+0x30>

08049704 <strcmp@plt>:
 8049704:	ff 25 fc 03 05 08    	jmp    *0x80503fc
 804970a:	68 c0 00 00 00       	push   $0xc0
 804970f:	e9 60 fe ff ff       	jmp    8049574 <_init+0x30>

Disassembly of section .text:

08049720 <_start>:
 8049720:	31 ed                	xor    %ebp,%ebp
 8049722:	5e                   	pop    %esi
 8049723:	89 e1                	mov    %esp,%ecx
 8049725:	83 e4 f0             	and    $0xfffffff0,%esp
 8049728:	50                   	push   %eax
 8049729:	54                   	push   %esp
 804972a:	52                   	push   %edx
 804972b:	68 00 dc 04 08       	push   $0x804dc00
 8049730:	68 10 dc 04 08       	push   $0x804dc10
 8049735:	51                   	push   %ecx
 8049736:	56                   	push   %esi
 8049737:	68 13 9c 04 08       	push   $0x8049c13
 804973c:	e8 d3 fe ff ff       	call   8049614 <__libc_start_main@plt>
 8049741:	f4                   	hlt    
 8049742:	90                   	nop
 8049743:	90                   	nop
 8049744:	90                   	nop
 8049745:	90                   	nop
 8049746:	90                   	nop
 8049747:	90                   	nop
 8049748:	90                   	nop
 8049749:	90                   	nop
 804974a:	90                   	nop
 804974b:	90                   	nop
 804974c:	90                   	nop
 804974d:	90                   	nop
 804974e:	90                   	nop
 804974f:	90                   	nop

08049750 <__do_global_dtors_aux>:
 8049750:	55                   	push   %ebp
 8049751:	89 e5                	mov    %esp,%ebp
 8049753:	53                   	push   %ebx
 8049754:	8d 64 24 fc          	lea    -0x4(%esp),%esp
 8049758:	80 3d ac 04 05 08 00 	cmpb   $0x0,0x80504ac
 804975f:	75 3e                	jne    804979f <__do_global_dtors_aux+0x4f>
 8049761:	bb 9c 02 05 08       	mov    $0x805029c,%ebx
 8049766:	a1 b0 04 05 08       	mov    0x80504b0,%eax
 804976b:	81 eb 98 02 05 08    	sub    $0x8050298,%ebx
 8049771:	c1 fb 02             	sar    $0x2,%ebx
 8049774:	83 eb 01             	sub    $0x1,%ebx
 8049777:	39 d8                	cmp    %ebx,%eax
 8049779:	73 1d                	jae    8049798 <__do_global_dtors_aux+0x48>
 804977b:	90                   	nop
 804977c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049780:	83 c0 01             	add    $0x1,%eax
 8049783:	a3 b0 04 05 08       	mov    %eax,0x80504b0
 8049788:	ff 14 85 98 02 05 08 	call   *0x8050298(,%eax,4)
 804978f:	a1 b0 04 05 08       	mov    0x80504b0,%eax
 8049794:	39 d8                	cmp    %ebx,%eax
 8049796:	72 e8                	jb     8049780 <__do_global_dtors_aux+0x30>
 8049798:	c6 05 ac 04 05 08 01 	movb   $0x1,0x80504ac
 804979f:	8d 64 24 04          	lea    0x4(%esp),%esp
 80497a3:	5b                   	pop    %ebx
 80497a4:	5d                   	pop    %ebp
 80497a5:	c3                   	ret    
 80497a6:	8d 76 00             	lea    0x0(%esi),%esi
 80497a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080497b0 <frame_dummy>:
 80497b0:	55                   	push   %ebp
 80497b1:	89 e5                	mov    %esp,%ebp
 80497b3:	8d 64 24 e8          	lea    -0x18(%esp),%esp
 80497b7:	a1 a0 02 05 08       	mov    0x80502a0,%eax
 80497bc:	85 c0                	test   %eax,%eax
 80497be:	74 12                	je     80497d2 <frame_dummy+0x22>
 80497c0:	b8 00 00 00 00       	mov    $0x0,%eax
 80497c5:	85 c0                	test   %eax,%eax
 80497c7:	74 09                	je     80497d2 <frame_dummy+0x22>
 80497c9:	c7 04 24 a0 02 05 08 	movl   $0x80502a0,(%esp)
 80497d0:	ff d0                	call   *%eax
 80497d2:	c9                   	leave  
 80497d3:	c3                   	ret    

080497d4 <_Z11create_jsonv>:
				{"firstname":	"Thomas",	"lastname":	"Carter"}
			]
	}
 * */

cJSON* create_json(){
 80497d4:	55                   	push   %ebp
 80497d5:	89 e5                	mov    %esp,%ebp
 80497d7:	83 ec 48             	sub    $0x48,%esp
	cJSON *root = cJSON_CreateObject();
 80497da:	e8 82 38 00 00       	call   804d061 <cJSON_CreateObject>
 80497df:	89 45 ec             	mov    %eax,-0x14(%ebp)
	cJSON_AddItemToObject(root, "name", cJSON_CreateString("王小二"));
 80497e2:	c7 04 24 c8 dc 04 08 	movl   $0x804dcc8,(%esp)
 80497e9:	e8 d0 36 00 00       	call   804cebe <cJSON_CreateString>
 80497ee:	89 44 24 08          	mov    %eax,0x8(%esp)
 80497f2:	c7 44 24 04 d2 dc 04 	movl   $0x804dcd2,0x4(%esp)
 80497f9:	08 
 80497fa:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80497fd:	89 04 24             	mov    %eax,(%esp)
 8049800:	e8 7b 2d 00 00       	call   804c580 <cJSON_AddItemToObject>
	cJSON_AddNumberToObject(root, "age", 25.2);
 8049805:	dd 05 f0 dd 04 08    	fldl   0x804ddf0
 804980b:	dd 5c 24 08          	fstpl  0x8(%esp)
 804980f:	c7 44 24 04 d7 dc 04 	movl   $0x804dcd7,0x4(%esp)
 8049816:	08 
 8049817:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804981a:	89 04 24             	mov    %eax,(%esp)
 804981d:	e8 a8 2f 00 00       	call   804c7ca <cJSON_AddNumberToObject>
	cJSON_AddStringToObject(root, "birthday", "1990-01-01");
 8049822:	c7 44 24 08 db dc 04 	movl   $0x804dcdb,0x8(%esp)
 8049829:	08 
 804982a:	c7 44 24 04 e6 dc 04 	movl   $0x804dce6,0x4(%esp)
 8049831:	08 
 8049832:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049835:	89 04 24             	mov    %eax,(%esp)
 8049838:	e8 f6 2f 00 00       	call   804c833 <cJSON_AddStringToObject>
	cJSON *sub  = NULL;
 804983d:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
	cJSON_AddItemToObject(root, "school", sub = cJSON_CreateString("蓝翔"));
 8049844:	c7 04 24 ef dc 04 08 	movl   $0x804dcef,(%esp)
 804984b:	e8 6e 36 00 00       	call   804cebe <cJSON_CreateString>
 8049850:	89 45 f0             	mov    %eax,-0x10(%ebp)
 8049853:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049856:	89 44 24 08          	mov    %eax,0x8(%esp)
 804985a:	c7 44 24 04 f6 dc 04 	movl   $0x804dcf6,0x4(%esp)
 8049861:	08 
 8049862:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049865:	89 04 24             	mov    %eax,(%esp)
 8049868:	e8 13 2d 00 00       	call   804c580 <cJSON_AddItemToObject>
	
	const char *chars[2] = {"理发", "挖掘机"};
 804986d:	c7 45 e4 fd dc 04 08 	movl   $0x804dcfd,-0x1c(%ebp)
 8049874:	c7 45 e8 04 dd 04 08 	movl   $0x804dd04,-0x18(%ebp)
	cJSON *array = cJSON_CreateStringArray(chars, sizeof(chars)/sizeof(chars[0]));
 804987b:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 8049882:	00 
 8049883:	8d 45 e4             	lea    -0x1c(%ebp),%eax
 8049886:	89 04 24             	mov    %eax,(%esp)
 8049889:	e8 58 3a 00 00       	call   804d2e6 <cJSON_CreateStringArray>
 804988e:	89 45 f4             	mov    %eax,-0xc(%ebp)
	cJSON_AddItemToObject(root, "major", array);
 8049891:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049894:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049898:	c7 44 24 04 0e dd 04 	movl   $0x804dd0e,0x4(%esp)
 804989f:	08 
 80498a0:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80498a3:	89 04 24             	mov    %eax,(%esp)
 80498a6:	e8 d5 2c 00 00       	call   804c580 <cJSON_AddItemToObject>
	
	cJSON_AddFalseToObject(root, "has_girlfriend");
 80498ab:	c7 44 24 04 14 dd 04 	movl   $0x804dd14,0x4(%esp)
 80498b2:	08 
 80498b3:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80498b6:	89 04 24             	mov    %eax,(%esp)
 80498b9:	e8 58 2e 00 00       	call   804c716 <cJSON_AddFalseToObject>
	
	double double_array[3] = {73.8, 23.5, 89.1};
 80498be:	dd 05 f8 dd 04 08    	fldl   0x804ddf8
 80498c4:	dd 5d c8             	fstpl  -0x38(%ebp)
 80498c7:	dd 05 00 de 04 08    	fldl   0x804de00
 80498cd:	dd 5d d0             	fstpl  -0x30(%ebp)
 80498d0:	dd 05 08 de 04 08    	fldl   0x804de08
 80498d6:	dd 5d d8             	fstpl  -0x28(%ebp)
	cJSON_AddItemToObject(root, "grade", array = cJSON_CreateDoubleArray(double_array, sizeof(double_array)/sizeof(double_array[0])));
 80498d9:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
 80498e0:	00 
 80498e1:	8d 45 c8             	lea    -0x38(%ebp),%eax
 80498e4:	89 04 24             	mov    %eax,(%esp)
 80498e7:	e8 33 39 00 00       	call   804d21f <cJSON_CreateDoubleArray>
 80498ec:	89 45 f4             	mov    %eax,-0xc(%ebp)
 80498ef:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80498f2:	89 44 24 08          	mov    %eax,0x8(%esp)
 80498f6:	c7 44 24 04 23 dd 04 	movl   $0x804dd23,0x4(%esp)
 80498fd:	08 
 80498fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049901:	89 04 24             	mov    %eax,(%esp)
 8049904:	e8 77 2c 00 00       	call   804c580 <cJSON_AddItemToObject>

	cJSON_AddBoolToObject(root, "car", false);
 8049909:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 8049910:	00 
 8049911:	c7 44 24 04 29 dd 04 	movl   $0x804dd29,0x4(%esp)
 8049918:	08 
 8049919:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804991c:	89 04 24             	mov    %eax,(%esp)
 804991f:	e8 49 2e 00 00       	call   804c76d <cJSON_AddBoolToObject>
	cJSON_AddBoolToObject(root, "house", false);
 8049924:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804992b:	00 
 804992c:	c7 44 24 04 2d dd 04 	movl   $0x804dd2d,0x4(%esp)
 8049933:	08 
 8049934:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049937:	89 04 24             	mov    %eax,(%esp)
 804993a:	e8 2e 2e 00 00       	call   804c76d <cJSON_AddBoolToObject>
	
	array = cJSON_CreateArray();
 804993f:	e8 f3 36 00 00       	call   804d037 <cJSON_CreateArray>
 8049944:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sub = cJSON_CreateObject();
 8049947:	e8 15 37 00 00       	call   804d061 <cJSON_CreateObject>
 804994c:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cJSON_AddTrueToObject(sub, "math");
 804994f:	c7 44 24 04 33 dd 04 	movl   $0x804dd33,0x4(%esp)
 8049956:	08 
 8049957:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804995a:	89 04 24             	mov    %eax,(%esp)
 804995d:	e8 5d 2d 00 00       	call   804c6bf <cJSON_AddTrueToObject>
	cJSON_AddItemToArray(array, sub);
 8049962:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049965:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049969:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804996c:	89 04 24             	mov    %eax,(%esp)
 804996f:	e8 1a 2b 00 00       	call   804c48e <cJSON_AddItemToArray>

	sub = cJSON_CreateObject();
 8049974:	e8 e8 36 00 00       	call   804d061 <cJSON_CreateObject>
 8049979:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cJSON_AddFalseToObject(sub, "PE");
 804997c:	c7 44 24 04 38 dd 04 	movl   $0x804dd38,0x4(%esp)
 8049983:	08 
 8049984:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049987:	89 04 24             	mov    %eax,(%esp)
 804998a:	e8 87 2d 00 00       	call   804c716 <cJSON_AddFalseToObject>
	cJSON_AddItemToArray(array, sub);
 804998f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049992:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049996:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049999:	89 04 24             	mov    %eax,(%esp)
 804999c:	e8 ed 2a 00 00       	call   804c48e <cJSON_AddItemToArray>

	sub = cJSON_CreateObject();
 80499a1:	e8 bb 36 00 00       	call   804d061 <cJSON_CreateObject>
 80499a6:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cJSON_AddTrueToObject(sub, "English");
 80499a9:	c7 44 24 04 3b dd 04 	movl   $0x804dd3b,0x4(%esp)
 80499b0:	08 
 80499b1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80499b4:	89 04 24             	mov    %eax,(%esp)
 80499b7:	e8 03 2d 00 00       	call   804c6bf <cJSON_AddTrueToObject>
	cJSON_AddItemToArray(array, sub);
 80499bc:	8b 45 f0             	mov    -0x10(%ebp),%eax
 80499bf:	89 44 24 04          	mov    %eax,0x4(%esp)
 80499c3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80499c6:	89 04 24             	mov    %eax,(%esp)
 80499c9:	e8 c0 2a 00 00       	call   804c48e <cJSON_AddItemToArray>
	cJSON_AddItemToObject(root, "grade_pass", array);
 80499ce:	8b 45 f4             	mov    -0xc(%ebp),%eax
 80499d1:	89 44 24 08          	mov    %eax,0x8(%esp)
 80499d5:	c7 44 24 04 43 dd 04 	movl   $0x804dd43,0x4(%esp)
 80499dc:	08 
 80499dd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80499e0:	89 04 24             	mov    %eax,(%esp)
 80499e3:	e8 98 2b 00 00       	call   804c580 <cJSON_AddItemToObject>

	cJSON_AddStringToObject(root, "comment", "this is a comment");
 80499e8:	c7 44 24 08 4e dd 04 	movl   $0x804dd4e,0x8(%esp)
 80499ef:	08 
 80499f0:	c7 44 24 04 60 dd 04 	movl   $0x804dd60,0x4(%esp)
 80499f7:	08 
 80499f8:	8b 45 ec             	mov    -0x14(%ebp),%eax
 80499fb:	89 04 24             	mov    %eax,(%esp)
 80499fe:	e8 30 2e 00 00       	call   804c833 <cJSON_AddStringToObject>

	array = cJSON_CreateArray();
 8049a03:	e8 2f 36 00 00       	call   804d037 <cJSON_CreateArray>
 8049a08:	89 45 f4             	mov    %eax,-0xc(%ebp)
	sub = cJSON_CreateObject();
 8049a0b:	e8 51 36 00 00       	call   804d061 <cJSON_CreateObject>
 8049a10:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cJSON_AddItemToObject(sub, "firstname", cJSON_CreateString("Bill"));
 8049a13:	c7 04 24 68 dd 04 08 	movl   $0x804dd68,(%esp)
 8049a1a:	e8 9f 34 00 00       	call   804cebe <cJSON_CreateString>
 8049a1f:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049a23:	c7 44 24 04 6d dd 04 	movl   $0x804dd6d,0x4(%esp)
 8049a2a:	08 
 8049a2b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049a2e:	89 04 24             	mov    %eax,(%esp)
 8049a31:	e8 4a 2b 00 00       	call   804c580 <cJSON_AddItemToObject>
	cJSON_AddStringToObject(sub, "lastname", "Gates");
 8049a36:	c7 44 24 08 77 dd 04 	movl   $0x804dd77,0x8(%esp)
 8049a3d:	08 
 8049a3e:	c7 44 24 04 7d dd 04 	movl   $0x804dd7d,0x4(%esp)
 8049a45:	08 
 8049a46:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049a49:	89 04 24             	mov    %eax,(%esp)
 8049a4c:	e8 e2 2d 00 00       	call   804c833 <cJSON_AddStringToObject>
	cJSON_AddItemToArray(array, sub);
 8049a51:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049a54:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049a58:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049a5b:	89 04 24             	mov    %eax,(%esp)
 8049a5e:	e8 2b 2a 00 00       	call   804c48e <cJSON_AddItemToArray>

	sub = cJSON_CreateObject();
 8049a63:	e8 f9 35 00 00       	call   804d061 <cJSON_CreateObject>
 8049a68:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cJSON_AddItemToObject(sub, "firstname", cJSON_CreateString("Georeg"));
 8049a6b:	c7 04 24 86 dd 04 08 	movl   $0x804dd86,(%esp)
 8049a72:	e8 47 34 00 00       	call   804cebe <cJSON_CreateString>
 8049a77:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049a7b:	c7 44 24 04 6d dd 04 	movl   $0x804dd6d,0x4(%esp)
 8049a82:	08 
 8049a83:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049a86:	89 04 24             	mov    %eax,(%esp)
 8049a89:	e8 f2 2a 00 00       	call   804c580 <cJSON_AddItemToObject>
	cJSON_AddStringToObject(sub, "lastname", "Bush");
 8049a8e:	c7 44 24 08 8d dd 04 	movl   $0x804dd8d,0x8(%esp)
 8049a95:	08 
 8049a96:	c7 44 24 04 7d dd 04 	movl   $0x804dd7d,0x4(%esp)
 8049a9d:	08 
 8049a9e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049aa1:	89 04 24             	mov    %eax,(%esp)
 8049aa4:	e8 8a 2d 00 00       	call   804c833 <cJSON_AddStringToObject>
	cJSON_AddItemToArray(array, sub);
 8049aa9:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049aac:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049ab0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049ab3:	89 04 24             	mov    %eax,(%esp)
 8049ab6:	e8 d3 29 00 00       	call   804c48e <cJSON_AddItemToArray>

	sub = cJSON_CreateObject();
 8049abb:	e8 a1 35 00 00       	call   804d061 <cJSON_CreateObject>
 8049ac0:	89 45 f0             	mov    %eax,-0x10(%ebp)
	cJSON_AddItemToObject(sub, "firstname", cJSON_CreateString("Thomas"));
 8049ac3:	c7 04 24 92 dd 04 08 	movl   $0x804dd92,(%esp)
 8049aca:	e8 ef 33 00 00       	call   804cebe <cJSON_CreateString>
 8049acf:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049ad3:	c7 44 24 04 6d dd 04 	movl   $0x804dd6d,0x4(%esp)
 8049ada:	08 
 8049adb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049ade:	89 04 24             	mov    %eax,(%esp)
 8049ae1:	e8 9a 2a 00 00       	call   804c580 <cJSON_AddItemToObject>
	cJSON_AddStringToObject(sub, "lastname", "carter");
 8049ae6:	c7 44 24 08 99 dd 04 	movl   $0x804dd99,0x8(%esp)
 8049aed:	08 
 8049aee:	c7 44 24 04 7d dd 04 	movl   $0x804dd7d,0x4(%esp)
 8049af5:	08 
 8049af6:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049af9:	89 04 24             	mov    %eax,(%esp)
 8049afc:	e8 32 2d 00 00       	call   804c833 <cJSON_AddStringToObject>
	cJSON_AddItemToArray(array, sub);
 8049b01:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049b04:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049b08:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049b0b:	89 04 24             	mov    %eax,(%esp)
 8049b0e:	e8 7b 29 00 00       	call   804c48e <cJSON_AddItemToArray>

	cJSON_AddItemToObject(root, "employ", array);
 8049b13:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049b16:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049b1a:	c7 44 24 04 a0 dd 04 	movl   $0x804dda0,0x4(%esp)
 8049b21:	08 
 8049b22:	8b 45 ec             	mov    -0x14(%ebp),%eax
 8049b25:	89 04 24             	mov    %eax,(%esp)
 8049b28:	e8 53 2a 00 00       	call   804c580 <cJSON_AddItemToObject>
	return root;
 8049b2d:	8b 45 ec             	mov    -0x14(%ebp),%eax
}
 8049b30:	c9                   	leave  
 8049b31:	c3                   	ret    

08049b32 <_Z10write_fileP5cJSON>:


void write_file(cJSON *root){
 8049b32:	55                   	push   %ebp
 8049b33:	89 e5                	mov    %esp,%ebp
 8049b35:	83 ec 28             	sub    $0x28,%esp
	if(root == NULL){
 8049b38:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8049b3c:	0f 84 ce 00 00 00    	je     8049c10 <_Z10write_fileP5cJSON+0xde>
		return ;
	}
	char *buffer = cJSON_Print(root);
 8049b42:	8b 45 08             	mov    0x8(%ebp),%eax
 8049b45:	89 04 24             	mov    %eax,(%esp)
 8049b48:	e8 6c 16 00 00       	call   804b1b9 <cJSON_Print>
 8049b4d:	89 45 f0             	mov    %eax,-0x10(%ebp)
	std::cout << "my.json " << buffer << std::endl;
 8049b50:	c7 44 24 04 a7 dd 04 	movl   $0x804dda7,0x4(%esp)
 8049b57:	08 
 8049b58:	c7 04 24 20 04 05 08 	movl   $0x8050420,(%esp)
 8049b5f:	e8 e0 fa ff ff       	call   8049644 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
 8049b64:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049b67:	89 54 24 04          	mov    %edx,0x4(%esp)
 8049b6b:	89 04 24             	mov    %eax,(%esp)
 8049b6e:	e8 d1 fa ff ff       	call   8049644 <_ZStlsISt11char_traitsIcEERSt13basic_ostreamIcT_ES5_PKc@plt>
 8049b73:	c7 44 24 04 d4 96 04 	movl   $0x80496d4,0x4(%esp)
 8049b7a:	08 
 8049b7b:	89 04 24             	mov    %eax,(%esp)
 8049b7e:	e8 21 fb ff ff       	call   80496a4 <_ZNSolsEPFRSoS_E@plt>

	int fd = open(location, O_CREAT | O_RDWR, 0644);
 8049b83:	c7 44 24 08 a4 01 00 	movl   $0x1a4,0x8(%esp)
 8049b8a:	00 
 8049b8b:	c7 44 24 04 42 00 00 	movl   $0x42,0x4(%esp)
 8049b92:	00 
 8049b93:	c7 04 24 b0 dd 04 08 	movl   $0x804ddb0,(%esp)
 8049b9a:	e8 f5 f9 ff ff       	call   8049594 <open@plt>
 8049b9f:	89 45 f4             	mov    %eax,-0xc(%ebp)
	assert(fd != -1);
 8049ba2:	83 7d f4 ff          	cmpl   $0xffffffff,-0xc(%ebp)
 8049ba6:	75 24                	jne    8049bcc <_Z10write_fileP5cJSON+0x9a>
 8049ba8:	c7 44 24 0c d1 dd 04 	movl   $0x804ddd1,0xc(%esp)
 8049baf:	08 
 8049bb0:	c7 44 24 08 62 00 00 	movl   $0x62,0x8(%esp)
 8049bb7:	00 
 8049bb8:	c7 44 24 04 ba dd 04 	movl   $0x804ddba,0x4(%esp)
 8049bbf:	08 
 8049bc0:	c7 04 24 c8 dd 04 08 	movl   $0x804ddc8,(%esp)
 8049bc7:	e8 58 fa ff ff       	call   8049624 <__assert_fail@plt>
	write(fd, buffer, strlen(buffer));
 8049bcc:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049bcf:	89 04 24             	mov    %eax,(%esp)
 8049bd2:	e8 9d fa ff ff       	call   8049674 <strlen@plt>
 8049bd7:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049bdb:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049bde:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049be2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049be5:	89 04 24             	mov    %eax,(%esp)
 8049be8:	e8 07 fa ff ff       	call   80495f4 <write@plt>
	close(fd);
 8049bed:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049bf0:	89 04 24             	mov    %eax,(%esp)
 8049bf3:	e8 8c fa ff ff       	call   8049684 <close@plt>
	free(buffer);
 8049bf8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049bfb:	89 04 24             	mov    %eax,(%esp)
 8049bfe:	e8 51 fa ff ff       	call   8049654 <free@plt>
	cJSON_Delete(root);
 8049c03:	8b 45 08             	mov    0x8(%ebp),%eax
 8049c06:	89 04 24             	mov    %eax,(%esp)
 8049c09:	e8 d8 02 00 00       	call   8049ee6 <cJSON_Delete>
 8049c0e:	eb 01                	jmp    8049c11 <_Z10write_fileP5cJSON+0xdf>
}


void write_file(cJSON *root){
	if(root == NULL){
		return ;
 8049c10:	90                   	nop
	assert(fd != -1);
	write(fd, buffer, strlen(buffer));
	close(fd);
	free(buffer);
	cJSON_Delete(root);
}
 8049c11:	c9                   	leave  
 8049c12:	c3                   	ret    

08049c13 <main>:

int main(){
 8049c13:	55                   	push   %ebp
 8049c14:	89 e5                	mov    %esp,%ebp
 8049c16:	83 e4 f0             	and    $0xfffffff0,%esp
 8049c19:	83 ec 20             	sub    $0x20,%esp
	cJSON *root = create_json();
 8049c1c:	e8 b3 fb ff ff       	call   80497d4 <_Z11create_jsonv>
 8049c21:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	write_file(root);
 8049c25:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8049c29:	89 04 24             	mov    %eax,(%esp)
 8049c2c:	e8 01 ff ff ff       	call   8049b32 <_Z10write_fileP5cJSON>
	return 0;
 8049c31:	b8 00 00 00 00       	mov    $0x0,%eax
}
 8049c36:	c9                   	leave  
 8049c37:	c3                   	ret    

08049c38 <_Z41__static_initialization_and_destruction_0ii>:
 8049c38:	55                   	push   %ebp
 8049c39:	89 e5                	mov    %esp,%ebp
 8049c3b:	83 ec 18             	sub    $0x18,%esp
 8049c3e:	83 7d 08 01          	cmpl   $0x1,0x8(%ebp)
 8049c42:	75 32                	jne    8049c76 <_Z41__static_initialization_and_destruction_0ii+0x3e>
 8049c44:	81 7d 0c ff ff 00 00 	cmpl   $0xffff,0xc(%ebp)
 8049c4b:	75 29                	jne    8049c76 <_Z41__static_initialization_and_destruction_0ii+0x3e>
  extern wostream wclog;	///< Linked to standard error (buffered)
#endif
  //@}

  // For construction of filebuffers for cout, cin, cerr, clog et. al.
  static ios_base::Init __ioinit;
 8049c4d:	c7 04 24 b4 04 05 08 	movl   $0x80504b4,(%esp)
 8049c54:	e8 8b f9 ff ff       	call   80495e4 <_ZNSt8ios_base4InitC1Ev@plt>
 8049c59:	b8 34 96 04 08       	mov    $0x8049634,%eax
 8049c5e:	c7 44 24 08 c0 dc 04 	movl   $0x804dcc0,0x8(%esp)
 8049c65:	08 
 8049c66:	c7 44 24 04 b4 04 05 	movl   $0x80504b4,0x4(%esp)
 8049c6d:	08 
 8049c6e:	89 04 24             	mov    %eax,(%esp)
 8049c71:	e8 2e f9 ff ff       	call   80495a4 <__cxa_atexit@plt>
 8049c76:	c9                   	leave  
 8049c77:	c3                   	ret    

08049c78 <_GLOBAL__I__Z11create_jsonv>:
 8049c78:	55                   	push   %ebp
 8049c79:	89 e5                	mov    %esp,%ebp
 8049c7b:	83 ec 18             	sub    $0x18,%esp
 8049c7e:	c7 44 24 04 ff ff 00 	movl   $0xffff,0x4(%esp)
 8049c85:	00 
 8049c86:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
 8049c8d:	e8 a6 ff ff ff       	call   8049c38 <_Z41__static_initialization_and_destruction_0ii>
 8049c92:	c9                   	leave  
 8049c93:	c3                   	ret    

08049c94 <cJSON_GetErrorPtr>:
    size_t position;
} error;
static error global_error = { NULL, 0 };

CJSON_PUBLIC(const char *) cJSON_GetErrorPtr(void)
{
 8049c94:	55                   	push   %ebp
 8049c95:	89 e5                	mov    %esp,%ebp
    return (const char*) (global_error.json + global_error.position);
 8049c97:	a1 b8 04 05 08       	mov    0x80504b8,%eax
 8049c9c:	89 c2                	mov    %eax,%edx
 8049c9e:	a1 bc 04 05 08       	mov    0x80504bc,%eax
 8049ca3:	8d 04 02             	lea    (%edx,%eax,1),%eax
}
 8049ca6:	5d                   	pop    %ebp
 8049ca7:	c3                   	ret    

08049ca8 <cJSON_GetStringValue>:

CJSON_PUBLIC(char *) cJSON_GetStringValue(cJSON *item) {
 8049ca8:	55                   	push   %ebp
 8049ca9:	89 e5                	mov    %esp,%ebp
 8049cab:	83 ec 18             	sub    $0x18,%esp
    if (!cJSON_IsString(item)) {
 8049cae:	8b 45 08             	mov    0x8(%ebp),%eax
 8049cb1:	89 04 24             	mov    %eax,(%esp)
 8049cb4:	e8 2b 3b 00 00       	call   804d7e4 <cJSON_IsString>
 8049cb9:	85 c0                	test   %eax,%eax
 8049cbb:	0f 94 c0             	sete   %al
 8049cbe:	84 c0                	test   %al,%al
 8049cc0:	74 07                	je     8049cc9 <cJSON_GetStringValue+0x21>
        return NULL;
 8049cc2:	b8 00 00 00 00       	mov    $0x0,%eax
 8049cc7:	eb 06                	jmp    8049ccf <cJSON_GetStringValue+0x27>
    }

    return item->valuestring;
 8049cc9:	8b 45 08             	mov    0x8(%ebp),%eax
 8049ccc:	8b 40 10             	mov    0x10(%eax),%eax
}
 8049ccf:	c9                   	leave  
 8049cd0:	c3                   	ret    

08049cd1 <cJSON_Version>:
#if (CJSON_VERSION_MAJOR != 1) || (CJSON_VERSION_MINOR != 7) || (CJSON_VERSION_PATCH != 5)
    #error cJSON.h and cJSON.c have different versions. Make sure that both have the same.
#endif

CJSON_PUBLIC(const char*) cJSON_Version(void)
{
 8049cd1:	55                   	push   %ebp
 8049cd2:	89 e5                	mov    %esp,%ebp
 8049cd4:	83 ec 28             	sub    $0x28,%esp
    static char version[15];
    sprintf(version, "%i.%i.%i", CJSON_VERSION_MAJOR, CJSON_VERSION_MINOR, CJSON_VERSION_PATCH);
 8049cd7:	c7 44 24 10 05 00 00 	movl   $0x5,0x10(%esp)
 8049cde:	00 
 8049cdf:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
 8049ce6:	00 
 8049ce7:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 8049cee:	00 
 8049cef:	c7 44 24 04 10 de 04 	movl   $0x804de10,0x4(%esp)
 8049cf6:	08 
 8049cf7:	c7 04 24 c0 04 05 08 	movl   $0x80504c0,(%esp)
 8049cfe:	e8 81 f8 ff ff       	call   8049584 <sprintf@plt>

    return version;
 8049d03:	b8 c0 04 05 08       	mov    $0x80504c0,%eax
}
 8049d08:	c9                   	leave  
 8049d09:	c3                   	ret    

08049d0a <_ZL23case_insensitive_strcmpPKhS0_>:

/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
{
 8049d0a:	55                   	push   %ebp
 8049d0b:	89 e5                	mov    %esp,%ebp
 8049d0d:	53                   	push   %ebx
 8049d0e:	83 ec 14             	sub    $0x14,%esp
    if ((string1 == NULL) || (string2 == NULL))
 8049d11:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8049d15:	74 06                	je     8049d1d <_ZL23case_insensitive_strcmpPKhS0_+0x13>
 8049d17:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 8049d1b:	75 07                	jne    8049d24 <_ZL23case_insensitive_strcmpPKhS0_+0x1a>
    {
        return 1;
 8049d1d:	b8 01 00 00 00       	mov    $0x1,%eax
 8049d22:	eb 7f                	jmp    8049da3 <_ZL23case_insensitive_strcmpPKhS0_+0x99>
    }

    if (string1 == string2)
 8049d24:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d27:	3b 45 0c             	cmp    0xc(%ebp),%eax
 8049d2a:	75 20                	jne    8049d4c <_ZL23case_insensitive_strcmpPKhS0_+0x42>
    {
        return 0;
 8049d2c:	b8 00 00 00 00       	mov    $0x0,%eax
 8049d31:	eb 70                	jmp    8049da3 <_ZL23case_insensitive_strcmpPKhS0_+0x99>
    }

    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
    {
        if (*string1 == '\0')
 8049d33:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d36:	0f b6 00             	movzbl (%eax),%eax
 8049d39:	84 c0                	test   %al,%al
 8049d3b:	75 07                	jne    8049d44 <_ZL23case_insensitive_strcmpPKhS0_+0x3a>
        {
            return 0;
 8049d3d:	b8 00 00 00 00       	mov    $0x0,%eax
 8049d42:	eb 5f                	jmp    8049da3 <_ZL23case_insensitive_strcmpPKhS0_+0x99>
    if (string1 == string2)
    {
        return 0;
    }

    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
 8049d44:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 8049d48:	83 45 0c 01          	addl   $0x1,0xc(%ebp)
 8049d4c:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d4f:	0f b6 00             	movzbl (%eax),%eax
 8049d52:	0f b6 c0             	movzbl %al,%eax
 8049d55:	89 04 24             	mov    %eax,(%esp)
 8049d58:	e8 97 f9 ff ff       	call   80496f4 <tolower@plt>
 8049d5d:	89 c3                	mov    %eax,%ebx
 8049d5f:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049d62:	0f b6 00             	movzbl (%eax),%eax
 8049d65:	0f b6 c0             	movzbl %al,%eax
 8049d68:	89 04 24             	mov    %eax,(%esp)
 8049d6b:	e8 84 f9 ff ff       	call   80496f4 <tolower@plt>
 8049d70:	39 c3                	cmp    %eax,%ebx
 8049d72:	0f 94 c0             	sete   %al
 8049d75:	84 c0                	test   %al,%al
 8049d77:	75 ba                	jne    8049d33 <_ZL23case_insensitive_strcmpPKhS0_+0x29>
        {
            return 0;
        }
    }

    return tolower(*string1) - tolower(*string2);
 8049d79:	8b 45 08             	mov    0x8(%ebp),%eax
 8049d7c:	0f b6 00             	movzbl (%eax),%eax
 8049d7f:	0f b6 c0             	movzbl %al,%eax
 8049d82:	89 04 24             	mov    %eax,(%esp)
 8049d85:	e8 6a f9 ff ff       	call   80496f4 <tolower@plt>
 8049d8a:	89 c3                	mov    %eax,%ebx
 8049d8c:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049d8f:	0f b6 00             	movzbl (%eax),%eax
 8049d92:	0f b6 c0             	movzbl %al,%eax
 8049d95:	89 04 24             	mov    %eax,(%esp)
 8049d98:	e8 57 f9 ff ff       	call   80496f4 <tolower@plt>
 8049d9d:	89 da                	mov    %ebx,%edx
 8049d9f:	29 c2                	sub    %eax,%edx
 8049da1:	89 d0                	mov    %edx,%eax
}
 8049da3:	83 c4 14             	add    $0x14,%esp
 8049da6:	5b                   	pop    %ebx
 8049da7:	5d                   	pop    %ebp
 8049da8:	c3                   	ret    

08049da9 <_ZL12cJSON_strdupPKhPK14internal_hooks>:
#endif

static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };

static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
{
 8049da9:	55                   	push   %ebp
 8049daa:	89 e5                	mov    %esp,%ebp
 8049dac:	83 ec 28             	sub    $0x28,%esp
    size_t length = 0;
 8049daf:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    unsigned char *copy = NULL;
 8049db6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if (string == NULL)
 8049dbd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8049dc1:	75 07                	jne    8049dca <_ZL12cJSON_strdupPKhPK14internal_hooks+0x21>
    {
        return NULL;
 8049dc3:	b8 00 00 00 00       	mov    $0x0,%eax
 8049dc8:	eb 4a                	jmp    8049e14 <_ZL12cJSON_strdupPKhPK14internal_hooks+0x6b>
    }

    length = strlen((const char*)string) + sizeof("");
 8049dca:	8b 45 08             	mov    0x8(%ebp),%eax
 8049dcd:	89 04 24             	mov    %eax,(%esp)
 8049dd0:	e8 9f f8 ff ff       	call   8049674 <strlen@plt>
 8049dd5:	83 c0 01             	add    $0x1,%eax
 8049dd8:	89 45 f0             	mov    %eax,-0x10(%ebp)
    copy = (unsigned char*)hooks->allocate(length);
 8049ddb:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049dde:	8b 00                	mov    (%eax),%eax
 8049de0:	8b 55 f0             	mov    -0x10(%ebp),%edx
 8049de3:	89 14 24             	mov    %edx,(%esp)
 8049de6:	ff d0                	call   *%eax
 8049de8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (copy == NULL)
 8049deb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049def:	75 07                	jne    8049df8 <_ZL12cJSON_strdupPKhPK14internal_hooks+0x4f>
    {
        return NULL;
 8049df1:	b8 00 00 00 00       	mov    $0x0,%eax
 8049df6:	eb 1c                	jmp    8049e14 <_ZL12cJSON_strdupPKhPK14internal_hooks+0x6b>
    }
    memcpy(copy, string, length);
 8049df8:	8b 45 f0             	mov    -0x10(%ebp),%eax
 8049dfb:	89 44 24 08          	mov    %eax,0x8(%esp)
 8049dff:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e02:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049e06:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049e09:	89 04 24             	mov    %eax,(%esp)
 8049e0c:	e8 53 f8 ff ff       	call   8049664 <memcpy@plt>

    return copy;
 8049e11:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8049e14:	c9                   	leave  
 8049e15:	c3                   	ret    

08049e16 <cJSON_InitHooks>:

CJSON_PUBLIC(void) cJSON_InitHooks(cJSON_Hooks* hooks)
{
 8049e16:	55                   	push   %ebp
 8049e17:	89 e5                	mov    %esp,%ebp
    if (hooks == NULL)
 8049e19:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8049e1d:	75 20                	jne    8049e3f <cJSON_InitHooks+0x29>
    {
        /* Reset hooks */
        global_hooks.allocate = malloc;
 8049e1f:	c7 05 04 04 05 08 94 	movl   $0x8049694,0x8050404
 8049e26:	96 04 08 
        global_hooks.deallocate = free;
 8049e29:	c7 05 08 04 05 08 54 	movl   $0x8049654,0x8050408
 8049e30:	96 04 08 
        global_hooks.reallocate = realloc;
 8049e33:	c7 05 0c 04 05 08 c4 	movl   $0x80495c4,0x805040c
 8049e3a:	95 04 08 
        return;
 8049e3d:	eb 68                	jmp    8049ea7 <cJSON_InitHooks+0x91>
    }

    global_hooks.allocate = malloc;
 8049e3f:	c7 05 04 04 05 08 94 	movl   $0x8049694,0x8050404
 8049e46:	96 04 08 
    if (hooks->malloc_fn != NULL)
 8049e49:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e4c:	8b 00                	mov    (%eax),%eax
 8049e4e:	85 c0                	test   %eax,%eax
 8049e50:	74 0a                	je     8049e5c <cJSON_InitHooks+0x46>
    {
        global_hooks.allocate = hooks->malloc_fn;
 8049e52:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e55:	8b 00                	mov    (%eax),%eax
 8049e57:	a3 04 04 05 08       	mov    %eax,0x8050404
    }

    global_hooks.deallocate = free;
 8049e5c:	c7 05 08 04 05 08 54 	movl   $0x8049654,0x8050408
 8049e63:	96 04 08 
    if (hooks->free_fn != NULL)
 8049e66:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e69:	8b 40 04             	mov    0x4(%eax),%eax
 8049e6c:	85 c0                	test   %eax,%eax
 8049e6e:	74 0b                	je     8049e7b <cJSON_InitHooks+0x65>
    {
        global_hooks.deallocate = hooks->free_fn;
 8049e70:	8b 45 08             	mov    0x8(%ebp),%eax
 8049e73:	8b 40 04             	mov    0x4(%eax),%eax
 8049e76:	a3 08 04 05 08       	mov    %eax,0x8050408
    }

    /* use realloc only if both free and malloc are used */
    global_hooks.reallocate = NULL;
 8049e7b:	c7 05 0c 04 05 08 00 	movl   $0x0,0x805040c
 8049e82:	00 00 00 
    if ((global_hooks.allocate == malloc) && (global_hooks.deallocate == free))
 8049e85:	a1 04 04 05 08       	mov    0x8050404,%eax
 8049e8a:	3d 94 96 04 08       	cmp    $0x8049694,%eax
 8049e8f:	75 16                	jne    8049ea7 <cJSON_InitHooks+0x91>
 8049e91:	a1 08 04 05 08       	mov    0x8050408,%eax
 8049e96:	3d 54 96 04 08       	cmp    $0x8049654,%eax
 8049e9b:	75 0a                	jne    8049ea7 <cJSON_InitHooks+0x91>
    {
        global_hooks.reallocate = realloc;
 8049e9d:	c7 05 0c 04 05 08 c4 	movl   $0x80495c4,0x805040c
 8049ea4:	95 04 08 
    }
}
 8049ea7:	5d                   	pop    %ebp
 8049ea8:	c3                   	ret    

08049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>:

/* Internal constructor. */
static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
{
 8049ea9:	55                   	push   %ebp
 8049eaa:	89 e5                	mov    %esp,%ebp
 8049eac:	83 ec 28             	sub    $0x28,%esp
    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
 8049eaf:	8b 45 08             	mov    0x8(%ebp),%eax
 8049eb2:	8b 00                	mov    (%eax),%eax
 8049eb4:	c7 04 24 24 00 00 00 	movl   $0x24,(%esp)
 8049ebb:	ff d0                	call   *%eax
 8049ebd:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (node)
 8049ec0:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 8049ec4:	74 1b                	je     8049ee1 <_ZL14cJSON_New_ItemPK14internal_hooks+0x38>
    {
        memset(node, '\0', sizeof(cJSON));
 8049ec6:	c7 44 24 08 24 00 00 	movl   $0x24,0x8(%esp)
 8049ecd:	00 
 8049ece:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 8049ed5:	00 
 8049ed6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049ed9:	89 04 24             	mov    %eax,(%esp)
 8049edc:	e8 23 f7 ff ff       	call   8049604 <memset@plt>
    }

    return node;
 8049ee1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 8049ee4:	c9                   	leave  
 8049ee5:	c3                   	ret    

08049ee6 <cJSON_Delete>:

/* Delete a cJSON structure. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
{
 8049ee6:	55                   	push   %ebp
 8049ee7:	89 e5                	mov    %esp,%ebp
 8049ee9:	83 ec 28             	sub    $0x28,%esp
    cJSON *next = NULL;
 8049eec:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    while (item != NULL)
 8049ef3:	e9 94 00 00 00       	jmp    8049f8c <cJSON_Delete+0xa6>
    {
        next = item->next;
 8049ef8:	8b 45 08             	mov    0x8(%ebp),%eax
 8049efb:	8b 00                	mov    (%eax),%eax
 8049efd:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
 8049f00:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f03:	8b 40 0c             	mov    0xc(%eax),%eax
 8049f06:	25 00 01 00 00       	and    $0x100,%eax
 8049f0b:	85 c0                	test   %eax,%eax
 8049f0d:	75 18                	jne    8049f27 <cJSON_Delete+0x41>
 8049f0f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f12:	8b 40 08             	mov    0x8(%eax),%eax
 8049f15:	85 c0                	test   %eax,%eax
 8049f17:	74 0e                	je     8049f27 <cJSON_Delete+0x41>
        {
            cJSON_Delete(item->child);
 8049f19:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f1c:	8b 40 08             	mov    0x8(%eax),%eax
 8049f1f:	89 04 24             	mov    %eax,(%esp)
 8049f22:	e8 bf ff ff ff       	call   8049ee6 <cJSON_Delete>
        }
        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
 8049f27:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f2a:	8b 40 0c             	mov    0xc(%eax),%eax
 8049f2d:	25 00 01 00 00       	and    $0x100,%eax
 8049f32:	85 c0                	test   %eax,%eax
 8049f34:	75 1a                	jne    8049f50 <cJSON_Delete+0x6a>
 8049f36:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f39:	8b 40 10             	mov    0x10(%eax),%eax
 8049f3c:	85 c0                	test   %eax,%eax
 8049f3e:	74 10                	je     8049f50 <cJSON_Delete+0x6a>
        {
            global_hooks.deallocate(item->valuestring);
 8049f40:	a1 08 04 05 08       	mov    0x8050408,%eax
 8049f45:	8b 55 08             	mov    0x8(%ebp),%edx
 8049f48:	8b 52 10             	mov    0x10(%edx),%edx
 8049f4b:	89 14 24             	mov    %edx,(%esp)
 8049f4e:	ff d0                	call   *%eax
        }
        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
 8049f50:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f53:	8b 40 0c             	mov    0xc(%eax),%eax
 8049f56:	25 00 02 00 00       	and    $0x200,%eax
 8049f5b:	85 c0                	test   %eax,%eax
 8049f5d:	75 1a                	jne    8049f79 <cJSON_Delete+0x93>
 8049f5f:	8b 45 08             	mov    0x8(%ebp),%eax
 8049f62:	8b 40 20             	mov    0x20(%eax),%eax
 8049f65:	85 c0                	test   %eax,%eax
 8049f67:	74 10                	je     8049f79 <cJSON_Delete+0x93>
        {
            global_hooks.deallocate(item->string);
 8049f69:	a1 08 04 05 08       	mov    0x8050408,%eax
 8049f6e:	8b 55 08             	mov    0x8(%ebp),%edx
 8049f71:	8b 52 20             	mov    0x20(%edx),%edx
 8049f74:	89 14 24             	mov    %edx,(%esp)
 8049f77:	ff d0                	call   *%eax
        }
        global_hooks.deallocate(item);
 8049f79:	a1 08 04 05 08       	mov    0x8050408,%eax
 8049f7e:	8b 55 08             	mov    0x8(%ebp),%edx
 8049f81:	89 14 24             	mov    %edx,(%esp)
 8049f84:	ff d0                	call   *%eax
        item = next;
 8049f86:	8b 45 f4             	mov    -0xc(%ebp),%eax
 8049f89:	89 45 08             	mov    %eax,0x8(%ebp)

/* Delete a cJSON structure. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
{
    cJSON *next = NULL;
    while (item != NULL)
 8049f8c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 8049f90:	0f 95 c0             	setne  %al
 8049f93:	84 c0                	test   %al,%al
 8049f95:	0f 85 5d ff ff ff    	jne    8049ef8 <cJSON_Delete+0x12>
            global_hooks.deallocate(item->string);
        }
        global_hooks.deallocate(item);
        item = next;
    }
}
 8049f9b:	c9                   	leave  
 8049f9c:	c3                   	ret    

08049f9d <_ZL17get_decimal_pointv>:

/* get the decimal point character of the current locale */
static unsigned char get_decimal_point(void)
{
 8049f9d:	55                   	push   %ebp
 8049f9e:	89 e5                	mov    %esp,%ebp
#ifdef ENABLE_LOCALES
    struct lconv *lconv = localeconv();
    return (unsigned char) lconv->decimal_point[0];
#else
    return '.';
 8049fa0:	b8 2e 00 00 00       	mov    $0x2e,%eax
#endif
}
 8049fa5:	5d                   	pop    %ebp
 8049fa6:	c3                   	ret    

08049fa7 <_ZL12parse_numberP5cJSONP12parse_buffer>:
/* get a pointer to the buffer at the position */
#define buffer_at_offset(buffer) ((buffer)->content + (buffer)->offset)

/* Parse the input text to generate a number, and populate the result into item. */
static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
{
 8049fa7:	55                   	push   %ebp
 8049fa8:	89 e5                	mov    %esp,%ebp
 8049faa:	53                   	push   %ebx
 8049fab:	81 ec 84 00 00 00    	sub    $0x84,%esp
    double number = 0;
 8049fb1:	d9 ee                	fldz   
 8049fb3:	dd 5d e8             	fstpl  -0x18(%ebp)
    unsigned char *after_end = NULL;
 8049fb6:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned char number_c_string[64];
    unsigned char decimal_point = get_decimal_point();
 8049fbd:	e8 db ff ff ff       	call   8049f9d <_ZL17get_decimal_pointv>
 8049fc2:	88 45 f3             	mov    %al,-0xd(%ebp)
    size_t i = 0;
 8049fc5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if ((input_buffer == NULL) || (input_buffer->content == NULL))
 8049fcc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 8049fd0:	74 09                	je     8049fdb <_ZL12parse_numberP5cJSONP12parse_buffer+0x34>
 8049fd2:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049fd5:	8b 00                	mov    (%eax),%eax
 8049fd7:	85 c0                	test   %eax,%eax
 8049fd9:	75 0a                	jne    8049fe5 <_ZL12parse_numberP5cJSONP12parse_buffer+0x3e>
    {
        return false;
 8049fdb:	b8 00 00 00 00       	mov    $0x0,%eax
 8049fe0:	e9 62 01 00 00       	jmp    804a147 <_ZL12parse_numberP5cJSONP12parse_buffer+0x1a0>
    }

    /* copy the number into a temporary buffer and replace '.' with the decimal point
     * of the current locale (for strtod)
     * This also takes care of '\0' not necessarily being available for marking the end of the input */
    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
 8049fe5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 8049fec:	eb 55                	jmp    804a043 <_ZL12parse_numberP5cJSONP12parse_buffer+0x9c>
    {
        switch (buffer_at_offset(input_buffer)[i])
 8049fee:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049ff1:	8b 10                	mov    (%eax),%edx
 8049ff3:	8b 45 0c             	mov    0xc(%ebp),%eax
 8049ff6:	8b 40 08             	mov    0x8(%eax),%eax
 8049ff9:	03 45 f4             	add    -0xc(%ebp),%eax
 8049ffc:	8d 04 02             	lea    (%edx,%eax,1),%eax
 8049fff:	0f b6 00             	movzbl (%eax),%eax
 804a002:	0f b6 c0             	movzbl %al,%eax
 804a005:	83 e8 2b             	sub    $0x2b,%eax
 804a008:	83 f8 3a             	cmp    $0x3a,%eax
 804a00b:	77 6d                	ja     804a07a <_ZL12parse_numberP5cJSONP12parse_buffer+0xd3>
 804a00d:	8b 04 85 1c de 04 08 	mov    0x804de1c(,%eax,4),%eax
 804a014:	ff e0                	jmp    *%eax
            case '9':
            case '+':
            case '-':
            case 'e':
            case 'E':
                number_c_string[i] = buffer_at_offset(input_buffer)[i];
 804a016:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a019:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a01c:	8b 0a                	mov    (%edx),%ecx
 804a01e:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a021:	8b 52 08             	mov    0x8(%edx),%edx
 804a024:	03 55 f4             	add    -0xc(%ebp),%edx
 804a027:	8d 14 11             	lea    (%ecx,%edx,1),%edx
 804a02a:	0f b6 12             	movzbl (%edx),%edx
 804a02d:	88 54 05 a4          	mov    %dl,-0x5c(%ebp,%eax,1)
                break;
 804a031:	eb 0c                	jmp    804a03f <_ZL12parse_numberP5cJSONP12parse_buffer+0x98>

            case '.':
                number_c_string[i] = decimal_point;
 804a033:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a036:	0f b6 55 f3          	movzbl -0xd(%ebp),%edx
 804a03a:	88 54 05 a4          	mov    %dl,-0x5c(%ebp,%eax,1)
                break;
 804a03e:	90                   	nop
    }

    /* copy the number into a temporary buffer and replace '.' with the decimal point
     * of the current locale (for strtod)
     * This also takes care of '\0' not necessarily being available for marking the end of the input */
    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
 804a03f:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804a043:	83 7d f4 3e          	cmpl   $0x3e,-0xc(%ebp)
 804a047:	77 22                	ja     804a06b <_ZL12parse_numberP5cJSONP12parse_buffer+0xc4>
 804a049:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804a04d:	74 1c                	je     804a06b <_ZL12parse_numberP5cJSONP12parse_buffer+0xc4>
 804a04f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a052:	8b 40 08             	mov    0x8(%eax),%eax
 804a055:	89 c2                	mov    %eax,%edx
 804a057:	03 55 f4             	add    -0xc(%ebp),%edx
 804a05a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a05d:	8b 40 04             	mov    0x4(%eax),%eax
 804a060:	39 c2                	cmp    %eax,%edx
 804a062:	73 07                	jae    804a06b <_ZL12parse_numberP5cJSONP12parse_buffer+0xc4>
 804a064:	b8 01 00 00 00       	mov    $0x1,%eax
 804a069:	eb 05                	jmp    804a070 <_ZL12parse_numberP5cJSONP12parse_buffer+0xc9>
 804a06b:	b8 00 00 00 00       	mov    $0x0,%eax
 804a070:	84 c0                	test   %al,%al
 804a072:	0f 85 76 ff ff ff    	jne    8049fee <_ZL12parse_numberP5cJSONP12parse_buffer+0x47>
 804a078:	eb 04                	jmp    804a07e <_ZL12parse_numberP5cJSONP12parse_buffer+0xd7>
            case '.':
                number_c_string[i] = decimal_point;
                break;

            default:
                goto loop_end;
 804a07a:	90                   	nop
 804a07b:	eb 01                	jmp    804a07e <_ZL12parse_numberP5cJSONP12parse_buffer+0xd7>
 804a07d:	90                   	nop
        }
    }
loop_end:
    number_c_string[i] = '\0';
 804a07e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a081:	c6 44 05 a4 00       	movb   $0x0,-0x5c(%ebp,%eax,1)

    number = strtod((const char*)number_c_string, (char**)&after_end);
 804a086:	8d 55 e4             	lea    -0x1c(%ebp),%edx
 804a089:	8d 45 a4             	lea    -0x5c(%ebp),%eax
 804a08c:	89 54 24 04          	mov    %edx,0x4(%esp)
 804a090:	89 04 24             	mov    %eax,(%esp)
 804a093:	e8 3c f5 ff ff       	call   80495d4 <strtod@plt>
 804a098:	dd 5d e8             	fstpl  -0x18(%ebp)
    if (number_c_string == after_end)
 804a09b:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a09e:	8d 45 a4             	lea    -0x5c(%ebp),%eax
 804a0a1:	39 c2                	cmp    %eax,%edx
 804a0a3:	75 0a                	jne    804a0af <_ZL12parse_numberP5cJSONP12parse_buffer+0x108>
    {
        return false; /* parse_error */
 804a0a5:	b8 00 00 00 00       	mov    $0x0,%eax
 804a0aa:	e9 98 00 00 00       	jmp    804a147 <_ZL12parse_numberP5cJSONP12parse_buffer+0x1a0>
    }

    item->valuedouble = number;
 804a0af:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0b2:	dd 45 e8             	fldl   -0x18(%ebp)
 804a0b5:	dd 58 18             	fstpl  0x18(%eax)

    /* use saturation in case of overflow */
    if (number >= INT_MAX)
 804a0b8:	dd 45 e8             	fldl   -0x18(%ebp)
 804a0bb:	dd 05 90 e0 04 08    	fldl   0x804e090
 804a0c1:	d9 c9                	fxch   %st(1)
 804a0c3:	df e9                	fucomip %st(1),%st
 804a0c5:	dd d8                	fstp   %st(0)
 804a0c7:	0f 93 c0             	setae  %al
 804a0ca:	84 c0                	test   %al,%al
 804a0cc:	74 0c                	je     804a0da <_ZL12parse_numberP5cJSONP12parse_buffer+0x133>
    {
        item->valueint = INT_MAX;
 804a0ce:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0d1:	c7 40 14 ff ff ff 7f 	movl   $0x7fffffff,0x14(%eax)
 804a0d8:	eb 42                	jmp    804a11c <_ZL12parse_numberP5cJSONP12parse_buffer+0x175>
    }
    else if (number <= INT_MIN)
 804a0da:	dd 45 e8             	fldl   -0x18(%ebp)
 804a0dd:	dd 05 98 e0 04 08    	fldl   0x804e098
 804a0e3:	df e9                	fucomip %st(1),%st
 804a0e5:	dd d8                	fstp   %st(0)
 804a0e7:	0f 93 c0             	setae  %al
 804a0ea:	84 c0                	test   %al,%al
 804a0ec:	74 0c                	je     804a0fa <_ZL12parse_numberP5cJSONP12parse_buffer+0x153>
    {
        item->valueint = INT_MIN;
 804a0ee:	8b 45 08             	mov    0x8(%ebp),%eax
 804a0f1:	c7 40 14 00 00 00 80 	movl   $0x80000000,0x14(%eax)
 804a0f8:	eb 22                	jmp    804a11c <_ZL12parse_numberP5cJSONP12parse_buffer+0x175>
    }
    else
    {
        item->valueint = (int)number;
 804a0fa:	dd 45 e8             	fldl   -0x18(%ebp)
 804a0fd:	d9 7d 96             	fnstcw -0x6a(%ebp)
 804a100:	0f b7 45 96          	movzwl -0x6a(%ebp),%eax
 804a104:	b4 0c                	mov    $0xc,%ah
 804a106:	66 89 45 94          	mov    %ax,-0x6c(%ebp)
 804a10a:	d9 6d 94             	fldcw  -0x6c(%ebp)
 804a10d:	db 5d 90             	fistpl -0x70(%ebp)
 804a110:	d9 6d 96             	fldcw  -0x6a(%ebp)
 804a113:	8b 55 90             	mov    -0x70(%ebp),%edx
 804a116:	8b 45 08             	mov    0x8(%ebp),%eax
 804a119:	89 50 14             	mov    %edx,0x14(%eax)
    }

    item->type = cJSON_Number;
 804a11c:	8b 45 08             	mov    0x8(%ebp),%eax
 804a11f:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)

    input_buffer->offset += (size_t)(after_end - number_c_string);
 804a126:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a129:	8b 50 08             	mov    0x8(%eax),%edx
 804a12c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a12f:	89 c1                	mov    %eax,%ecx
 804a131:	8d 45 a4             	lea    -0x5c(%ebp),%eax
 804a134:	89 cb                	mov    %ecx,%ebx
 804a136:	29 c3                	sub    %eax,%ebx
 804a138:	89 d8                	mov    %ebx,%eax
 804a13a:	01 c2                	add    %eax,%edx
 804a13c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a13f:	89 50 08             	mov    %edx,0x8(%eax)
    return true;
 804a142:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804a147:	81 c4 84 00 00 00    	add    $0x84,%esp
 804a14d:	5b                   	pop    %ebx
 804a14e:	5d                   	pop    %ebp
 804a14f:	c3                   	ret    

0804a150 <cJSON_SetNumberHelper>:

/* don't ask me, but the original cJSON_SetNumberValue returns an integer or double */
CJSON_PUBLIC(double) cJSON_SetNumberHelper(cJSON *object, double number)
{
 804a150:	55                   	push   %ebp
 804a151:	89 e5                	mov    %esp,%ebp
 804a153:	83 ec 10             	sub    $0x10,%esp
 804a156:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a159:	89 45 f8             	mov    %eax,-0x8(%ebp)
 804a15c:	8b 45 10             	mov    0x10(%ebp),%eax
 804a15f:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (number >= INT_MAX)
 804a162:	dd 45 f8             	fldl   -0x8(%ebp)
 804a165:	dd 05 90 e0 04 08    	fldl   0x804e090
 804a16b:	d9 c9                	fxch   %st(1)
 804a16d:	df e9                	fucomip %st(1),%st
 804a16f:	dd d8                	fstp   %st(0)
 804a171:	0f 93 c0             	setae  %al
 804a174:	84 c0                	test   %al,%al
 804a176:	74 0c                	je     804a184 <cJSON_SetNumberHelper+0x34>
    {
        object->valueint = INT_MAX;
 804a178:	8b 45 08             	mov    0x8(%ebp),%eax
 804a17b:	c7 40 14 ff ff ff 7f 	movl   $0x7fffffff,0x14(%eax)
 804a182:	eb 42                	jmp    804a1c6 <cJSON_SetNumberHelper+0x76>
    }
    else if (number <= INT_MIN)
 804a184:	dd 45 f8             	fldl   -0x8(%ebp)
 804a187:	dd 05 98 e0 04 08    	fldl   0x804e098
 804a18d:	df e9                	fucomip %st(1),%st
 804a18f:	dd d8                	fstp   %st(0)
 804a191:	0f 93 c0             	setae  %al
 804a194:	84 c0                	test   %al,%al
 804a196:	74 0c                	je     804a1a4 <cJSON_SetNumberHelper+0x54>
    {
        object->valueint = INT_MIN;
 804a198:	8b 45 08             	mov    0x8(%ebp),%eax
 804a19b:	c7 40 14 00 00 00 80 	movl   $0x80000000,0x14(%eax)
 804a1a2:	eb 22                	jmp    804a1c6 <cJSON_SetNumberHelper+0x76>
    }
    else
    {
        object->valueint = (int)number;
 804a1a4:	dd 45 f8             	fldl   -0x8(%ebp)
 804a1a7:	d9 7d f6             	fnstcw -0xa(%ebp)
 804a1aa:	0f b7 45 f6          	movzwl -0xa(%ebp),%eax
 804a1ae:	b4 0c                	mov    $0xc,%ah
 804a1b0:	66 89 45 f4          	mov    %ax,-0xc(%ebp)
 804a1b4:	d9 6d f4             	fldcw  -0xc(%ebp)
 804a1b7:	db 5d f0             	fistpl -0x10(%ebp)
 804a1ba:	d9 6d f6             	fldcw  -0xa(%ebp)
 804a1bd:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a1c0:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1c3:	89 50 14             	mov    %edx,0x14(%eax)
    }

    return object->valuedouble = number;
 804a1c6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1c9:	dd 45 f8             	fldl   -0x8(%ebp)
 804a1cc:	dd 58 18             	fstpl  0x18(%eax)
 804a1cf:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1d2:	dd 40 18             	fldl   0x18(%eax)
}
 804a1d5:	c9                   	leave  
 804a1d6:	c3                   	ret    

0804a1d7 <_ZL6ensureP11printbufferj>:
    internal_hooks hooks;
} printbuffer;

/* realloc printbuffer if necessary to have at least "needed" bytes more */
static unsigned char* ensure(printbuffer * const p, size_t needed)
{
 804a1d7:	55                   	push   %ebp
 804a1d8:	89 e5                	mov    %esp,%ebp
 804a1da:	83 ec 28             	sub    $0x28,%esp
    unsigned char *newbuffer = NULL;
 804a1dd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    size_t newsize = 0;
 804a1e4:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if ((p == NULL) || (p->buffer == NULL))
 804a1eb:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804a1ef:	74 09                	je     804a1fa <_ZL6ensureP11printbufferj+0x23>
 804a1f1:	8b 45 08             	mov    0x8(%ebp),%eax
 804a1f4:	8b 00                	mov    (%eax),%eax
 804a1f6:	85 c0                	test   %eax,%eax
 804a1f8:	75 0a                	jne    804a204 <_ZL6ensureP11printbufferj+0x2d>
    {
        return NULL;
 804a1fa:	b8 00 00 00 00       	mov    $0x0,%eax
 804a1ff:	e9 8e 01 00 00       	jmp    804a392 <_ZL6ensureP11printbufferj+0x1bb>
    }

    if ((p->length > 0) && (p->offset >= p->length))
 804a204:	8b 45 08             	mov    0x8(%ebp),%eax
 804a207:	8b 40 04             	mov    0x4(%eax),%eax
 804a20a:	85 c0                	test   %eax,%eax
 804a20c:	74 1a                	je     804a228 <_ZL6ensureP11printbufferj+0x51>
 804a20e:	8b 45 08             	mov    0x8(%ebp),%eax
 804a211:	8b 50 08             	mov    0x8(%eax),%edx
 804a214:	8b 45 08             	mov    0x8(%ebp),%eax
 804a217:	8b 40 04             	mov    0x4(%eax),%eax
 804a21a:	39 c2                	cmp    %eax,%edx
 804a21c:	72 0a                	jb     804a228 <_ZL6ensureP11printbufferj+0x51>
    {
        /* make sure that offset is valid */
        return NULL;
 804a21e:	b8 00 00 00 00       	mov    $0x0,%eax
 804a223:	e9 6a 01 00 00       	jmp    804a392 <_ZL6ensureP11printbufferj+0x1bb>
    }

    if (needed > INT_MAX)
 804a228:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a22b:	85 c0                	test   %eax,%eax
 804a22d:	79 0a                	jns    804a239 <_ZL6ensureP11printbufferj+0x62>
    {
        /* sizes bigger than INT_MAX are currently not supported */
        return NULL;
 804a22f:	b8 00 00 00 00       	mov    $0x0,%eax
 804a234:	e9 59 01 00 00       	jmp    804a392 <_ZL6ensureP11printbufferj+0x1bb>
    }

    needed += p->offset + 1;
 804a239:	8b 45 08             	mov    0x8(%ebp),%eax
 804a23c:	8b 40 08             	mov    0x8(%eax),%eax
 804a23f:	03 45 0c             	add    0xc(%ebp),%eax
 804a242:	83 c0 01             	add    $0x1,%eax
 804a245:	89 45 0c             	mov    %eax,0xc(%ebp)
    if (needed <= p->length)
 804a248:	8b 45 08             	mov    0x8(%ebp),%eax
 804a24b:	8b 40 04             	mov    0x4(%eax),%eax
 804a24e:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804a251:	72 13                	jb     804a266 <_ZL6ensureP11printbufferj+0x8f>
    {
        return p->buffer + p->offset;
 804a253:	8b 45 08             	mov    0x8(%ebp),%eax
 804a256:	8b 10                	mov    (%eax),%edx
 804a258:	8b 45 08             	mov    0x8(%ebp),%eax
 804a25b:	8b 40 08             	mov    0x8(%eax),%eax
 804a25e:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a261:	e9 2c 01 00 00       	jmp    804a392 <_ZL6ensureP11printbufferj+0x1bb>
    }

    if (p->noalloc) {
 804a266:	8b 45 08             	mov    0x8(%ebp),%eax
 804a269:	8b 40 10             	mov    0x10(%eax),%eax
 804a26c:	85 c0                	test   %eax,%eax
 804a26e:	74 0a                	je     804a27a <_ZL6ensureP11printbufferj+0xa3>
        return NULL;
 804a270:	b8 00 00 00 00       	mov    $0x0,%eax
 804a275:	e9 18 01 00 00       	jmp    804a392 <_ZL6ensureP11printbufferj+0x1bb>
    }

    /* calculate new buffer size */
    if (needed > (INT_MAX / 2))
 804a27a:	81 7d 0c ff ff ff 3f 	cmpl   $0x3fffffff,0xc(%ebp)
 804a281:	76 1a                	jbe    804a29d <_ZL6ensureP11printbufferj+0xc6>
    {
        /* overflow of int, use INT_MAX if possible */
        if (needed <= INT_MAX)
 804a283:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a286:	85 c0                	test   %eax,%eax
 804a288:	78 09                	js     804a293 <_ZL6ensureP11printbufferj+0xbc>
        {
            newsize = INT_MAX;
 804a28a:	c7 45 f4 ff ff ff 7f 	movl   $0x7fffffff,-0xc(%ebp)
 804a291:	eb 12                	jmp    804a2a5 <_ZL6ensureP11printbufferj+0xce>
        }
        else
        {
            return NULL;
 804a293:	b8 00 00 00 00       	mov    $0x0,%eax
 804a298:	e9 f5 00 00 00       	jmp    804a392 <_ZL6ensureP11printbufferj+0x1bb>
        }
    }
    else
    {
        newsize = needed * 2;
 804a29d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a2a0:	01 c0                	add    %eax,%eax
 804a2a2:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (p->hooks.reallocate != NULL)
 804a2a5:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2a8:	8b 40 20             	mov    0x20(%eax),%eax
 804a2ab:	85 c0                	test   %eax,%eax
 804a2ad:	74 51                	je     804a300 <_ZL6ensureP11printbufferj+0x129>
    {
        /* reallocate with realloc if available */
        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
 804a2af:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2b2:	8b 40 20             	mov    0x20(%eax),%eax
 804a2b5:	8b 55 08             	mov    0x8(%ebp),%edx
 804a2b8:	8b 12                	mov    (%edx),%edx
 804a2ba:	8b 4d f4             	mov    -0xc(%ebp),%ecx
 804a2bd:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 804a2c1:	89 14 24             	mov    %edx,(%esp)
 804a2c4:	ff d0                	call   *%eax
 804a2c6:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (newbuffer == NULL)
 804a2c9:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804a2cd:	0f 85 a5 00 00 00    	jne    804a378 <_ZL6ensureP11printbufferj+0x1a1>
        {
            p->hooks.deallocate(p->buffer);
 804a2d3:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2d6:	8b 40 1c             	mov    0x1c(%eax),%eax
 804a2d9:	8b 55 08             	mov    0x8(%ebp),%edx
 804a2dc:	8b 12                	mov    (%edx),%edx
 804a2de:	89 14 24             	mov    %edx,(%esp)
 804a2e1:	ff d0                	call   *%eax
            p->length = 0;
 804a2e3:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2e6:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
            p->buffer = NULL;
 804a2ed:	8b 45 08             	mov    0x8(%ebp),%eax
 804a2f0:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

            return NULL;
 804a2f6:	b8 00 00 00 00       	mov    $0x0,%eax
 804a2fb:	e9 92 00 00 00       	jmp    804a392 <_ZL6ensureP11printbufferj+0x1bb>
        }
    }
    else
    {
        /* otherwise reallocate manually */
        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
 804a300:	8b 45 08             	mov    0x8(%ebp),%eax
 804a303:	8b 40 18             	mov    0x18(%eax),%eax
 804a306:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a309:	89 14 24             	mov    %edx,(%esp)
 804a30c:	ff d0                	call   *%eax
 804a30e:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (!newbuffer)
 804a311:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804a315:	75 2a                	jne    804a341 <_ZL6ensureP11printbufferj+0x16a>
        {
            p->hooks.deallocate(p->buffer);
 804a317:	8b 45 08             	mov    0x8(%ebp),%eax
 804a31a:	8b 40 1c             	mov    0x1c(%eax),%eax
 804a31d:	8b 55 08             	mov    0x8(%ebp),%edx
 804a320:	8b 12                	mov    (%edx),%edx
 804a322:	89 14 24             	mov    %edx,(%esp)
 804a325:	ff d0                	call   *%eax
            p->length = 0;
 804a327:	8b 45 08             	mov    0x8(%ebp),%eax
 804a32a:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
            p->buffer = NULL;
 804a331:	8b 45 08             	mov    0x8(%ebp),%eax
 804a334:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

            return NULL;
 804a33a:	b8 00 00 00 00       	mov    $0x0,%eax
 804a33f:	eb 51                	jmp    804a392 <_ZL6ensureP11printbufferj+0x1bb>
        }
        if (newbuffer)
 804a341:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804a345:	74 21                	je     804a368 <_ZL6ensureP11printbufferj+0x191>
        {
            memcpy(newbuffer, p->buffer, p->offset + 1);
 804a347:	8b 45 08             	mov    0x8(%ebp),%eax
 804a34a:	8b 40 08             	mov    0x8(%eax),%eax
 804a34d:	8d 50 01             	lea    0x1(%eax),%edx
 804a350:	8b 45 08             	mov    0x8(%ebp),%eax
 804a353:	8b 00                	mov    (%eax),%eax
 804a355:	89 54 24 08          	mov    %edx,0x8(%esp)
 804a359:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a35d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a360:	89 04 24             	mov    %eax,(%esp)
 804a363:	e8 fc f2 ff ff       	call   8049664 <memcpy@plt>
        }
        p->hooks.deallocate(p->buffer);
 804a368:	8b 45 08             	mov    0x8(%ebp),%eax
 804a36b:	8b 40 1c             	mov    0x1c(%eax),%eax
 804a36e:	8b 55 08             	mov    0x8(%ebp),%edx
 804a371:	8b 12                	mov    (%edx),%edx
 804a373:	89 14 24             	mov    %edx,(%esp)
 804a376:	ff d0                	call   *%eax
    }
    p->length = newsize;
 804a378:	8b 45 08             	mov    0x8(%ebp),%eax
 804a37b:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804a37e:	89 50 04             	mov    %edx,0x4(%eax)
    p->buffer = newbuffer;
 804a381:	8b 45 08             	mov    0x8(%ebp),%eax
 804a384:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804a387:	89 10                	mov    %edx,(%eax)

    return newbuffer + p->offset;
 804a389:	8b 45 08             	mov    0x8(%ebp),%eax
 804a38c:	8b 40 08             	mov    0x8(%eax),%eax
 804a38f:	03 45 f0             	add    -0x10(%ebp),%eax
}
 804a392:	c9                   	leave  
 804a393:	c3                   	ret    

0804a394 <_ZL13update_offsetP11printbuffer>:

/* calculate the new length of the string in a printbuffer and update the offset */
static void update_offset(printbuffer * const buffer)
{
 804a394:	55                   	push   %ebp
 804a395:	89 e5                	mov    %esp,%ebp
 804a397:	53                   	push   %ebx
 804a398:	83 ec 24             	sub    $0x24,%esp
    const unsigned char *buffer_pointer = NULL;
 804a39b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if ((buffer == NULL) || (buffer->buffer == NULL))
 804a3a2:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804a3a6:	74 36                	je     804a3de <_ZL13update_offsetP11printbuffer+0x4a>
 804a3a8:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3ab:	8b 00                	mov    (%eax),%eax
 804a3ad:	85 c0                	test   %eax,%eax
 804a3af:	74 30                	je     804a3e1 <_ZL13update_offsetP11printbuffer+0x4d>
    {
        return;
    }
    buffer_pointer = buffer->buffer + buffer->offset;
 804a3b1:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3b4:	8b 10                	mov    (%eax),%edx
 804a3b6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3b9:	8b 40 08             	mov    0x8(%eax),%eax
 804a3bc:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a3bf:	89 45 f4             	mov    %eax,-0xc(%ebp)

    buffer->offset += strlen((const char*)buffer_pointer);
 804a3c2:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3c5:	8b 58 08             	mov    0x8(%eax),%ebx
 804a3c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804a3cb:	89 04 24             	mov    %eax,(%esp)
 804a3ce:	e8 a1 f2 ff ff       	call   8049674 <strlen@plt>
 804a3d3:	8d 14 03             	lea    (%ebx,%eax,1),%edx
 804a3d6:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3d9:	89 50 08             	mov    %edx,0x8(%eax)
 804a3dc:	eb 04                	jmp    804a3e2 <_ZL13update_offsetP11printbuffer+0x4e>
static void update_offset(printbuffer * const buffer)
{
    const unsigned char *buffer_pointer = NULL;
    if ((buffer == NULL) || (buffer->buffer == NULL))
    {
        return;
 804a3de:	90                   	nop
 804a3df:	eb 01                	jmp    804a3e2 <_ZL13update_offsetP11printbuffer+0x4e>
 804a3e1:	90                   	nop
    }
    buffer_pointer = buffer->buffer + buffer->offset;

    buffer->offset += strlen((const char*)buffer_pointer);
}
 804a3e2:	83 c4 24             	add    $0x24,%esp
 804a3e5:	5b                   	pop    %ebx
 804a3e6:	5d                   	pop    %ebp
 804a3e7:	c3                   	ret    

0804a3e8 <_ZL12print_numberPK5cJSONP11printbuffer>:

/* Render the number nicely from the given item into a string. */
static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
{
 804a3e8:	55                   	push   %ebp
 804a3e9:	89 e5                	mov    %esp,%ebp
 804a3eb:	83 ec 58             	sub    $0x58,%esp
    unsigned char *output_pointer = NULL;
 804a3ee:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    double d = item->valuedouble;
 804a3f5:	8b 45 08             	mov    0x8(%ebp),%eax
 804a3f8:	dd 40 18             	fldl   0x18(%eax)
 804a3fb:	dd 5d e0             	fstpl  -0x20(%ebp)
    int length = 0;
 804a3fe:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    size_t i = 0;
 804a405:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    unsigned char number_buffer[26]; /* temporary buffer to print the number into */
    unsigned char decimal_point = get_decimal_point();
 804a40c:	e8 8c fb ff ff       	call   8049f9d <_ZL17get_decimal_pointv>
 804a411:	88 45 f7             	mov    %al,-0x9(%ebp)
    double test;

    if (output_buffer == NULL)
 804a414:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804a418:	75 0a                	jne    804a424 <_ZL12print_numberPK5cJSONP11printbuffer+0x3c>
    {
        return false;
 804a41a:	b8 00 00 00 00       	mov    $0x0,%eax
 804a41f:	e9 54 01 00 00       	jmp    804a578 <_ZL12print_numberPK5cJSONP11printbuffer+0x190>
    }

    /* This checks for NaN and Infinity */
    if ((d * 0) != 0)
 804a424:	dd 45 e0             	fldl   -0x20(%ebp)
 804a427:	d9 ee                	fldz   
 804a429:	de c9                	fmulp  %st,%st(1)
 804a42b:	d9 ee                	fldz   
 804a42d:	d9 c9                	fxch   %st(1)
 804a42f:	df e9                	fucomip %st(1),%st
 804a431:	dd d8                	fstp   %st(0)
 804a433:	7a 02                	jp     804a437 <_ZL12print_numberPK5cJSONP11printbuffer+0x4f>
 804a435:	74 24                	je     804a45b <_ZL12print_numberPK5cJSONP11printbuffer+0x73>
    {
        length = sprintf((char*)number_buffer, "null");
 804a437:	8d 45 c2             	lea    -0x3e(%ebp),%eax
 804a43a:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
 804a441:	00 
 804a442:	c7 44 24 04 08 df 04 	movl   $0x804df08,0x4(%esp)
 804a449:	08 
 804a44a:	89 04 24             	mov    %eax,(%esp)
 804a44d:	e8 12 f2 ff ff       	call   8049664 <memcpy@plt>
 804a452:	c7 45 ec 04 00 00 00 	movl   $0x4,-0x14(%ebp)
 804a459:	eb 79                	jmp    804a4d4 <_ZL12print_numberPK5cJSONP11printbuffer+0xec>
    }
    else
    {
        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
        length = sprintf((char*)number_buffer, "%1.15g", d);
 804a45b:	8d 45 c2             	lea    -0x3e(%ebp),%eax
 804a45e:	dd 45 e0             	fldl   -0x20(%ebp)
 804a461:	dd 5c 24 08          	fstpl  0x8(%esp)
 804a465:	c7 44 24 04 0d df 04 	movl   $0x804df0d,0x4(%esp)
 804a46c:	08 
 804a46d:	89 04 24             	mov    %eax,(%esp)
 804a470:	e8 0f f1 ff ff       	call   8049584 <sprintf@plt>
 804a475:	89 45 ec             	mov    %eax,-0x14(%ebp)

        /* Check whether the original double can be recovered */
        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || ((double)test != d))
 804a478:	8d 45 c2             	lea    -0x3e(%ebp),%eax
 804a47b:	8d 55 b8             	lea    -0x48(%ebp),%edx
 804a47e:	89 54 24 08          	mov    %edx,0x8(%esp)
 804a482:	c7 44 24 04 14 df 04 	movl   $0x804df14,0x4(%esp)
 804a489:	08 
 804a48a:	89 04 24             	mov    %eax,(%esp)
 804a48d:	e8 22 f2 ff ff       	call   80496b4 <sscanf@plt>
 804a492:	83 f8 01             	cmp    $0x1,%eax
 804a495:	75 10                	jne    804a4a7 <_ZL12print_numberPK5cJSONP11printbuffer+0xbf>
 804a497:	dd 45 b8             	fldl   -0x48(%ebp)
 804a49a:	dd 45 e0             	fldl   -0x20(%ebp)
 804a49d:	d9 c9                	fxch   %st(1)
 804a49f:	df e9                	fucomip %st(1),%st
 804a4a1:	dd d8                	fstp   %st(0)
 804a4a3:	7a 02                	jp     804a4a7 <_ZL12print_numberPK5cJSONP11printbuffer+0xbf>
 804a4a5:	74 07                	je     804a4ae <_ZL12print_numberPK5cJSONP11printbuffer+0xc6>
 804a4a7:	b8 01 00 00 00       	mov    $0x1,%eax
 804a4ac:	eb 05                	jmp    804a4b3 <_ZL12print_numberPK5cJSONP11printbuffer+0xcb>
 804a4ae:	b8 00 00 00 00       	mov    $0x0,%eax
 804a4b3:	84 c0                	test   %al,%al
 804a4b5:	74 1d                	je     804a4d4 <_ZL12print_numberPK5cJSONP11printbuffer+0xec>
        {
            /* If not, print with 17 decimal places of precision */
            length = sprintf((char*)number_buffer, "%1.17g", d);
 804a4b7:	8d 45 c2             	lea    -0x3e(%ebp),%eax
 804a4ba:	dd 45 e0             	fldl   -0x20(%ebp)
 804a4bd:	dd 5c 24 08          	fstpl  0x8(%esp)
 804a4c1:	c7 44 24 04 18 df 04 	movl   $0x804df18,0x4(%esp)
 804a4c8:	08 
 804a4c9:	89 04 24             	mov    %eax,(%esp)
 804a4cc:	e8 b3 f0 ff ff       	call   8049584 <sprintf@plt>
 804a4d1:	89 45 ec             	mov    %eax,-0x14(%ebp)
        }
    }

    /* sprintf failed or buffer overrun occured */
    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
 804a4d4:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804a4d8:	78 06                	js     804a4e0 <_ZL12print_numberPK5cJSONP11printbuffer+0xf8>
 804a4da:	83 7d ec 19          	cmpl   $0x19,-0x14(%ebp)
 804a4de:	7e 0a                	jle    804a4ea <_ZL12print_numberPK5cJSONP11printbuffer+0x102>
    {
        return false;
 804a4e0:	b8 00 00 00 00       	mov    $0x0,%eax
 804a4e5:	e9 8e 00 00 00       	jmp    804a578 <_ZL12print_numberPK5cJSONP11printbuffer+0x190>
    }

    /* reserve appropriate space in the output */
    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
 804a4ea:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a4ed:	83 c0 01             	add    $0x1,%eax
 804a4f0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804a4f4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a4f7:	89 04 24             	mov    %eax,(%esp)
 804a4fa:	e8 d8 fc ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804a4ff:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (output_pointer == NULL)
 804a502:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
 804a506:	75 07                	jne    804a50f <_ZL12print_numberPK5cJSONP11printbuffer+0x127>
    {
        return false;
 804a508:	b8 00 00 00 00       	mov    $0x0,%eax
 804a50d:	eb 69                	jmp    804a578 <_ZL12print_numberPK5cJSONP11printbuffer+0x190>
    }

    /* copy the printed number to the output and replace locale
     * dependent decimal point with '.' */
    for (i = 0; i < ((size_t)length); i++)
 804a50f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 804a516:	eb 31                	jmp    804a549 <_ZL12print_numberPK5cJSONP11printbuffer+0x161>
    {
        if (number_buffer[i] == decimal_point)
 804a518:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a51b:	0f b6 44 05 c2       	movzbl -0x3e(%ebp,%eax,1),%eax
 804a520:	3a 45 f7             	cmp    -0x9(%ebp),%al
 804a523:	75 0e                	jne    804a533 <_ZL12print_numberPK5cJSONP11printbuffer+0x14b>
        {
            output_pointer[i] = '.';
 804a525:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a528:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a52b:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a52e:	c6 00 2e             	movb   $0x2e,(%eax)
            continue;
 804a531:	eb 12                	jmp    804a545 <_ZL12print_numberPK5cJSONP11printbuffer+0x15d>
        }

        output_pointer[i] = number_buffer[i];
 804a533:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a536:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a539:	01 c2                	add    %eax,%edx
 804a53b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a53e:	0f b6 44 05 c2       	movzbl -0x3e(%ebp,%eax,1),%eax
 804a543:	88 02                	mov    %al,(%edx)
        return false;
    }

    /* copy the printed number to the output and replace locale
     * dependent decimal point with '.' */
    for (i = 0; i < ((size_t)length); i++)
 804a545:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 804a549:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a54c:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 804a54f:	0f 97 c0             	seta   %al
 804a552:	84 c0                	test   %al,%al
 804a554:	75 c2                	jne    804a518 <_ZL12print_numberPK5cJSONP11printbuffer+0x130>
            continue;
        }

        output_pointer[i] = number_buffer[i];
    }
    output_pointer[i] = '\0';
 804a556:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a559:	8b 55 dc             	mov    -0x24(%ebp),%edx
 804a55c:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a55f:	c6 00 00             	movb   $0x0,(%eax)

    output_buffer->offset += (size_t)length;
 804a562:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a565:	8b 50 08             	mov    0x8(%eax),%edx
 804a568:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a56b:	01 c2                	add    %eax,%edx
 804a56d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a570:	89 50 08             	mov    %edx,0x8(%eax)

    return true;
 804a573:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804a578:	c9                   	leave  
 804a579:	c3                   	ret    

0804a57a <_ZL10parse_hex4PKh>:

/* parse 4 digit hexadecimal number */
static unsigned parse_hex4(const unsigned char * const input)
{
 804a57a:	55                   	push   %ebp
 804a57b:	89 e5                	mov    %esp,%ebp
 804a57d:	83 ec 10             	sub    $0x10,%esp
    unsigned int h = 0;
 804a580:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    size_t i = 0;
 804a587:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    for (i = 0; i < 4; i++)
 804a58e:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
 804a595:	e9 c3 00 00 00       	jmp    804a65d <_ZL10parse_hex4PKh+0xe3>
    {
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
 804a59a:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a59d:	8b 55 08             	mov    0x8(%ebp),%edx
 804a5a0:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a5a3:	0f b6 00             	movzbl (%eax),%eax
 804a5a6:	3c 2f                	cmp    $0x2f,%al
 804a5a8:	76 2a                	jbe    804a5d4 <_ZL10parse_hex4PKh+0x5a>
 804a5aa:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a5ad:	8b 55 08             	mov    0x8(%ebp),%edx
 804a5b0:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a5b3:	0f b6 00             	movzbl (%eax),%eax
 804a5b6:	3c 39                	cmp    $0x39,%al
 804a5b8:	77 1a                	ja     804a5d4 <_ZL10parse_hex4PKh+0x5a>
        {
            h += (unsigned int) input[i] - '0';
 804a5ba:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a5bd:	8b 55 08             	mov    0x8(%ebp),%edx
 804a5c0:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a5c3:	0f b6 00             	movzbl (%eax),%eax
 804a5c6:	0f b6 c0             	movzbl %al,%eax
 804a5c9:	03 45 f8             	add    -0x8(%ebp),%eax
 804a5cc:	83 e8 30             	sub    $0x30,%eax
 804a5cf:	89 45 f8             	mov    %eax,-0x8(%ebp)
    size_t i = 0;

    for (i = 0; i < 4; i++)
    {
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
 804a5d2:	eb 7b                	jmp    804a64f <_ZL10parse_hex4PKh+0xd5>
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
 804a5d4:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a5d7:	8b 55 08             	mov    0x8(%ebp),%edx
 804a5da:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a5dd:	0f b6 00             	movzbl (%eax),%eax
 804a5e0:	3c 40                	cmp    $0x40,%al
 804a5e2:	76 2a                	jbe    804a60e <_ZL10parse_hex4PKh+0x94>
 804a5e4:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a5e7:	8b 55 08             	mov    0x8(%ebp),%edx
 804a5ea:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a5ed:	0f b6 00             	movzbl (%eax),%eax
 804a5f0:	3c 46                	cmp    $0x46,%al
 804a5f2:	77 1a                	ja     804a60e <_ZL10parse_hex4PKh+0x94>
        {
            h += (unsigned int) 10 + input[i] - 'A';
 804a5f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a5f7:	8b 55 08             	mov    0x8(%ebp),%edx
 804a5fa:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a5fd:	0f b6 00             	movzbl (%eax),%eax
 804a600:	0f b6 c0             	movzbl %al,%eax
 804a603:	03 45 f8             	add    -0x8(%ebp),%eax
 804a606:	83 e8 37             	sub    $0x37,%eax
 804a609:	89 45 f8             	mov    %eax,-0x8(%ebp)
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
 804a60c:	eb 41                	jmp    804a64f <_ZL10parse_hex4PKh+0xd5>
        {
            h += (unsigned int) 10 + input[i] - 'A';
        }
        else if ((input[i] >= 'a') && (input[i] <= 'f'))
 804a60e:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a611:	8b 55 08             	mov    0x8(%ebp),%edx
 804a614:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a617:	0f b6 00             	movzbl (%eax),%eax
 804a61a:	3c 60                	cmp    $0x60,%al
 804a61c:	76 2a                	jbe    804a648 <_ZL10parse_hex4PKh+0xce>
 804a61e:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a621:	8b 55 08             	mov    0x8(%ebp),%edx
 804a624:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a627:	0f b6 00             	movzbl (%eax),%eax
 804a62a:	3c 66                	cmp    $0x66,%al
 804a62c:	77 1a                	ja     804a648 <_ZL10parse_hex4PKh+0xce>
        {
            h += (unsigned int) 10 + input[i] - 'a';
 804a62e:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a631:	8b 55 08             	mov    0x8(%ebp),%edx
 804a634:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a637:	0f b6 00             	movzbl (%eax),%eax
 804a63a:	0f b6 c0             	movzbl %al,%eax
 804a63d:	03 45 f8             	add    -0x8(%ebp),%eax
 804a640:	83 e8 57             	sub    $0x57,%eax
 804a643:	89 45 f8             	mov    %eax,-0x8(%ebp)
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
        {
            h += (unsigned int) 10 + input[i] - 'A';
        }
        else if ((input[i] >= 'a') && (input[i] <= 'f'))
 804a646:	eb 07                	jmp    804a64f <_ZL10parse_hex4PKh+0xd5>
        {
            h += (unsigned int) 10 + input[i] - 'a';
        }
        else /* invalid */
        {
            return 0;
 804a648:	b8 00 00 00 00       	mov    $0x0,%eax
 804a64d:	eb 20                	jmp    804a66f <_ZL10parse_hex4PKh+0xf5>
        }

        if (i < 3)
 804a64f:	83 7d fc 02          	cmpl   $0x2,-0x4(%ebp)
 804a653:	77 04                	ja     804a659 <_ZL10parse_hex4PKh+0xdf>
        {
            /* shift left to make place for the next nibble */
            h = h << 4;
 804a655:	c1 65 f8 04          	shll   $0x4,-0x8(%ebp)
static unsigned parse_hex4(const unsigned char * const input)
{
    unsigned int h = 0;
    size_t i = 0;

    for (i = 0; i < 4; i++)
 804a659:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804a65d:	83 7d fc 03          	cmpl   $0x3,-0x4(%ebp)
 804a661:	0f 96 c0             	setbe  %al
 804a664:	84 c0                	test   %al,%al
 804a666:	0f 85 2e ff ff ff    	jne    804a59a <_ZL10parse_hex4PKh+0x20>
            /* shift left to make place for the next nibble */
            h = h << 4;
        }
    }

    return h;
 804a66c:	8b 45 f8             	mov    -0x8(%ebp),%eax
}
 804a66f:	c9                   	leave  
 804a670:	c3                   	ret    

0804a671 <_ZL21utf16_literal_to_utf8PKhS0_PPh>:

/* converts a UTF-16 literal to UTF-8
 * A literal can be one or two sequences of the form \uXXXX */
static unsigned char utf16_literal_to_utf8(const unsigned char * const input_pointer, const unsigned char * const input_end, unsigned char **output_pointer)
{
 804a671:	55                   	push   %ebp
 804a672:	89 e5                	mov    %esp,%ebp
 804a674:	83 ec 24             	sub    $0x24,%esp
    long unsigned int codepoint = 0;
 804a677:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned int first_code = 0;
 804a67e:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    const unsigned char *first_sequence = input_pointer;
 804a685:	8b 45 08             	mov    0x8(%ebp),%eax
 804a688:	89 45 f0             	mov    %eax,-0x10(%ebp)
    unsigned char utf8_length = 0;
 804a68b:	c6 45 f4 00          	movb   $0x0,-0xc(%ebp)
    unsigned char utf8_position = 0;
 804a68f:	c6 45 f5 00          	movb   $0x0,-0xb(%ebp)
    unsigned char sequence_length = 0;
 804a693:	c6 45 f6 00          	movb   $0x0,-0xa(%ebp)
    unsigned char first_byte_mark = 0;
 804a697:	c6 45 f7 00          	movb   $0x0,-0x9(%ebp)

    if ((input_end - first_sequence) < 6)
 804a69b:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a69e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a6a1:	89 d1                	mov    %edx,%ecx
 804a6a3:	29 c1                	sub    %eax,%ecx
 804a6a5:	89 c8                	mov    %ecx,%eax
 804a6a7:	83 f8 05             	cmp    $0x5,%eax
 804a6aa:	0f 8e 8f 01 00 00    	jle    804a83f <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1ce>
        /* input ends unexpectedly */
        goto fail;
    }

    /* get the first utf16 sequence */
    first_code = parse_hex4(first_sequence + 2);
 804a6b0:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a6b3:	83 c0 02             	add    $0x2,%eax
 804a6b6:	89 04 24             	mov    %eax,(%esp)
 804a6b9:	e8 bc fe ff ff       	call   804a57a <_ZL10parse_hex4PKh>
 804a6be:	89 45 ec             	mov    %eax,-0x14(%ebp)

    /* check that the code is valid */
    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
 804a6c1:	81 7d ec ff db 00 00 	cmpl   $0xdbff,-0x14(%ebp)
 804a6c8:	76 0d                	jbe    804a6d7 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x66>
 804a6ca:	81 7d ec ff df 00 00 	cmpl   $0xdfff,-0x14(%ebp)
 804a6d1:	0f 86 6b 01 00 00    	jbe    804a842 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d1>
    {
        goto fail;
    }

    /* UTF16 surrogate pair */
    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
 804a6d7:	81 7d ec ff d7 00 00 	cmpl   $0xd7ff,-0x14(%ebp)
 804a6de:	0f 86 a1 00 00 00    	jbe    804a785 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x114>
 804a6e4:	81 7d ec ff db 00 00 	cmpl   $0xdbff,-0x14(%ebp)
 804a6eb:	0f 87 94 00 00 00    	ja     804a785 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x114>
    {
        const unsigned char *second_sequence = first_sequence + 6;
 804a6f1:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804a6f4:	83 c0 06             	add    $0x6,%eax
 804a6f7:	89 45 f8             	mov    %eax,-0x8(%ebp)
        unsigned int second_code = 0;
 804a6fa:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)
        sequence_length = 12; /* \uXXXX\uXXXX */
 804a701:	c6 45 f6 0c          	movb   $0xc,-0xa(%ebp)

        if ((input_end - second_sequence) < 6)
 804a705:	8b 55 0c             	mov    0xc(%ebp),%edx
 804a708:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804a70b:	89 d1                	mov    %edx,%ecx
 804a70d:	29 c1                	sub    %eax,%ecx
 804a70f:	89 c8                	mov    %ecx,%eax
 804a711:	83 f8 05             	cmp    $0x5,%eax
 804a714:	0f 8e 2b 01 00 00    	jle    804a845 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d4>
        {
            /* input ends unexpectedly */
            goto fail;
        }

        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
 804a71a:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804a71d:	0f b6 00             	movzbl (%eax),%eax
 804a720:	3c 5c                	cmp    $0x5c,%al
 804a722:	0f 85 21 01 00 00    	jne    804a849 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d8>
 804a728:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804a72b:	83 c0 01             	add    $0x1,%eax
 804a72e:	0f b6 00             	movzbl (%eax),%eax
 804a731:	3c 75                	cmp    $0x75,%al
 804a733:	0f 85 10 01 00 00    	jne    804a849 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d8>
            /* missing second half of the surrogate pair */
            goto fail;
        }

        /* get the second utf16 sequence */
        second_code = parse_hex4(second_sequence + 2);
 804a739:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804a73c:	83 c0 02             	add    $0x2,%eax
 804a73f:	89 04 24             	mov    %eax,(%esp)
 804a742:	e8 33 fe ff ff       	call   804a57a <_ZL10parse_hex4PKh>
 804a747:	89 45 fc             	mov    %eax,-0x4(%ebp)
        /* check that the code is valid */
        if ((second_code < 0xDC00) || (second_code > 0xDFFF))
 804a74a:	81 7d fc ff db 00 00 	cmpl   $0xdbff,-0x4(%ebp)
 804a751:	0f 86 f2 00 00 00    	jbe    804a849 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d8>
 804a757:	81 7d fc ff df 00 00 	cmpl   $0xdfff,-0x4(%ebp)
 804a75e:	0f 87 e5 00 00 00    	ja     804a849 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d8>
            goto fail;
        }


        /* calculate the unicode codepoint from the surrogate pair */
        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
 804a764:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a767:	25 ff 03 00 00       	and    $0x3ff,%eax
 804a76c:	89 c2                	mov    %eax,%edx
 804a76e:	c1 e2 0a             	shl    $0xa,%edx
 804a771:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804a774:	25 ff 03 00 00       	and    $0x3ff,%eax
 804a779:	09 d0                	or     %edx,%eax
 804a77b:	05 00 00 01 00       	add    $0x10000,%eax
 804a780:	89 45 e8             	mov    %eax,-0x18(%ebp)
    {
        goto fail;
    }

    /* UTF16 surrogate pair */
    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
 804a783:	eb 0a                	jmp    804a78f <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x11e>
        /* calculate the unicode codepoint from the surrogate pair */
        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
    }
    else
    {
        sequence_length = 6; /* \uXXXX */
 804a785:	c6 45 f6 06          	movb   $0x6,-0xa(%ebp)
        codepoint = first_code;
 804a789:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804a78c:	89 45 e8             	mov    %eax,-0x18(%ebp)
    }

    /* encode as UTF-8
     * takes at maximum 4 bytes to encode:
     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    if (codepoint < 0x80)
 804a78f:	83 7d e8 7f          	cmpl   $0x7f,-0x18(%ebp)
 804a793:	77 06                	ja     804a79b <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x12a>
    {
        /* normal ascii, encoding 0xxxxxxx */
        utf8_length = 1;
 804a795:	c6 45 f4 01          	movb   $0x1,-0xc(%ebp)
 804a799:	eb 37                	jmp    804a7d2 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x161>
    }
    else if (codepoint < 0x800)
 804a79b:	81 7d e8 ff 07 00 00 	cmpl   $0x7ff,-0x18(%ebp)
 804a7a2:	77 0a                	ja     804a7ae <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x13d>
    {
        /* two bytes, encoding 110xxxxx 10xxxxxx */
        utf8_length = 2;
 804a7a4:	c6 45 f4 02          	movb   $0x2,-0xc(%ebp)
        first_byte_mark = 0xC0; /* 11000000 */
 804a7a8:	c6 45 f7 c0          	movb   $0xc0,-0x9(%ebp)
 804a7ac:	eb 24                	jmp    804a7d2 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x161>
    }
    else if (codepoint < 0x10000)
 804a7ae:	81 7d e8 ff ff 00 00 	cmpl   $0xffff,-0x18(%ebp)
 804a7b5:	77 0a                	ja     804a7c1 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x150>
    {
        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        utf8_length = 3;
 804a7b7:	c6 45 f4 03          	movb   $0x3,-0xc(%ebp)
        first_byte_mark = 0xE0; /* 11100000 */
 804a7bb:	c6 45 f7 e0          	movb   $0xe0,-0x9(%ebp)
 804a7bf:	eb 11                	jmp    804a7d2 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x161>
    }
    else if (codepoint <= 0x10FFFF)
 804a7c1:	81 7d e8 ff ff 10 00 	cmpl   $0x10ffff,-0x18(%ebp)
 804a7c8:	77 7e                	ja     804a848 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d7>
    {
        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
        utf8_length = 4;
 804a7ca:	c6 45 f4 04          	movb   $0x4,-0xc(%ebp)
        first_byte_mark = 0xF0; /* 11110000 */
 804a7ce:	c6 45 f7 f0          	movb   $0xf0,-0x9(%ebp)
        /* invalid unicode codepoint */
        goto fail;
    }

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
 804a7d2:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 804a7d6:	83 e8 01             	sub    $0x1,%eax
 804a7d9:	88 45 f5             	mov    %al,-0xb(%ebp)
 804a7dc:	eb 1e                	jmp    804a7fc <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x18b>
    {
        /* 10xxxxxx */
        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
 804a7de:	8b 45 10             	mov    0x10(%ebp),%eax
 804a7e1:	8b 10                	mov    (%eax),%edx
 804a7e3:	0f b6 45 f5          	movzbl -0xb(%ebp),%eax
 804a7e7:	01 c2                	add    %eax,%edx
 804a7e9:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a7ec:	83 e0 3f             	and    $0x3f,%eax
 804a7ef:	83 c8 80             	or     $0xffffff80,%eax
 804a7f2:	88 02                	mov    %al,(%edx)
        codepoint >>= 6;
 804a7f4:	c1 6d e8 06          	shrl   $0x6,-0x18(%ebp)
        /* invalid unicode codepoint */
        goto fail;
    }

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
 804a7f8:	80 6d f5 01          	subb   $0x1,-0xb(%ebp)
 804a7fc:	80 7d f5 00          	cmpb   $0x0,-0xb(%ebp)
 804a800:	0f 95 c0             	setne  %al
 804a803:	84 c0                	test   %al,%al
 804a805:	75 d7                	jne    804a7de <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x16d>
        /* 10xxxxxx */
        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
        codepoint >>= 6;
    }
    /* encode first byte */
    if (utf8_length > 1)
 804a807:	80 7d f4 01          	cmpb   $0x1,-0xc(%ebp)
 804a80b:	76 0f                	jbe    804a81c <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1ab>
    {
        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
 804a80d:	8b 45 10             	mov    0x10(%ebp),%eax
 804a810:	8b 00                	mov    (%eax),%eax
 804a812:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a815:	0a 55 f7             	or     -0x9(%ebp),%dl
 804a818:	88 10                	mov    %dl,(%eax)
 804a81a:	eb 0d                	jmp    804a829 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1b8>
    }
    else
    {
        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
 804a81c:	8b 45 10             	mov    0x10(%ebp),%eax
 804a81f:	8b 00                	mov    (%eax),%eax
 804a821:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804a824:	83 e2 7f             	and    $0x7f,%edx
 804a827:	88 10                	mov    %dl,(%eax)
    }

    *output_pointer += utf8_length;
 804a829:	8b 45 10             	mov    0x10(%ebp),%eax
 804a82c:	8b 10                	mov    (%eax),%edx
 804a82e:	0f b6 45 f4          	movzbl -0xc(%ebp),%eax
 804a832:	01 c2                	add    %eax,%edx
 804a834:	8b 45 10             	mov    0x10(%ebp),%eax
 804a837:	89 10                	mov    %edx,(%eax)

    return sequence_length;
 804a839:	0f b6 45 f6          	movzbl -0xa(%ebp),%eax
 804a83d:	eb 0f                	jmp    804a84e <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1dd>
    unsigned char first_byte_mark = 0;

    if ((input_end - first_sequence) < 6)
    {
        /* input ends unexpectedly */
        goto fail;
 804a83f:	90                   	nop
 804a840:	eb 07                	jmp    804a849 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d8>
    first_code = parse_hex4(first_sequence + 2);

    /* check that the code is valid */
    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
    {
        goto fail;
 804a842:	90                   	nop
 804a843:	eb 04                	jmp    804a849 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d8>
        sequence_length = 12; /* \uXXXX\uXXXX */

        if ((input_end - second_sequence) < 6)
        {
            /* input ends unexpectedly */
            goto fail;
 804a845:	90                   	nop
 804a846:	eb 01                	jmp    804a849 <_ZL21utf16_literal_to_utf8PKhS0_PPh+0x1d8>
        first_byte_mark = 0xF0; /* 11110000 */
    }
    else
    {
        /* invalid unicode codepoint */
        goto fail;
 804a848:	90                   	nop
    *output_pointer += utf8_length;

    return sequence_length;

fail:
    return 0;
 804a849:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804a84e:	c9                   	leave  
 804a84f:	c3                   	ret    

0804a850 <_ZL12parse_stringP5cJSONP12parse_buffer>:

/* Parse the input text into an unescaped cinput, and populate item. */
static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
{
 804a850:	55                   	push   %ebp
 804a851:	89 e5                	mov    %esp,%ebp
 804a853:	83 ec 38             	sub    $0x38,%esp
    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
 804a856:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a859:	8b 10                	mov    (%eax),%edx
 804a85b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a85e:	8b 40 08             	mov    0x8(%eax),%eax
 804a861:	83 c0 01             	add    $0x1,%eax
 804a864:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a867:	89 45 e0             	mov    %eax,-0x20(%ebp)
    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
 804a86a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a86d:	8b 10                	mov    (%eax),%edx
 804a86f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a872:	8b 40 08             	mov    0x8(%eax),%eax
 804a875:	83 c0 01             	add    $0x1,%eax
 804a878:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a87b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    unsigned char *output_pointer = NULL;
 804a87e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    unsigned char *output = NULL;
 804a885:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)

    /* not a string */
    if (buffer_at_offset(input_buffer)[0] != '\"')
 804a88c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a88f:	8b 10                	mov    (%eax),%edx
 804a891:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a894:	8b 40 08             	mov    0x8(%eax),%eax
 804a897:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804a89a:	0f b6 00             	movzbl (%eax),%eax
 804a89d:	3c 22                	cmp    $0x22,%al
 804a89f:	0f 85 28 02 00 00    	jne    804aacd <_ZL12parse_stringP5cJSONP12parse_buffer+0x27d>
        goto fail;
    }

    {
        /* calculate approximate size of the output (overestimate) */
        size_t allocation_length = 0;
 804a8a5:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
        size_t skipped_bytes = 0;
 804a8ac:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
 804a8b3:	eb 39                	jmp    804a8ee <_ZL12parse_stringP5cJSONP12parse_buffer+0x9e>
        {
            /* is escape sequence */
            if (input_end[0] == '\\')
 804a8b5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a8b8:	0f b6 00             	movzbl (%eax),%eax
 804a8bb:	3c 5c                	cmp    $0x5c,%al
 804a8bd:	75 2b                	jne    804a8ea <_ZL12parse_stringP5cJSONP12parse_buffer+0x9a>
            {
                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
 804a8bf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a8c2:	83 c0 01             	add    $0x1,%eax
 804a8c5:	89 c2                	mov    %eax,%edx
 804a8c7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a8ca:	8b 00                	mov    (%eax),%eax
 804a8cc:	89 d1                	mov    %edx,%ecx
 804a8ce:	29 c1                	sub    %eax,%ecx
 804a8d0:	89 c8                	mov    %ecx,%eax
 804a8d2:	89 c2                	mov    %eax,%edx
 804a8d4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a8d7:	8b 40 04             	mov    0x4(%eax),%eax
 804a8da:	39 c2                	cmp    %eax,%edx
 804a8dc:	0f 83 ee 01 00 00    	jae    804aad0 <_ZL12parse_stringP5cJSONP12parse_buffer+0x280>
                {
                    /* prevent buffer overflow when last input character is a backslash */
                    goto fail;
                }
                skipped_bytes++;
 804a8e2:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
                input_end++;
 804a8e6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            }
            input_end++;
 804a8ea:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)

    {
        /* calculate approximate size of the output (overestimate) */
        size_t allocation_length = 0;
        size_t skipped_bytes = 0;
        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
 804a8ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a8f1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a8f4:	8b 00                	mov    (%eax),%eax
 804a8f6:	89 d1                	mov    %edx,%ecx
 804a8f8:	29 c1                	sub    %eax,%ecx
 804a8fa:	89 c8                	mov    %ecx,%eax
 804a8fc:	89 c2                	mov    %eax,%edx
 804a8fe:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a901:	8b 40 04             	mov    0x4(%eax),%eax
 804a904:	39 c2                	cmp    %eax,%edx
 804a906:	73 11                	jae    804a919 <_ZL12parse_stringP5cJSONP12parse_buffer+0xc9>
 804a908:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a90b:	0f b6 00             	movzbl (%eax),%eax
 804a90e:	3c 22                	cmp    $0x22,%al
 804a910:	74 07                	je     804a919 <_ZL12parse_stringP5cJSONP12parse_buffer+0xc9>
 804a912:	b8 01 00 00 00       	mov    $0x1,%eax
 804a917:	eb 05                	jmp    804a91e <_ZL12parse_stringP5cJSONP12parse_buffer+0xce>
 804a919:	b8 00 00 00 00       	mov    $0x0,%eax
 804a91e:	84 c0                	test   %al,%al
 804a920:	75 93                	jne    804a8b5 <_ZL12parse_stringP5cJSONP12parse_buffer+0x65>
                skipped_bytes++;
                input_end++;
            }
            input_end++;
        }
        if (((size_t)(input_end - input_buffer->content) >= input_buffer->length) || (*input_end != '\"'))
 804a922:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a925:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a928:	8b 00                	mov    (%eax),%eax
 804a92a:	89 d1                	mov    %edx,%ecx
 804a92c:	29 c1                	sub    %eax,%ecx
 804a92e:	89 c8                	mov    %ecx,%eax
 804a930:	89 c2                	mov    %eax,%edx
 804a932:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a935:	8b 40 04             	mov    0x4(%eax),%eax
 804a938:	39 c2                	cmp    %eax,%edx
 804a93a:	0f 83 a0 01 00 00    	jae    804aae0 <_ZL12parse_stringP5cJSONP12parse_buffer+0x290>
 804a940:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804a943:	0f b6 00             	movzbl (%eax),%eax
 804a946:	3c 22                	cmp    $0x22,%al
 804a948:	0f 85 92 01 00 00    	jne    804aae0 <_ZL12parse_stringP5cJSONP12parse_buffer+0x290>
        {
            goto fail; /* string ended unexpectedly */
        }

        /* This is at most how much we need for the output */
        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
 804a94e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a951:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a954:	8b 08                	mov    (%eax),%ecx
 804a956:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a959:	8b 40 08             	mov    0x8(%eax),%eax
 804a95c:	8d 04 01             	lea    (%ecx,%eax,1),%eax
 804a95f:	89 d1                	mov    %edx,%ecx
 804a961:	29 c1                	sub    %eax,%ecx
 804a963:	89 c8                	mov    %ecx,%eax
 804a965:	2b 45 f0             	sub    -0x10(%ebp),%eax
 804a968:	89 45 ec             	mov    %eax,-0x14(%ebp)
        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
 804a96b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804a96e:	8b 40 10             	mov    0x10(%eax),%eax
 804a971:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804a974:	83 c2 01             	add    $0x1,%edx
 804a977:	89 14 24             	mov    %edx,(%esp)
 804a97a:	ff d0                	call   *%eax
 804a97c:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (output == NULL)
 804a97f:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804a983:	0f 84 4a 01 00 00    	je     804aad3 <_ZL12parse_stringP5cJSONP12parse_buffer+0x283>
        {
            goto fail; /* allocation failure */
        }
    }

    output_pointer = output;
 804a989:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804a98c:	89 45 dc             	mov    %eax,-0x24(%ebp)
    /* loop through the string literal */
    while (input_pointer < input_end)
 804a98f:	e9 e3 00 00 00       	jmp    804aa77 <_ZL12parse_stringP5cJSONP12parse_buffer+0x227>
    {
        if (*input_pointer != '\\')
 804a994:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a997:	0f b6 00             	movzbl (%eax),%eax
 804a99a:	3c 5c                	cmp    $0x5c,%al
 804a99c:	74 1a                	je     804a9b8 <_ZL12parse_stringP5cJSONP12parse_buffer+0x168>
        {
            *output_pointer++ = *input_pointer++;
 804a99e:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a9a1:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804a9a4:	0f b6 12             	movzbl (%edx),%edx
 804a9a7:	88 10                	mov    %dl,(%eax)
 804a9a9:	83 c0 01             	add    $0x1,%eax
 804a9ac:	89 45 dc             	mov    %eax,-0x24(%ebp)
 804a9af:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
 804a9b3:	e9 bf 00 00 00       	jmp    804aa77 <_ZL12parse_stringP5cJSONP12parse_buffer+0x227>
        }
        /* escape sequence */
        else
        {
            unsigned char sequence_length = 2;
 804a9b8:	c6 45 f7 02          	movb   $0x2,-0x9(%ebp)
            if ((input_end - input_pointer) < 1)
 804a9bc:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804a9bf:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a9c2:	89 d1                	mov    %edx,%ecx
 804a9c4:	29 c1                	sub    %eax,%ecx
 804a9c6:	89 c8                	mov    %ecx,%eax
 804a9c8:	85 c0                	test   %eax,%eax
 804a9ca:	0f 8e 06 01 00 00    	jle    804aad6 <_ZL12parse_stringP5cJSONP12parse_buffer+0x286>
            {
                goto fail;
            }

            switch (input_pointer[1])
 804a9d0:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804a9d3:	83 c0 01             	add    $0x1,%eax
 804a9d6:	0f b6 00             	movzbl (%eax),%eax
 804a9d9:	0f b6 c0             	movzbl %al,%eax
 804a9dc:	83 e8 22             	sub    $0x22,%eax
 804a9df:	83 f8 53             	cmp    $0x53,%eax
 804a9e2:	0f 87 f1 00 00 00    	ja     804aad9 <_ZL12parse_stringP5cJSONP12parse_buffer+0x289>
 804a9e8:	8b 04 85 20 df 04 08 	mov    0x804df20(,%eax,4),%eax
 804a9ef:	ff e0                	jmp    *%eax
            {
                case 'b':
                    *output_pointer++ = '\b';
 804a9f1:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804a9f4:	c6 00 08             	movb   $0x8,(%eax)
 804a9f7:	83 c0 01             	add    $0x1,%eax
 804a9fa:	89 45 dc             	mov    %eax,-0x24(%ebp)
                    break;
 804a9fd:	eb 71                	jmp    804aa70 <_ZL12parse_stringP5cJSONP12parse_buffer+0x220>
                case 'f':
                    *output_pointer++ = '\f';
 804a9ff:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804aa02:	c6 00 0c             	movb   $0xc,(%eax)
 804aa05:	83 c0 01             	add    $0x1,%eax
 804aa08:	89 45 dc             	mov    %eax,-0x24(%ebp)
                    break;
 804aa0b:	eb 63                	jmp    804aa70 <_ZL12parse_stringP5cJSONP12parse_buffer+0x220>
                case 'n':
                    *output_pointer++ = '\n';
 804aa0d:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804aa10:	c6 00 0a             	movb   $0xa,(%eax)
 804aa13:	83 c0 01             	add    $0x1,%eax
 804aa16:	89 45 dc             	mov    %eax,-0x24(%ebp)
                    break;
 804aa19:	eb 55                	jmp    804aa70 <_ZL12parse_stringP5cJSONP12parse_buffer+0x220>
                case 'r':
                    *output_pointer++ = '\r';
 804aa1b:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804aa1e:	c6 00 0d             	movb   $0xd,(%eax)
 804aa21:	83 c0 01             	add    $0x1,%eax
 804aa24:	89 45 dc             	mov    %eax,-0x24(%ebp)
                    break;
 804aa27:	eb 47                	jmp    804aa70 <_ZL12parse_stringP5cJSONP12parse_buffer+0x220>
                case 't':
                    *output_pointer++ = '\t';
 804aa29:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804aa2c:	c6 00 09             	movb   $0x9,(%eax)
 804aa2f:	83 c0 01             	add    $0x1,%eax
 804aa32:	89 45 dc             	mov    %eax,-0x24(%ebp)
                    break;
 804aa35:	eb 39                	jmp    804aa70 <_ZL12parse_stringP5cJSONP12parse_buffer+0x220>
                case '\"':
                case '\\':
                case '/':
                    *output_pointer++ = input_pointer[1];
 804aa37:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804aa3a:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804aa3d:	83 c2 01             	add    $0x1,%edx
 804aa40:	0f b6 12             	movzbl (%edx),%edx
 804aa43:	88 10                	mov    %dl,(%eax)
 804aa45:	83 c0 01             	add    $0x1,%eax
 804aa48:	89 45 dc             	mov    %eax,-0x24(%ebp)
                    break;
 804aa4b:	eb 23                	jmp    804aa70 <_ZL12parse_stringP5cJSONP12parse_buffer+0x220>

                /* UTF-16 literal */
                case 'u':
                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
 804aa4d:	8d 45 dc             	lea    -0x24(%ebp),%eax
 804aa50:	89 44 24 08          	mov    %eax,0x8(%esp)
 804aa54:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aa57:	89 44 24 04          	mov    %eax,0x4(%esp)
 804aa5b:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804aa5e:	89 04 24             	mov    %eax,(%esp)
 804aa61:	e8 0b fc ff ff       	call   804a671 <_ZL21utf16_literal_to_utf8PKhS0_PPh>
 804aa66:	88 45 f7             	mov    %al,-0x9(%ebp)
                    if (sequence_length == 0)
 804aa69:	80 7d f7 00          	cmpb   $0x0,-0x9(%ebp)
 804aa6d:	74 70                	je     804aadf <_ZL12parse_stringP5cJSONP12parse_buffer+0x28f>
                    {
                        /* failed to convert UTF16-literal to UTF-8 */
                        goto fail;
                    }
                    break;
 804aa6f:	90                   	nop

                default:
                    goto fail;
            }
            input_pointer += sequence_length;
 804aa70:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
 804aa74:	01 45 e0             	add    %eax,-0x20(%ebp)
        }
    }

    output_pointer = output;
    /* loop through the string literal */
    while (input_pointer < input_end)
 804aa77:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804aa7a:	3b 45 e4             	cmp    -0x1c(%ebp),%eax
 804aa7d:	0f 92 c0             	setb   %al
 804aa80:	84 c0                	test   %al,%al
 804aa82:	0f 85 0c ff ff ff    	jne    804a994 <_ZL12parse_stringP5cJSONP12parse_buffer+0x144>
            input_pointer += sequence_length;
        }
    }

    /* zero terminate the output */
    *output_pointer = '\0';
 804aa88:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804aa8b:	c6 00 00             	movb   $0x0,(%eax)

    item->type = cJSON_String;
 804aa8e:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa91:	c7 40 0c 10 00 00 00 	movl   $0x10,0xc(%eax)
    item->valuestring = (char*)output;
 804aa98:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804aa9b:	8b 45 08             	mov    0x8(%ebp),%eax
 804aa9e:	89 50 10             	mov    %edx,0x10(%eax)

    input_buffer->offset = (size_t) (input_end - input_buffer->content);
 804aaa1:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804aaa4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aaa7:	8b 00                	mov    (%eax),%eax
 804aaa9:	89 d1                	mov    %edx,%ecx
 804aaab:	29 c1                	sub    %eax,%ecx
 804aaad:	89 c8                	mov    %ecx,%eax
 804aaaf:	89 c2                	mov    %eax,%edx
 804aab1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aab4:	89 50 08             	mov    %edx,0x8(%eax)
    input_buffer->offset++;
 804aab7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aaba:	8b 40 08             	mov    0x8(%eax),%eax
 804aabd:	8d 50 01             	lea    0x1(%eax),%edx
 804aac0:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aac3:	89 50 08             	mov    %edx,0x8(%eax)

    return true;
 804aac6:	b8 01 00 00 00       	mov    $0x1,%eax
 804aacb:	eb 48                	jmp    804ab15 <_ZL12parse_stringP5cJSONP12parse_buffer+0x2c5>
    unsigned char *output = NULL;

    /* not a string */
    if (buffer_at_offset(input_buffer)[0] != '\"')
    {
        goto fail;
 804aacd:	90                   	nop
 804aace:	eb 10                	jmp    804aae0 <_ZL12parse_stringP5cJSONP12parse_buffer+0x290>
            if (input_end[0] == '\\')
            {
                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
                {
                    /* prevent buffer overflow when last input character is a backslash */
                    goto fail;
 804aad0:	90                   	nop
 804aad1:	eb 0d                	jmp    804aae0 <_ZL12parse_stringP5cJSONP12parse_buffer+0x290>
        /* This is at most how much we need for the output */
        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
        if (output == NULL)
        {
            goto fail; /* allocation failure */
 804aad3:	90                   	nop
 804aad4:	eb 0a                	jmp    804aae0 <_ZL12parse_stringP5cJSONP12parse_buffer+0x290>
        else
        {
            unsigned char sequence_length = 2;
            if ((input_end - input_pointer) < 1)
            {
                goto fail;
 804aad6:	90                   	nop
 804aad7:	eb 07                	jmp    804aae0 <_ZL12parse_stringP5cJSONP12parse_buffer+0x290>
                        goto fail;
                    }
                    break;

                default:
                    goto fail;
 804aad9:	90                   	nop
 804aada:	eb 04                	jmp    804aae0 <_ZL12parse_stringP5cJSONP12parse_buffer+0x290>
 804aadc:	90                   	nop
 804aadd:	eb 01                	jmp    804aae0 <_ZL12parse_stringP5cJSONP12parse_buffer+0x290>
                case 'u':
                    sequence_length = utf16_literal_to_utf8(input_pointer, input_end, &output_pointer);
                    if (sequence_length == 0)
                    {
                        /* failed to convert UTF16-literal to UTF-8 */
                        goto fail;
 804aadf:	90                   	nop
    input_buffer->offset++;

    return true;

fail:
    if (output != NULL)
 804aae0:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804aae4:	74 0e                	je     804aaf4 <_ZL12parse_stringP5cJSONP12parse_buffer+0x2a4>
    {
        input_buffer->hooks.deallocate(output);
 804aae6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804aae9:	8b 40 14             	mov    0x14(%eax),%eax
 804aaec:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804aaef:	89 14 24             	mov    %edx,(%esp)
 804aaf2:	ff d0                	call   *%eax
    }

    if (input_pointer != NULL)
 804aaf4:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
 804aaf8:	74 16                	je     804ab10 <_ZL12parse_stringP5cJSONP12parse_buffer+0x2c0>
    {
        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
 804aafa:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804aafd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ab00:	8b 00                	mov    (%eax),%eax
 804ab02:	89 d1                	mov    %edx,%ecx
 804ab04:	29 c1                	sub    %eax,%ecx
 804ab06:	89 c8                	mov    %ecx,%eax
 804ab08:	89 c2                	mov    %eax,%edx
 804ab0a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ab0d:	89 50 08             	mov    %edx,0x8(%eax)
    }

    return false;
 804ab10:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804ab15:	c9                   	leave  
 804ab16:	c3                   	ret    

0804ab17 <_ZL16print_string_ptrPKhP11printbuffer>:

/* Render the cstring provided to an escaped version that can be printed. */
static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
{
 804ab17:	55                   	push   %ebp
 804ab18:	89 e5                	mov    %esp,%ebp
 804ab1a:	83 ec 38             	sub    $0x38,%esp
    const unsigned char *input_pointer = NULL;
 804ab1d:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    unsigned char *output = NULL;
 804ab24:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    unsigned char *output_pointer = NULL;
 804ab2b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    size_t output_length = 0;
 804ab32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    /* numbers of additional characters needed for escaping */
    size_t escape_characters = 0;
 804ab39:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if (output_buffer == NULL)
 804ab40:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804ab44:	75 0a                	jne    804ab50 <_ZL16print_string_ptrPKhP11printbuffer+0x39>
    {
        return false;
 804ab46:	b8 00 00 00 00       	mov    $0x0,%eax
 804ab4b:	e9 46 02 00 00       	jmp    804ad96 <_ZL16print_string_ptrPKhP11printbuffer+0x27f>
    }

    /* empty string */
    if (input == NULL)
 804ab50:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804ab54:	75 4b                	jne    804aba1 <_ZL16print_string_ptrPKhP11printbuffer+0x8a>
    {
        output = ensure(output_buffer, sizeof("\"\""));
 804ab56:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
 804ab5d:	00 
 804ab5e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ab61:	89 04 24             	mov    %eax,(%esp)
 804ab64:	e8 6e f6 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804ab69:	89 45 e8             	mov    %eax,-0x18(%ebp)
        if (output == NULL)
 804ab6c:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804ab70:	75 0a                	jne    804ab7c <_ZL16print_string_ptrPKhP11printbuffer+0x65>
        {
            return false;
 804ab72:	b8 00 00 00 00       	mov    $0x0,%eax
 804ab77:	e9 1a 02 00 00       	jmp    804ad96 <_ZL16print_string_ptrPKhP11printbuffer+0x27f>
        }
        strcpy((char*)output, "\"\"");
 804ab7c:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ab7f:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804ab86:	00 
 804ab87:	c7 44 24 04 70 e0 04 	movl   $0x804e070,0x4(%esp)
 804ab8e:	08 
 804ab8f:	89 04 24             	mov    %eax,(%esp)
 804ab92:	e8 cd ea ff ff       	call   8049664 <memcpy@plt>

        return true;
 804ab97:	b8 01 00 00 00       	mov    $0x1,%eax
 804ab9c:	e9 f5 01 00 00       	jmp    804ad96 <_ZL16print_string_ptrPKhP11printbuffer+0x27f>
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
 804aba1:	8b 45 08             	mov    0x8(%ebp),%eax
 804aba4:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804aba7:	eb 3f                	jmp    804abe8 <_ZL16print_string_ptrPKhP11printbuffer+0xd1>
    {
        switch (*input_pointer)
 804aba9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804abac:	0f b6 00             	movzbl (%eax),%eax
 804abaf:	0f b6 c0             	movzbl %al,%eax
 804abb2:	83 f8 0d             	cmp    $0xd,%eax
 804abb5:	7f 0f                	jg     804abc6 <_ZL16print_string_ptrPKhP11printbuffer+0xaf>
 804abb7:	83 f8 0c             	cmp    $0xc,%eax
 804abba:	7d 14                	jge    804abd0 <_ZL16print_string_ptrPKhP11printbuffer+0xb9>
 804abbc:	83 e8 08             	sub    $0x8,%eax
 804abbf:	83 f8 02             	cmp    $0x2,%eax
 804abc2:	77 12                	ja     804abd6 <_ZL16print_string_ptrPKhP11printbuffer+0xbf>
 804abc4:	eb 0a                	jmp    804abd0 <_ZL16print_string_ptrPKhP11printbuffer+0xb9>
 804abc6:	83 f8 22             	cmp    $0x22,%eax
 804abc9:	74 05                	je     804abd0 <_ZL16print_string_ptrPKhP11printbuffer+0xb9>
 804abcb:	83 f8 5c             	cmp    $0x5c,%eax
 804abce:	75 06                	jne    804abd6 <_ZL16print_string_ptrPKhP11printbuffer+0xbf>
            case '\f':
            case '\n':
            case '\r':
            case '\t':
                /* one character escape sequence */
                escape_characters++;
 804abd0:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
                break;
 804abd4:	eb 0e                	jmp    804abe4 <_ZL16print_string_ptrPKhP11printbuffer+0xcd>
            default:
                if (*input_pointer < 32)
 804abd6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804abd9:	0f b6 00             	movzbl (%eax),%eax
 804abdc:	3c 1f                	cmp    $0x1f,%al
 804abde:	77 04                	ja     804abe4 <_ZL16print_string_ptrPKhP11printbuffer+0xcd>
                {
                    /* UTF-16 escape sequence uXXXX */
                    escape_characters += 5;
 804abe0:	83 45 f4 05          	addl   $0x5,-0xc(%ebp)

        return true;
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
 804abe4:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
 804abe8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804abeb:	0f b6 00             	movzbl (%eax),%eax
 804abee:	84 c0                	test   %al,%al
 804abf0:	0f 95 c0             	setne  %al
 804abf3:	84 c0                	test   %al,%al
 804abf5:	75 b2                	jne    804aba9 <_ZL16print_string_ptrPKhP11printbuffer+0x92>
                    escape_characters += 5;
                }
                break;
        }
    }
    output_length = (size_t)(input_pointer - input) + escape_characters;
 804abf7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
 804abfa:	8b 45 08             	mov    0x8(%ebp),%eax
 804abfd:	89 d1                	mov    %edx,%ecx
 804abff:	29 c1                	sub    %eax,%ecx
 804ac01:	89 c8                	mov    %ecx,%eax
 804ac03:	03 45 f4             	add    -0xc(%ebp),%eax
 804ac06:	89 45 f0             	mov    %eax,-0x10(%ebp)

    output = ensure(output_buffer, output_length + sizeof("\"\""));
 804ac09:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac0c:	83 c0 03             	add    $0x3,%eax
 804ac0f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ac13:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ac16:	89 04 24             	mov    %eax,(%esp)
 804ac19:	e8 b9 f5 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804ac1e:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (output == NULL)
 804ac21:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804ac25:	75 0a                	jne    804ac31 <_ZL16print_string_ptrPKhP11printbuffer+0x11a>
    {
        return false;
 804ac27:	b8 00 00 00 00       	mov    $0x0,%eax
 804ac2c:	e9 65 01 00 00       	jmp    804ad96 <_ZL16print_string_ptrPKhP11printbuffer+0x27f>
    }

    /* no characters have to be escaped */
    if (escape_characters == 0)
 804ac31:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804ac35:	75 44                	jne    804ac7b <_ZL16print_string_ptrPKhP11printbuffer+0x164>
    {
        output[0] = '\"';
 804ac37:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ac3a:	c6 00 22             	movb   $0x22,(%eax)
        memcpy(output + 1, input, output_length);
 804ac3d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ac40:	8d 50 01             	lea    0x1(%eax),%edx
 804ac43:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac46:	89 44 24 08          	mov    %eax,0x8(%esp)
 804ac4a:	8b 45 08             	mov    0x8(%ebp),%eax
 804ac4d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ac51:	89 14 24             	mov    %edx,(%esp)
 804ac54:	e8 0b ea ff ff       	call   8049664 <memcpy@plt>
        output[output_length + 1] = '\"';
 804ac59:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac5c:	83 c0 01             	add    $0x1,%eax
 804ac5f:	03 45 e8             	add    -0x18(%ebp),%eax
 804ac62:	c6 00 22             	movb   $0x22,(%eax)
        output[output_length + 2] = '\0';
 804ac65:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ac68:	83 c0 02             	add    $0x2,%eax
 804ac6b:	03 45 e8             	add    -0x18(%ebp),%eax
 804ac6e:	c6 00 00             	movb   $0x0,(%eax)

        return true;
 804ac71:	b8 01 00 00 00       	mov    $0x1,%eax
 804ac76:	e9 1b 01 00 00       	jmp    804ad96 <_ZL16print_string_ptrPKhP11printbuffer+0x27f>
    }

    output[0] = '\"';
 804ac7b:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ac7e:	c6 00 22             	movb   $0x22,(%eax)
    output_pointer = output + 1;
 804ac81:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804ac84:	83 c0 01             	add    $0x1,%eax
 804ac87:	89 45 ec             	mov    %eax,-0x14(%ebp)
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
 804ac8a:	8b 45 08             	mov    0x8(%ebp),%eax
 804ac8d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804ac90:	e9 d1 00 00 00       	jmp    804ad66 <_ZL16print_string_ptrPKhP11printbuffer+0x24f>
    {
        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
 804ac95:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ac98:	0f b6 00             	movzbl (%eax),%eax
 804ac9b:	3c 1f                	cmp    $0x1f,%al
 804ac9d:	76 24                	jbe    804acc3 <_ZL16print_string_ptrPKhP11printbuffer+0x1ac>
 804ac9f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804aca2:	0f b6 00             	movzbl (%eax),%eax
 804aca5:	3c 22                	cmp    $0x22,%al
 804aca7:	74 1a                	je     804acc3 <_ZL16print_string_ptrPKhP11printbuffer+0x1ac>
 804aca9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804acac:	0f b6 00             	movzbl (%eax),%eax
 804acaf:	3c 5c                	cmp    $0x5c,%al
 804acb1:	74 10                	je     804acc3 <_ZL16print_string_ptrPKhP11printbuffer+0x1ac>
        {
            /* normal character, copy */
            *output_pointer = *input_pointer;
 804acb3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804acb6:	0f b6 10             	movzbl (%eax),%edx
 804acb9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804acbc:	88 10                	mov    %dl,(%eax)
    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
    {
        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
 804acbe:	e9 9b 00 00 00       	jmp    804ad5e <_ZL16print_string_ptrPKhP11printbuffer+0x247>
            *output_pointer = *input_pointer;
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
 804acc3:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804acc6:	c6 00 5c             	movb   $0x5c,(%eax)
 804acc9:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
            switch (*input_pointer)
 804accd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804acd0:	0f b6 00             	movzbl (%eax),%eax
 804acd3:	0f b6 c0             	movzbl %al,%eax
 804acd6:	83 f8 0c             	cmp    $0xc,%eax
 804acd9:	74 3f                	je     804ad1a <_ZL16print_string_ptrPKhP11printbuffer+0x203>
 804acdb:	83 f8 0c             	cmp    $0xc,%eax
 804acde:	7f 11                	jg     804acf1 <_ZL16print_string_ptrPKhP11printbuffer+0x1da>
 804ace0:	83 f8 09             	cmp    $0x9,%eax
 804ace3:	74 4d                	je     804ad32 <_ZL16print_string_ptrPKhP11printbuffer+0x21b>
 804ace5:	83 f8 0a             	cmp    $0xa,%eax
 804ace8:	74 38                	je     804ad22 <_ZL16print_string_ptrPKhP11printbuffer+0x20b>
 804acea:	83 f8 08             	cmp    $0x8,%eax
 804aced:	74 23                	je     804ad12 <_ZL16print_string_ptrPKhP11printbuffer+0x1fb>
 804acef:	eb 49                	jmp    804ad3a <_ZL16print_string_ptrPKhP11printbuffer+0x223>
 804acf1:	83 f8 22             	cmp    $0x22,%eax
 804acf4:	74 14                	je     804ad0a <_ZL16print_string_ptrPKhP11printbuffer+0x1f3>
 804acf6:	83 f8 5c             	cmp    $0x5c,%eax
 804acf9:	74 07                	je     804ad02 <_ZL16print_string_ptrPKhP11printbuffer+0x1eb>
 804acfb:	83 f8 0d             	cmp    $0xd,%eax
 804acfe:	74 2a                	je     804ad2a <_ZL16print_string_ptrPKhP11printbuffer+0x213>
 804ad00:	eb 38                	jmp    804ad3a <_ZL16print_string_ptrPKhP11printbuffer+0x223>
            {
                case '\\':
                    *output_pointer = '\\';
 804ad02:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ad05:	c6 00 5c             	movb   $0x5c,(%eax)
                    break;
 804ad08:	eb 54                	jmp    804ad5e <_ZL16print_string_ptrPKhP11printbuffer+0x247>
                case '\"':
                    *output_pointer = '\"';
 804ad0a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ad0d:	c6 00 22             	movb   $0x22,(%eax)
                    break;
 804ad10:	eb 4c                	jmp    804ad5e <_ZL16print_string_ptrPKhP11printbuffer+0x247>
                case '\b':
                    *output_pointer = 'b';
 804ad12:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ad15:	c6 00 62             	movb   $0x62,(%eax)
                    break;
 804ad18:	eb 44                	jmp    804ad5e <_ZL16print_string_ptrPKhP11printbuffer+0x247>
                case '\f':
                    *output_pointer = 'f';
 804ad1a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ad1d:	c6 00 66             	movb   $0x66,(%eax)
                    break;
 804ad20:	eb 3c                	jmp    804ad5e <_ZL16print_string_ptrPKhP11printbuffer+0x247>
                case '\n':
                    *output_pointer = 'n';
 804ad22:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ad25:	c6 00 6e             	movb   $0x6e,(%eax)
                    break;
 804ad28:	eb 34                	jmp    804ad5e <_ZL16print_string_ptrPKhP11printbuffer+0x247>
                case '\r':
                    *output_pointer = 'r';
 804ad2a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ad2d:	c6 00 72             	movb   $0x72,(%eax)
                    break;
 804ad30:	eb 2c                	jmp    804ad5e <_ZL16print_string_ptrPKhP11printbuffer+0x247>
                case '\t':
                    *output_pointer = 't';
 804ad32:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ad35:	c6 00 74             	movb   $0x74,(%eax)
                    break;
 804ad38:	eb 24                	jmp    804ad5e <_ZL16print_string_ptrPKhP11printbuffer+0x247>
                default:
                    /* escape and print as unicode codepoint */
                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
 804ad3a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ad3d:	0f b6 00             	movzbl (%eax),%eax
 804ad40:	0f b6 d0             	movzbl %al,%edx
 804ad43:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ad46:	89 54 24 08          	mov    %edx,0x8(%esp)
 804ad4a:	c7 44 24 04 73 e0 04 	movl   $0x804e073,0x4(%esp)
 804ad51:	08 
 804ad52:	89 04 24             	mov    %eax,(%esp)
 804ad55:	e8 2a e8 ff ff       	call   8049584 <sprintf@plt>
                    output_pointer += 4;
 804ad5a:	83 45 ec 04          	addl   $0x4,-0x14(%ebp)
    }

    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
 804ad5e:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
 804ad62:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
 804ad66:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804ad69:	0f b6 00             	movzbl (%eax),%eax
 804ad6c:	84 c0                	test   %al,%al
 804ad6e:	0f 95 c0             	setne  %al
 804ad71:	84 c0                	test   %al,%al
 804ad73:	0f 85 1c ff ff ff    	jne    804ac95 <_ZL16print_string_ptrPKhP11printbuffer+0x17e>
                    output_pointer += 4;
                    break;
            }
        }
    }
    output[output_length + 1] = '\"';
 804ad79:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad7c:	83 c0 01             	add    $0x1,%eax
 804ad7f:	03 45 e8             	add    -0x18(%ebp),%eax
 804ad82:	c6 00 22             	movb   $0x22,(%eax)
    output[output_length + 2] = '\0';
 804ad85:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804ad88:	83 c0 02             	add    $0x2,%eax
 804ad8b:	03 45 e8             	add    -0x18(%ebp),%eax
 804ad8e:	c6 00 00             	movb   $0x0,(%eax)

    return true;
 804ad91:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804ad96:	c9                   	leave  
 804ad97:	c3                   	ret    

0804ad98 <_ZL12print_stringPK5cJSONP11printbuffer>:

/* Invoke print_string_ptr (which is useful) on an item. */
static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
{
 804ad98:	55                   	push   %ebp
 804ad99:	89 e5                	mov    %esp,%ebp
 804ad9b:	83 ec 18             	sub    $0x18,%esp
    return print_string_ptr((unsigned char*)item->valuestring, p);
 804ad9e:	8b 45 08             	mov    0x8(%ebp),%eax
 804ada1:	8b 40 10             	mov    0x10(%eax),%eax
 804ada4:	8b 55 0c             	mov    0xc(%ebp),%edx
 804ada7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804adab:	89 04 24             	mov    %eax,(%esp)
 804adae:	e8 64 fd ff ff       	call   804ab17 <_ZL16print_string_ptrPKhP11printbuffer>
}
 804adb3:	c9                   	leave  
 804adb4:	c3                   	ret    

0804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>:
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);

/* Utility to jump whitespace and cr/lf */
static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
{
 804adb5:	55                   	push   %ebp
 804adb6:	89 e5                	mov    %esp,%ebp
    if ((buffer == NULL) || (buffer->content == NULL))
 804adb8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804adbc:	74 09                	je     804adc7 <_ZL22buffer_skip_whitespaceP12parse_buffer+0x12>
 804adbe:	8b 45 08             	mov    0x8(%ebp),%eax
 804adc1:	8b 00                	mov    (%eax),%eax
 804adc3:	85 c0                	test   %eax,%eax
 804adc5:	75 16                	jne    804addd <_ZL22buffer_skip_whitespaceP12parse_buffer+0x28>
    {
        return NULL;
 804adc7:	b8 00 00 00 00       	mov    $0x0,%eax
 804adcc:	eb 6c                	jmp    804ae3a <_ZL22buffer_skip_whitespaceP12parse_buffer+0x85>
    }

    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
    {
       buffer->offset++;
 804adce:	8b 45 08             	mov    0x8(%ebp),%eax
 804add1:	8b 40 08             	mov    0x8(%eax),%eax
 804add4:	8d 50 01             	lea    0x1(%eax),%edx
 804add7:	8b 45 08             	mov    0x8(%ebp),%eax
 804adda:	89 50 08             	mov    %edx,0x8(%eax)
    if ((buffer == NULL) || (buffer->content == NULL))
    {
        return NULL;
    }

    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
 804addd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804ade1:	74 2c                	je     804ae0f <_ZL22buffer_skip_whitespaceP12parse_buffer+0x5a>
 804ade3:	8b 45 08             	mov    0x8(%ebp),%eax
 804ade6:	8b 50 08             	mov    0x8(%eax),%edx
 804ade9:	8b 45 08             	mov    0x8(%ebp),%eax
 804adec:	8b 40 04             	mov    0x4(%eax),%eax
 804adef:	39 c2                	cmp    %eax,%edx
 804adf1:	73 1c                	jae    804ae0f <_ZL22buffer_skip_whitespaceP12parse_buffer+0x5a>
 804adf3:	8b 45 08             	mov    0x8(%ebp),%eax
 804adf6:	8b 10                	mov    (%eax),%edx
 804adf8:	8b 45 08             	mov    0x8(%ebp),%eax
 804adfb:	8b 40 08             	mov    0x8(%eax),%eax
 804adfe:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804ae01:	0f b6 00             	movzbl (%eax),%eax
 804ae04:	3c 20                	cmp    $0x20,%al
 804ae06:	77 07                	ja     804ae0f <_ZL22buffer_skip_whitespaceP12parse_buffer+0x5a>
 804ae08:	b8 01 00 00 00       	mov    $0x1,%eax
 804ae0d:	eb 05                	jmp    804ae14 <_ZL22buffer_skip_whitespaceP12parse_buffer+0x5f>
 804ae0f:	b8 00 00 00 00       	mov    $0x0,%eax
 804ae14:	84 c0                	test   %al,%al
 804ae16:	75 b6                	jne    804adce <_ZL22buffer_skip_whitespaceP12parse_buffer+0x19>
    {
       buffer->offset++;
    }

    if (buffer->offset == buffer->length)
 804ae18:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae1b:	8b 50 08             	mov    0x8(%eax),%edx
 804ae1e:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae21:	8b 40 04             	mov    0x4(%eax),%eax
 804ae24:	39 c2                	cmp    %eax,%edx
 804ae26:	75 0f                	jne    804ae37 <_ZL22buffer_skip_whitespaceP12parse_buffer+0x82>
    {
        buffer->offset--;
 804ae28:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae2b:	8b 40 08             	mov    0x8(%eax),%eax
 804ae2e:	8d 50 ff             	lea    -0x1(%eax),%edx
 804ae31:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae34:	89 50 08             	mov    %edx,0x8(%eax)
    }

    return buffer;
 804ae37:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804ae3a:	5d                   	pop    %ebp
 804ae3b:	c3                   	ret    

0804ae3c <_ZL13skip_utf8_bomP12parse_buffer>:

/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
{
 804ae3c:	55                   	push   %ebp
 804ae3d:	89 e5                	mov    %esp,%ebp
 804ae3f:	83 ec 18             	sub    $0x18,%esp
    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
 804ae42:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804ae46:	74 13                	je     804ae5b <_ZL13skip_utf8_bomP12parse_buffer+0x1f>
 804ae48:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae4b:	8b 00                	mov    (%eax),%eax
 804ae4d:	85 c0                	test   %eax,%eax
 804ae4f:	74 0a                	je     804ae5b <_ZL13skip_utf8_bomP12parse_buffer+0x1f>
 804ae51:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae54:	8b 40 08             	mov    0x8(%eax),%eax
 804ae57:	85 c0                	test   %eax,%eax
 804ae59:	74 07                	je     804ae62 <_ZL13skip_utf8_bomP12parse_buffer+0x26>
    {
        return NULL;
 804ae5b:	b8 00 00 00 00       	mov    $0x0,%eax
 804ae60:	eb 57                	jmp    804aeb9 <_ZL13skip_utf8_bomP12parse_buffer+0x7d>
    }

    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
 804ae62:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804ae66:	74 4e                	je     804aeb6 <_ZL13skip_utf8_bomP12parse_buffer+0x7a>
 804ae68:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae6b:	8b 40 08             	mov    0x8(%eax),%eax
 804ae6e:	8d 50 04             	lea    0x4(%eax),%edx
 804ae71:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae74:	8b 40 04             	mov    0x4(%eax),%eax
 804ae77:	39 c2                	cmp    %eax,%edx
 804ae79:	73 3b                	jae    804aeb6 <_ZL13skip_utf8_bomP12parse_buffer+0x7a>
 804ae7b:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae7e:	8b 00                	mov    (%eax),%eax
 804ae80:	89 c2                	mov    %eax,%edx
 804ae82:	8b 45 08             	mov    0x8(%ebp),%eax
 804ae85:	8b 40 08             	mov    0x8(%eax),%eax
 804ae88:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804ae8b:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
 804ae92:	00 
 804ae93:	c7 44 24 04 79 e0 04 	movl   $0x804e079,0x4(%esp)
 804ae9a:	08 
 804ae9b:	89 04 24             	mov    %eax,(%esp)
 804ae9e:	e8 21 e8 ff ff       	call   80496c4 <strncmp@plt>
 804aea3:	85 c0                	test   %eax,%eax
 804aea5:	75 0f                	jne    804aeb6 <_ZL13skip_utf8_bomP12parse_buffer+0x7a>
    {
        buffer->offset += 3;
 804aea7:	8b 45 08             	mov    0x8(%ebp),%eax
 804aeaa:	8b 40 08             	mov    0x8(%eax),%eax
 804aead:	8d 50 03             	lea    0x3(%eax),%edx
 804aeb0:	8b 45 08             	mov    0x8(%ebp),%eax
 804aeb3:	89 50 08             	mov    %edx,0x8(%eax)
    }

    return buffer;
 804aeb6:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804aeb9:	c9                   	leave  
 804aeba:	c3                   	ret    

0804aebb <cJSON_ParseWithOpts>:

/* Parse an object - create a new root, and populate. */
CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
{
 804aebb:	55                   	push   %ebp
 804aebc:	89 e5                	mov    %esp,%ebp
 804aebe:	53                   	push   %ebx
 804aebf:	83 ec 44             	sub    $0x44,%esp
    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
 804aec2:	8d 55 d8             	lea    -0x28(%ebp),%edx
 804aec5:	b9 00 00 00 00       	mov    $0x0,%ecx
 804aeca:	b8 1c 00 00 00       	mov    $0x1c,%eax
 804aecf:	89 c3                	mov    %eax,%ebx
 804aed1:	83 e3 fc             	and    $0xfffffffc,%ebx
 804aed4:	b8 00 00 00 00       	mov    $0x0,%eax
 804aed9:	89 0c 02             	mov    %ecx,(%edx,%eax,1)
 804aedc:	83 c0 04             	add    $0x4,%eax
 804aedf:	39 d8                	cmp    %ebx,%eax
 804aee1:	72 f6                	jb     804aed9 <cJSON_ParseWithOpts+0x1e>
 804aee3:	01 c2                	add    %eax,%edx
    cJSON *item = NULL;
 804aee5:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    /* reset error position */
    global_error.json = NULL;
 804aeec:	c7 05 b8 04 05 08 00 	movl   $0x0,0x80504b8
 804aef3:	00 00 00 
    global_error.position = 0;
 804aef6:	c7 05 bc 04 05 08 00 	movl   $0x0,0x80504bc
 804aefd:	00 00 00 

    if (value == NULL)
 804af00:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804af04:	0f 84 bb 00 00 00    	je     804afc5 <cJSON_ParseWithOpts+0x10a>
    {
        goto fail;
    }

    buffer.content = (const unsigned char*)value;
 804af0a:	8b 45 08             	mov    0x8(%ebp),%eax
 804af0d:	89 45 d8             	mov    %eax,-0x28(%ebp)
    buffer.length = strlen((const char*)value) + sizeof("");
 804af10:	8b 45 08             	mov    0x8(%ebp),%eax
 804af13:	89 04 24             	mov    %eax,(%esp)
 804af16:	e8 59 e7 ff ff       	call   8049674 <strlen@plt>
 804af1b:	83 c0 01             	add    $0x1,%eax
 804af1e:	89 45 dc             	mov    %eax,-0x24(%ebp)
    buffer.offset = 0;
 804af21:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
    buffer.hooks = global_hooks;
 804af28:	a1 04 04 05 08       	mov    0x8050404,%eax
 804af2d:	89 45 e8             	mov    %eax,-0x18(%ebp)
 804af30:	a1 08 04 05 08       	mov    0x8050408,%eax
 804af35:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804af38:	a1 0c 04 05 08       	mov    0x805040c,%eax
 804af3d:	89 45 f0             	mov    %eax,-0x10(%ebp)

    item = cJSON_New_Item(&global_hooks);
 804af40:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804af47:	e8 5d ef ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804af4c:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (item == NULL) /* memory fail */
 804af4f:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804af53:	74 73                	je     804afc8 <cJSON_ParseWithOpts+0x10d>
    {
        goto fail;
    }

    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
 804af55:	8d 45 d8             	lea    -0x28(%ebp),%eax
 804af58:	89 04 24             	mov    %eax,(%esp)
 804af5b:	e8 dc fe ff ff       	call   804ae3c <_ZL13skip_utf8_bomP12parse_buffer>
 804af60:	89 04 24             	mov    %eax,(%esp)
 804af63:	e8 4d fe ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>
 804af68:	89 44 24 04          	mov    %eax,0x4(%esp)
 804af6c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804af6f:	89 04 24             	mov    %eax,(%esp)
 804af72:	e8 bb 03 00 00       	call   804b332 <_ZL11parse_valueP5cJSONP12parse_buffer>
 804af77:	85 c0                	test   %eax,%eax
 804af79:	0f 94 c0             	sete   %al
 804af7c:	84 c0                	test   %al,%al
 804af7e:	75 4b                	jne    804afcb <cJSON_ParseWithOpts+0x110>
        /* parse failure. ep is set. */
        goto fail;
    }

    /* if we require null-terminated JSON without appended garbage, skip and then check for a null terminator */
    if (require_null_terminated)
 804af80:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804af84:	74 25                	je     804afab <cJSON_ParseWithOpts+0xf0>
    {
        buffer_skip_whitespace(&buffer);
 804af86:	8d 45 d8             	lea    -0x28(%ebp),%eax
 804af89:	89 04 24             	mov    %eax,(%esp)
 804af8c:	e8 24 fe ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>
        if ((buffer.offset >= buffer.length) || buffer_at_offset(&buffer)[0] != '\0')
 804af91:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804af94:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804af97:	39 c2                	cmp    %eax,%edx
 804af99:	73 31                	jae    804afcc <cJSON_ParseWithOpts+0x111>
 804af9b:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804af9e:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804afa1:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804afa4:	0f b6 00             	movzbl (%eax),%eax
 804afa7:	84 c0                	test   %al,%al
 804afa9:	75 21                	jne    804afcc <cJSON_ParseWithOpts+0x111>
        {
            goto fail;
        }
    }
    if (return_parse_end)
 804afab:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804afaf:	74 0f                	je     804afc0 <cJSON_ParseWithOpts+0x105>
    {
        *return_parse_end = (const char*)buffer_at_offset(&buffer);
 804afb1:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804afb4:	89 c2                	mov    %eax,%edx
 804afb6:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804afb9:	01 c2                	add    %eax,%edx
 804afbb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804afbe:	89 10                	mov    %edx,(%eax)
    }

    return item;
 804afc0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804afc3:	eb 78                	jmp    804b03d <cJSON_ParseWithOpts+0x182>
    global_error.json = NULL;
    global_error.position = 0;

    if (value == NULL)
    {
        goto fail;
 804afc5:	90                   	nop
 804afc6:	eb 04                	jmp    804afcc <cJSON_ParseWithOpts+0x111>
    buffer.hooks = global_hooks;

    item = cJSON_New_Item(&global_hooks);
    if (item == NULL) /* memory fail */
    {
        goto fail;
 804afc8:	90                   	nop
 804afc9:	eb 01                	jmp    804afcc <cJSON_ParseWithOpts+0x111>
    }

    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
    {
        /* parse failure. ep is set. */
        goto fail;
 804afcb:	90                   	nop
    }

    return item;

fail:
    if (item != NULL)
 804afcc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804afd0:	74 0b                	je     804afdd <cJSON_ParseWithOpts+0x122>
    {
        cJSON_Delete(item);
 804afd2:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804afd5:	89 04 24             	mov    %eax,(%esp)
 804afd8:	e8 09 ef ff ff       	call   8049ee6 <cJSON_Delete>
    }

    if (value != NULL)
 804afdd:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804afe1:	74 55                	je     804b038 <cJSON_ParseWithOpts+0x17d>
    {
        error local_error;
        local_error.json = (const unsigned char*)value;
 804afe3:	8b 45 08             	mov    0x8(%ebp),%eax
 804afe6:	89 45 d0             	mov    %eax,-0x30(%ebp)
        local_error.position = 0;
 804afe9:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

        if (buffer.offset < buffer.length)
 804aff0:	8b 55 e0             	mov    -0x20(%ebp),%edx
 804aff3:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804aff6:	39 c2                	cmp    %eax,%edx
 804aff8:	73 08                	jae    804b002 <cJSON_ParseWithOpts+0x147>
        {
            local_error.position = buffer.offset;
 804affa:	8b 45 e0             	mov    -0x20(%ebp),%eax
 804affd:	89 45 d4             	mov    %eax,-0x2c(%ebp)
 804b000:	eb 10                	jmp    804b012 <cJSON_ParseWithOpts+0x157>
        }
        else if (buffer.length > 0)
 804b002:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b005:	85 c0                	test   %eax,%eax
 804b007:	74 09                	je     804b012 <cJSON_ParseWithOpts+0x157>
        {
            local_error.position = buffer.length - 1;
 804b009:	8b 45 dc             	mov    -0x24(%ebp),%eax
 804b00c:	83 e8 01             	sub    $0x1,%eax
 804b00f:	89 45 d4             	mov    %eax,-0x2c(%ebp)
        }

        if (return_parse_end != NULL)
 804b012:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b016:	74 0f                	je     804b027 <cJSON_ParseWithOpts+0x16c>
        {
            *return_parse_end = (const char*)local_error.json + local_error.position;
 804b018:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804b01b:	89 c2                	mov    %eax,%edx
 804b01d:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b020:	01 c2                	add    %eax,%edx
 804b022:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b025:	89 10                	mov    %edx,(%eax)
        }

        global_error = local_error;
 804b027:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804b02a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804b02d:	a3 b8 04 05 08       	mov    %eax,0x80504b8
 804b032:	89 15 bc 04 05 08    	mov    %edx,0x80504bc
    }

    return NULL;
 804b038:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804b03d:	83 c4 44             	add    $0x44,%esp
 804b040:	5b                   	pop    %ebx
 804b041:	5d                   	pop    %ebp
 804b042:	c3                   	ret    

0804b043 <cJSON_Parse>:

/* Default options for cJSON_Parse */
CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
{
 804b043:	55                   	push   %ebp
 804b044:	89 e5                	mov    %esp,%ebp
 804b046:	83 ec 18             	sub    $0x18,%esp
    return cJSON_ParseWithOpts(value, 0, 0);
 804b049:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804b050:	00 
 804b051:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804b058:	00 
 804b059:	8b 45 08             	mov    0x8(%ebp),%eax
 804b05c:	89 04 24             	mov    %eax,(%esp)
 804b05f:	e8 57 fe ff ff       	call   804aebb <cJSON_ParseWithOpts>
}
 804b064:	c9                   	leave  
 804b065:	c3                   	ret    

0804b066 <_ZL5printPK5cJSONiPK14internal_hooks>:

#define cjson_min(a, b) ((a < b) ? a : b)

static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
{
 804b066:	55                   	push   %ebp
 804b067:	89 e5                	mov    %esp,%ebp
 804b069:	83 ec 48             	sub    $0x48,%esp
    static const size_t default_buffer_size = 256;
    printbuffer buffer[1];
    unsigned char *printed = NULL;
 804b06c:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    memset(buffer, 0, sizeof(buffer));
 804b073:	c7 44 24 08 24 00 00 	movl   $0x24,0x8(%esp)
 804b07a:	00 
 804b07b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804b082:	00 
 804b083:	8d 45 d0             	lea    -0x30(%ebp),%eax
 804b086:	89 04 24             	mov    %eax,(%esp)
 804b089:	e8 76 e5 ff ff       	call   8049604 <memset@plt>

    /* create buffer */
    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
 804b08e:	8b 45 10             	mov    0x10(%ebp),%eax
 804b091:	8b 00                	mov    (%eax),%eax
 804b093:	c7 04 24 00 01 00 00 	movl   $0x100,(%esp)
 804b09a:	ff d0                	call   *%eax
 804b09c:	89 45 d0             	mov    %eax,-0x30(%ebp)
    buffer->length = default_buffer_size;
 804b09f:	c7 45 d4 00 01 00 00 	movl   $0x100,-0x2c(%ebp)
    buffer->format = format;
 804b0a6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b0a9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    buffer->hooks = *hooks;
 804b0ac:	8b 45 10             	mov    0x10(%ebp),%eax
 804b0af:	8b 10                	mov    (%eax),%edx
 804b0b1:	89 55 e8             	mov    %edx,-0x18(%ebp)
 804b0b4:	8b 50 04             	mov    0x4(%eax),%edx
 804b0b7:	89 55 ec             	mov    %edx,-0x14(%ebp)
 804b0ba:	8b 40 08             	mov    0x8(%eax),%eax
 804b0bd:	89 45 f0             	mov    %eax,-0x10(%ebp)
    if (buffer->buffer == NULL)
 804b0c0:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804b0c3:	85 c0                	test   %eax,%eax
 804b0c5:	0f 84 b7 00 00 00    	je     804b182 <_ZL5printPK5cJSONiPK14internal_hooks+0x11c>
    {
        goto fail;
    }

    /* print the value */
    if (!print_value(item, buffer))
 804b0cb:	8d 45 d0             	lea    -0x30(%ebp),%eax
 804b0ce:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b0d2:	8b 45 08             	mov    0x8(%ebp),%eax
 804b0d5:	89 04 24             	mov    %eax,(%esp)
 804b0d8:	e8 e9 04 00 00       	call   804b5c6 <_ZL11print_valuePK5cJSONP11printbuffer>
 804b0dd:	85 c0                	test   %eax,%eax
 804b0df:	0f 94 c0             	sete   %al
 804b0e2:	84 c0                	test   %al,%al
 804b0e4:	0f 85 9b 00 00 00    	jne    804b185 <_ZL5printPK5cJSONiPK14internal_hooks+0x11f>
    {
        goto fail;
    }
    update_offset(buffer);
 804b0ea:	8d 45 d0             	lea    -0x30(%ebp),%eax
 804b0ed:	89 04 24             	mov    %eax,(%esp)
 804b0f0:	e8 9f f2 ff ff       	call   804a394 <_ZL13update_offsetP11printbuffer>

    /* check if reallocate is available */
    if (hooks->reallocate != NULL)
 804b0f5:	8b 45 10             	mov    0x10(%ebp),%eax
 804b0f8:	8b 40 08             	mov    0x8(%eax),%eax
 804b0fb:	85 c0                	test   %eax,%eax
 804b0fd:	74 2a                	je     804b129 <_ZL5printPK5cJSONiPK14internal_hooks+0xc3>
    {
        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
 804b0ff:	8b 45 10             	mov    0x10(%ebp),%eax
 804b102:	8b 40 08             	mov    0x8(%eax),%eax
 804b105:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b108:	8d 4a 01             	lea    0x1(%edx),%ecx
 804b10b:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804b10e:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 804b112:	89 14 24             	mov    %edx,(%esp)
 804b115:	ff d0                	call   *%eax
 804b117:	89 45 f4             	mov    %eax,-0xc(%ebp)
        buffer->buffer = NULL;
 804b11a:	c7 45 d0 00 00 00 00 	movl   $0x0,-0x30(%ebp)
        if (printed == NULL) {
 804b121:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b125:	75 56                	jne    804b17d <_ZL5printPK5cJSONiPK14internal_hooks+0x117>
            goto fail;
 804b127:	eb 60                	jmp    804b189 <_ZL5printPK5cJSONiPK14internal_hooks+0x123>
        }
    }
    else /* otherwise copy the JSON over to a new buffer */
    {
        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
 804b129:	8b 45 10             	mov    0x10(%ebp),%eax
 804b12c:	8b 00                	mov    (%eax),%eax
 804b12e:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804b131:	83 c2 01             	add    $0x1,%edx
 804b134:	89 14 24             	mov    %edx,(%esp)
 804b137:	ff d0                	call   *%eax
 804b139:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (printed == NULL)
 804b13c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b140:	74 46                	je     804b188 <_ZL5printPK5cJSONiPK14internal_hooks+0x122>
        {
            goto fail;
        }
        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
 804b142:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b145:	8d 50 01             	lea    0x1(%eax),%edx
 804b148:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b14b:	39 c2                	cmp    %eax,%edx
 804b14d:	0f 47 d0             	cmova  %eax,%edx
 804b150:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804b153:	89 54 24 08          	mov    %edx,0x8(%esp)
 804b157:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b15b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b15e:	89 04 24             	mov    %eax,(%esp)
 804b161:	e8 fe e4 ff ff       	call   8049664 <memcpy@plt>
        printed[buffer->offset] = '\0'; /* just to be sure */
 804b166:	8b 45 d8             	mov    -0x28(%ebp),%eax
 804b169:	03 45 f4             	add    -0xc(%ebp),%eax
 804b16c:	c6 00 00             	movb   $0x0,(%eax)

        /* free the buffer */
        hooks->deallocate(buffer->buffer);
 804b16f:	8b 45 10             	mov    0x10(%ebp),%eax
 804b172:	8b 40 04             	mov    0x4(%eax),%eax
 804b175:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804b178:	89 14 24             	mov    %edx,(%esp)
 804b17b:	ff d0                	call   *%eax
    }

    return printed;
 804b17d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b180:	eb 35                	jmp    804b1b7 <_ZL5printPK5cJSONiPK14internal_hooks+0x151>
    buffer->length = default_buffer_size;
    buffer->format = format;
    buffer->hooks = *hooks;
    if (buffer->buffer == NULL)
    {
        goto fail;
 804b182:	90                   	nop
 804b183:	eb 04                	jmp    804b189 <_ZL5printPK5cJSONiPK14internal_hooks+0x123>
    }

    /* print the value */
    if (!print_value(item, buffer))
    {
        goto fail;
 804b185:	90                   	nop
 804b186:	eb 01                	jmp    804b189 <_ZL5printPK5cJSONiPK14internal_hooks+0x123>
    else /* otherwise copy the JSON over to a new buffer */
    {
        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
        if (printed == NULL)
        {
            goto fail;
 804b188:	90                   	nop
    }

    return printed;

fail:
    if (buffer->buffer != NULL)
 804b189:	8b 45 d0             	mov    -0x30(%ebp),%eax
 804b18c:	85 c0                	test   %eax,%eax
 804b18e:	74 0e                	je     804b19e <_ZL5printPK5cJSONiPK14internal_hooks+0x138>
    {
        hooks->deallocate(buffer->buffer);
 804b190:	8b 45 10             	mov    0x10(%ebp),%eax
 804b193:	8b 40 04             	mov    0x4(%eax),%eax
 804b196:	8b 55 d0             	mov    -0x30(%ebp),%edx
 804b199:	89 14 24             	mov    %edx,(%esp)
 804b19c:	ff d0                	call   *%eax
    }

    if (printed != NULL)
 804b19e:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b1a2:	74 0e                	je     804b1b2 <_ZL5printPK5cJSONiPK14internal_hooks+0x14c>
    {
        hooks->deallocate(printed);
 804b1a4:	8b 45 10             	mov    0x10(%ebp),%eax
 804b1a7:	8b 40 04             	mov    0x4(%eax),%eax
 804b1aa:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804b1ad:	89 14 24             	mov    %edx,(%esp)
 804b1b0:	ff d0                	call   *%eax
    }

    return NULL;
 804b1b2:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804b1b7:	c9                   	leave  
 804b1b8:	c3                   	ret    

0804b1b9 <cJSON_Print>:

/* Render a cJSON item/entity/structure to text. */
CJSON_PUBLIC(char *) cJSON_Print(const cJSON *item)
{
 804b1b9:	55                   	push   %ebp
 804b1ba:	89 e5                	mov    %esp,%ebp
 804b1bc:	83 ec 18             	sub    $0x18,%esp
    return (char*)print(item, true, &global_hooks);
 804b1bf:	c7 44 24 08 04 04 05 	movl   $0x8050404,0x8(%esp)
 804b1c6:	08 
 804b1c7:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804b1ce:	00 
 804b1cf:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1d2:	89 04 24             	mov    %eax,(%esp)
 804b1d5:	e8 8c fe ff ff       	call   804b066 <_ZL5printPK5cJSONiPK14internal_hooks>
}
 804b1da:	c9                   	leave  
 804b1db:	c3                   	ret    

0804b1dc <cJSON_PrintUnformatted>:

CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
{
 804b1dc:	55                   	push   %ebp
 804b1dd:	89 e5                	mov    %esp,%ebp
 804b1df:	83 ec 18             	sub    $0x18,%esp
    return (char*)print(item, false, &global_hooks);
 804b1e2:	c7 44 24 08 04 04 05 	movl   $0x8050404,0x8(%esp)
 804b1e9:	08 
 804b1ea:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 804b1f1:	00 
 804b1f2:	8b 45 08             	mov    0x8(%ebp),%eax
 804b1f5:	89 04 24             	mov    %eax,(%esp)
 804b1f8:	e8 69 fe ff ff       	call   804b066 <_ZL5printPK5cJSONiPK14internal_hooks>
}
 804b1fd:	c9                   	leave  
 804b1fe:	c3                   	ret    

0804b1ff <cJSON_PrintBuffered>:

CJSON_PUBLIC(char *) cJSON_PrintBuffered(const cJSON *item, int prebuffer, cJSON_bool fmt)
{
 804b1ff:	55                   	push   %ebp
 804b200:	89 e5                	mov    %esp,%ebp
 804b202:	57                   	push   %edi
 804b203:	53                   	push   %ebx
 804b204:	83 ec 40             	sub    $0x40,%esp
    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
 804b207:	8d 5d d4             	lea    -0x2c(%ebp),%ebx
 804b20a:	b8 00 00 00 00       	mov    $0x0,%eax
 804b20f:	ba 09 00 00 00       	mov    $0x9,%edx
 804b214:	89 df                	mov    %ebx,%edi
 804b216:	89 d1                	mov    %edx,%ecx
 804b218:	f3 ab                	rep stos %eax,%es:(%edi)

    if (prebuffer < 0)
 804b21a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b21e:	79 0a                	jns    804b22a <cJSON_PrintBuffered+0x2b>
    {
        return NULL;
 804b220:	b8 00 00 00 00       	mov    $0x0,%eax
 804b225:	e9 82 00 00 00       	jmp    804b2ac <cJSON_PrintBuffered+0xad>
    }

    p.buffer = (unsigned char*)global_hooks.allocate((size_t)prebuffer);
 804b22a:	a1 04 04 05 08       	mov    0x8050404,%eax
 804b22f:	8b 55 0c             	mov    0xc(%ebp),%edx
 804b232:	89 14 24             	mov    %edx,(%esp)
 804b235:	ff d0                	call   *%eax
 804b237:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    if (!p.buffer)
 804b23a:	8b 45 d4             	mov    -0x2c(%ebp),%eax
 804b23d:	85 c0                	test   %eax,%eax
 804b23f:	75 07                	jne    804b248 <cJSON_PrintBuffered+0x49>
    {
        return NULL;
 804b241:	b8 00 00 00 00       	mov    $0x0,%eax
 804b246:	eb 64                	jmp    804b2ac <cJSON_PrintBuffered+0xad>
    }

    p.length = (size_t)prebuffer;
 804b248:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b24b:	89 45 d8             	mov    %eax,-0x28(%ebp)
    p.offset = 0;
 804b24e:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    p.noalloc = false;
 804b255:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    p.format = fmt;
 804b25c:	8b 45 10             	mov    0x10(%ebp),%eax
 804b25f:	89 45 e8             	mov    %eax,-0x18(%ebp)
    p.hooks = global_hooks;
 804b262:	a1 04 04 05 08       	mov    0x8050404,%eax
 804b267:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804b26a:	a1 08 04 05 08       	mov    0x8050408,%eax
 804b26f:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804b272:	a1 0c 04 05 08       	mov    0x805040c,%eax
 804b277:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (!print_value(item, &p))
 804b27a:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 804b27d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b281:	8b 45 08             	mov    0x8(%ebp),%eax
 804b284:	89 04 24             	mov    %eax,(%esp)
 804b287:	e8 3a 03 00 00       	call   804b5c6 <_ZL11print_valuePK5cJSONP11printbuffer>
 804b28c:	85 c0                	test   %eax,%eax
 804b28e:	0f 94 c0             	sete   %al
 804b291:	84 c0                	test   %al,%al
 804b293:	74 14                	je     804b2a9 <cJSON_PrintBuffered+0xaa>
    {
        global_hooks.deallocate(p.buffer);
 804b295:	a1 08 04 05 08       	mov    0x8050408,%eax
 804b29a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
 804b29d:	89 14 24             	mov    %edx,(%esp)
 804b2a0:	ff d0                	call   *%eax
        return NULL;
 804b2a2:	b8 00 00 00 00       	mov    $0x0,%eax
 804b2a7:	eb 03                	jmp    804b2ac <cJSON_PrintBuffered+0xad>
    }

    return (char*)p.buffer;
 804b2a9:	8b 45 d4             	mov    -0x2c(%ebp),%eax
}
 804b2ac:	83 c4 40             	add    $0x40,%esp
 804b2af:	5b                   	pop    %ebx
 804b2b0:	5f                   	pop    %edi
 804b2b1:	5d                   	pop    %ebp
 804b2b2:	c3                   	ret    

0804b2b3 <cJSON_PrintPreallocated>:

CJSON_PUBLIC(cJSON_bool) cJSON_PrintPreallocated(cJSON *item, char *buf, const int len, const cJSON_bool fmt)
{
 804b2b3:	55                   	push   %ebp
 804b2b4:	89 e5                	mov    %esp,%ebp
 804b2b6:	57                   	push   %edi
 804b2b7:	53                   	push   %ebx
 804b2b8:	83 ec 40             	sub    $0x40,%esp
    printbuffer p = { 0, 0, 0, 0, 0, 0, { 0, 0, 0 } };
 804b2bb:	8d 5d d4             	lea    -0x2c(%ebp),%ebx
 804b2be:	b8 00 00 00 00       	mov    $0x0,%eax
 804b2c3:	ba 09 00 00 00       	mov    $0x9,%edx
 804b2c8:	89 df                	mov    %ebx,%edi
 804b2ca:	89 d1                	mov    %edx,%ecx
 804b2cc:	f3 ab                	rep stos %eax,%es:(%edi)

    if ((len < 0) || (buf == NULL))
 804b2ce:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804b2d2:	78 06                	js     804b2da <cJSON_PrintPreallocated+0x27>
 804b2d4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b2d8:	75 07                	jne    804b2e1 <cJSON_PrintPreallocated+0x2e>
    {
        return false;
 804b2da:	b8 00 00 00 00       	mov    $0x0,%eax
 804b2df:	eb 4a                	jmp    804b32b <cJSON_PrintPreallocated+0x78>
    }

    p.buffer = (unsigned char*)buf;
 804b2e1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b2e4:	89 45 d4             	mov    %eax,-0x2c(%ebp)
    p.length = (size_t)len;
 804b2e7:	8b 45 10             	mov    0x10(%ebp),%eax
 804b2ea:	89 45 d8             	mov    %eax,-0x28(%ebp)
    p.offset = 0;
 804b2ed:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    p.noalloc = true;
 804b2f4:	c7 45 e4 01 00 00 00 	movl   $0x1,-0x1c(%ebp)
    p.format = fmt;
 804b2fb:	8b 45 14             	mov    0x14(%ebp),%eax
 804b2fe:	89 45 e8             	mov    %eax,-0x18(%ebp)
    p.hooks = global_hooks;
 804b301:	a1 04 04 05 08       	mov    0x8050404,%eax
 804b306:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804b309:	a1 08 04 05 08       	mov    0x8050408,%eax
 804b30e:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804b311:	a1 0c 04 05 08       	mov    0x805040c,%eax
 804b316:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return print_value(item, &p);
 804b319:	8d 45 d4             	lea    -0x2c(%ebp),%eax
 804b31c:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b320:	8b 45 08             	mov    0x8(%ebp),%eax
 804b323:	89 04 24             	mov    %eax,(%esp)
 804b326:	e8 9b 02 00 00       	call   804b5c6 <_ZL11print_valuePK5cJSONP11printbuffer>
}
 804b32b:	83 c4 40             	add    $0x40,%esp
 804b32e:	5b                   	pop    %ebx
 804b32f:	5f                   	pop    %edi
 804b330:	5d                   	pop    %ebp
 804b331:	c3                   	ret    

0804b332 <_ZL11parse_valueP5cJSONP12parse_buffer>:

/* Parser core - when encountering text, process appropriately. */
static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
{
 804b332:	55                   	push   %ebp
 804b333:	89 e5                	mov    %esp,%ebp
 804b335:	83 ec 18             	sub    $0x18,%esp
    if ((input_buffer == NULL) || (input_buffer->content == NULL))
 804b338:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b33c:	74 09                	je     804b347 <_ZL11parse_valueP5cJSONP12parse_buffer+0x15>
 804b33e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b341:	8b 00                	mov    (%eax),%eax
 804b343:	85 c0                	test   %eax,%eax
 804b345:	75 0a                	jne    804b351 <_ZL11parse_valueP5cJSONP12parse_buffer+0x1f>
    {
        return false; /* no input */
 804b347:	b8 00 00 00 00       	mov    $0x0,%eax
 804b34c:	e9 73 02 00 00       	jmp    804b5c4 <_ZL11parse_valueP5cJSONP12parse_buffer+0x292>
    }

    /* parse the different types of values */
    /* null */
    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
 804b351:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b355:	74 62                	je     804b3b9 <_ZL11parse_valueP5cJSONP12parse_buffer+0x87>
 804b357:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b35a:	8b 40 08             	mov    0x8(%eax),%eax
 804b35d:	8d 50 04             	lea    0x4(%eax),%edx
 804b360:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b363:	8b 40 04             	mov    0x4(%eax),%eax
 804b366:	39 c2                	cmp    %eax,%edx
 804b368:	77 4f                	ja     804b3b9 <_ZL11parse_valueP5cJSONP12parse_buffer+0x87>
 804b36a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b36d:	8b 00                	mov    (%eax),%eax
 804b36f:	89 c2                	mov    %eax,%edx
 804b371:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b374:	8b 40 08             	mov    0x8(%eax),%eax
 804b377:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b37a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 804b381:	00 
 804b382:	c7 44 24 04 08 df 04 	movl   $0x804df08,0x4(%esp)
 804b389:	08 
 804b38a:	89 04 24             	mov    %eax,(%esp)
 804b38d:	e8 32 e3 ff ff       	call   80496c4 <strncmp@plt>
 804b392:	85 c0                	test   %eax,%eax
 804b394:	75 23                	jne    804b3b9 <_ZL11parse_valueP5cJSONP12parse_buffer+0x87>
    {
        item->type = cJSON_NULL;
 804b396:	8b 45 08             	mov    0x8(%ebp),%eax
 804b399:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
        input_buffer->offset += 4;
 804b3a0:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b3a3:	8b 40 08             	mov    0x8(%eax),%eax
 804b3a6:	8d 50 04             	lea    0x4(%eax),%edx
 804b3a9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b3ac:	89 50 08             	mov    %edx,0x8(%eax)
        return true;
 804b3af:	b8 01 00 00 00       	mov    $0x1,%eax
 804b3b4:	e9 0b 02 00 00       	jmp    804b5c4 <_ZL11parse_valueP5cJSONP12parse_buffer+0x292>
    }
    /* false */
    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
 804b3b9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b3bd:	74 62                	je     804b421 <_ZL11parse_valueP5cJSONP12parse_buffer+0xef>
 804b3bf:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b3c2:	8b 40 08             	mov    0x8(%eax),%eax
 804b3c5:	8d 50 05             	lea    0x5(%eax),%edx
 804b3c8:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b3cb:	8b 40 04             	mov    0x4(%eax),%eax
 804b3ce:	39 c2                	cmp    %eax,%edx
 804b3d0:	77 4f                	ja     804b421 <_ZL11parse_valueP5cJSONP12parse_buffer+0xef>
 804b3d2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b3d5:	8b 00                	mov    (%eax),%eax
 804b3d7:	89 c2                	mov    %eax,%edx
 804b3d9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b3dc:	8b 40 08             	mov    0x8(%eax),%eax
 804b3df:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b3e2:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
 804b3e9:	00 
 804b3ea:	c7 44 24 04 7d e0 04 	movl   $0x804e07d,0x4(%esp)
 804b3f1:	08 
 804b3f2:	89 04 24             	mov    %eax,(%esp)
 804b3f5:	e8 ca e2 ff ff       	call   80496c4 <strncmp@plt>
 804b3fa:	85 c0                	test   %eax,%eax
 804b3fc:	75 23                	jne    804b421 <_ZL11parse_valueP5cJSONP12parse_buffer+0xef>
    {
        item->type = cJSON_False;
 804b3fe:	8b 45 08             	mov    0x8(%ebp),%eax
 804b401:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
        input_buffer->offset += 5;
 804b408:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b40b:	8b 40 08             	mov    0x8(%eax),%eax
 804b40e:	8d 50 05             	lea    0x5(%eax),%edx
 804b411:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b414:	89 50 08             	mov    %edx,0x8(%eax)
        return true;
 804b417:	b8 01 00 00 00       	mov    $0x1,%eax
 804b41c:	e9 a3 01 00 00       	jmp    804b5c4 <_ZL11parse_valueP5cJSONP12parse_buffer+0x292>
    }
    /* true */
    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
 804b421:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b425:	74 6c                	je     804b493 <_ZL11parse_valueP5cJSONP12parse_buffer+0x161>
 804b427:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b42a:	8b 40 08             	mov    0x8(%eax),%eax
 804b42d:	8d 50 04             	lea    0x4(%eax),%edx
 804b430:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b433:	8b 40 04             	mov    0x4(%eax),%eax
 804b436:	39 c2                	cmp    %eax,%edx
 804b438:	77 59                	ja     804b493 <_ZL11parse_valueP5cJSONP12parse_buffer+0x161>
 804b43a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b43d:	8b 00                	mov    (%eax),%eax
 804b43f:	89 c2                	mov    %eax,%edx
 804b441:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b444:	8b 40 08             	mov    0x8(%eax),%eax
 804b447:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b44a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
 804b451:	00 
 804b452:	c7 44 24 04 83 e0 04 	movl   $0x804e083,0x4(%esp)
 804b459:	08 
 804b45a:	89 04 24             	mov    %eax,(%esp)
 804b45d:	e8 62 e2 ff ff       	call   80496c4 <strncmp@plt>
 804b462:	85 c0                	test   %eax,%eax
 804b464:	75 2d                	jne    804b493 <_ZL11parse_valueP5cJSONP12parse_buffer+0x161>
    {
        item->type = cJSON_True;
 804b466:	8b 45 08             	mov    0x8(%ebp),%eax
 804b469:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
        item->valueint = 1;
 804b470:	8b 45 08             	mov    0x8(%ebp),%eax
 804b473:	c7 40 14 01 00 00 00 	movl   $0x1,0x14(%eax)
        input_buffer->offset += 4;
 804b47a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b47d:	8b 40 08             	mov    0x8(%eax),%eax
 804b480:	8d 50 04             	lea    0x4(%eax),%edx
 804b483:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b486:	89 50 08             	mov    %edx,0x8(%eax)
        return true;
 804b489:	b8 01 00 00 00       	mov    $0x1,%eax
 804b48e:	e9 31 01 00 00       	jmp    804b5c4 <_ZL11parse_valueP5cJSONP12parse_buffer+0x292>
    }
    /* string */
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
 804b493:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b497:	74 3c                	je     804b4d5 <_ZL11parse_valueP5cJSONP12parse_buffer+0x1a3>
 804b499:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b49c:	8b 50 08             	mov    0x8(%eax),%edx
 804b49f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4a2:	8b 40 04             	mov    0x4(%eax),%eax
 804b4a5:	39 c2                	cmp    %eax,%edx
 804b4a7:	73 2c                	jae    804b4d5 <_ZL11parse_valueP5cJSONP12parse_buffer+0x1a3>
 804b4a9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4ac:	8b 10                	mov    (%eax),%edx
 804b4ae:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4b1:	8b 40 08             	mov    0x8(%eax),%eax
 804b4b4:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b4b7:	0f b6 00             	movzbl (%eax),%eax
 804b4ba:	3c 22                	cmp    $0x22,%al
 804b4bc:	75 17                	jne    804b4d5 <_ZL11parse_valueP5cJSONP12parse_buffer+0x1a3>
    {
        return parse_string(item, input_buffer);
 804b4be:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4c1:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b4c5:	8b 45 08             	mov    0x8(%ebp),%eax
 804b4c8:	89 04 24             	mov    %eax,(%esp)
 804b4cb:	e8 80 f3 ff ff       	call   804a850 <_ZL12parse_stringP5cJSONP12parse_buffer>
 804b4d0:	e9 ef 00 00 00       	jmp    804b5c4 <_ZL11parse_valueP5cJSONP12parse_buffer+0x292>
    }
    /* number */
    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
 804b4d5:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b4d9:	74 66                	je     804b541 <_ZL11parse_valueP5cJSONP12parse_buffer+0x20f>
 804b4db:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4de:	8b 50 08             	mov    0x8(%eax),%edx
 804b4e1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4e4:	8b 40 04             	mov    0x4(%eax),%eax
 804b4e7:	39 c2                	cmp    %eax,%edx
 804b4e9:	73 56                	jae    804b541 <_ZL11parse_valueP5cJSONP12parse_buffer+0x20f>
 804b4eb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4ee:	8b 10                	mov    (%eax),%edx
 804b4f0:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b4f3:	8b 40 08             	mov    0x8(%eax),%eax
 804b4f6:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b4f9:	0f b6 00             	movzbl (%eax),%eax
 804b4fc:	3c 2d                	cmp    $0x2d,%al
 804b4fe:	74 2a                	je     804b52a <_ZL11parse_valueP5cJSONP12parse_buffer+0x1f8>
 804b500:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b503:	8b 10                	mov    (%eax),%edx
 804b505:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b508:	8b 40 08             	mov    0x8(%eax),%eax
 804b50b:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b50e:	0f b6 00             	movzbl (%eax),%eax
 804b511:	3c 2f                	cmp    $0x2f,%al
 804b513:	76 2c                	jbe    804b541 <_ZL11parse_valueP5cJSONP12parse_buffer+0x20f>
 804b515:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b518:	8b 10                	mov    (%eax),%edx
 804b51a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b51d:	8b 40 08             	mov    0x8(%eax),%eax
 804b520:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b523:	0f b6 00             	movzbl (%eax),%eax
 804b526:	3c 39                	cmp    $0x39,%al
 804b528:	77 17                	ja     804b541 <_ZL11parse_valueP5cJSONP12parse_buffer+0x20f>
    {
        return parse_number(item, input_buffer);
 804b52a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b52d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b531:	8b 45 08             	mov    0x8(%ebp),%eax
 804b534:	89 04 24             	mov    %eax,(%esp)
 804b537:	e8 6b ea ff ff       	call   8049fa7 <_ZL12parse_numberP5cJSONP12parse_buffer>
 804b53c:	e9 83 00 00 00       	jmp    804b5c4 <_ZL11parse_valueP5cJSONP12parse_buffer+0x292>
    }
    /* array */
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
 804b541:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b545:	74 39                	je     804b580 <_ZL11parse_valueP5cJSONP12parse_buffer+0x24e>
 804b547:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b54a:	8b 50 08             	mov    0x8(%eax),%edx
 804b54d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b550:	8b 40 04             	mov    0x4(%eax),%eax
 804b553:	39 c2                	cmp    %eax,%edx
 804b555:	73 29                	jae    804b580 <_ZL11parse_valueP5cJSONP12parse_buffer+0x24e>
 804b557:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b55a:	8b 10                	mov    (%eax),%edx
 804b55c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b55f:	8b 40 08             	mov    0x8(%eax),%eax
 804b562:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b565:	0f b6 00             	movzbl (%eax),%eax
 804b568:	3c 5b                	cmp    $0x5b,%al
 804b56a:	75 14                	jne    804b580 <_ZL11parse_valueP5cJSONP12parse_buffer+0x24e>
    {
        return parse_array(item, input_buffer);
 804b56c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b56f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b573:	8b 45 08             	mov    0x8(%ebp),%eax
 804b576:	89 04 24             	mov    %eax,(%esp)
 804b579:	e8 84 02 00 00       	call   804b802 <_ZL11parse_arrayP5cJSONP12parse_buffer>
 804b57e:	eb 44                	jmp    804b5c4 <_ZL11parse_valueP5cJSONP12parse_buffer+0x292>
    }
    /* object */
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
 804b580:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b584:	74 39                	je     804b5bf <_ZL11parse_valueP5cJSONP12parse_buffer+0x28d>
 804b586:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b589:	8b 50 08             	mov    0x8(%eax),%edx
 804b58c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b58f:	8b 40 04             	mov    0x4(%eax),%eax
 804b592:	39 c2                	cmp    %eax,%edx
 804b594:	73 29                	jae    804b5bf <_ZL11parse_valueP5cJSONP12parse_buffer+0x28d>
 804b596:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b599:	8b 10                	mov    (%eax),%edx
 804b59b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b59e:	8b 40 08             	mov    0x8(%eax),%eax
 804b5a1:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b5a4:	0f b6 00             	movzbl (%eax),%eax
 804b5a7:	3c 7b                	cmp    $0x7b,%al
 804b5a9:	75 14                	jne    804b5bf <_ZL11parse_valueP5cJSONP12parse_buffer+0x28d>
    {
        return parse_object(item, input_buffer);
 804b5ab:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b5ae:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b5b2:	8b 45 08             	mov    0x8(%ebp),%eax
 804b5b5:	89 04 24             	mov    %eax,(%esp)
 804b5b8:	e8 f3 05 00 00       	call   804bbb0 <_ZL12parse_objectP5cJSONP12parse_buffer>
 804b5bd:	eb 05                	jmp    804b5c4 <_ZL11parse_valueP5cJSONP12parse_buffer+0x292>
    }

    return false;
 804b5bf:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804b5c4:	c9                   	leave  
 804b5c5:	c3                   	ret    

0804b5c6 <_ZL11print_valuePK5cJSONP11printbuffer>:

/* Render a value to text. */
static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
{
 804b5c6:	55                   	push   %ebp
 804b5c7:	89 e5                	mov    %esp,%ebp
 804b5c9:	83 ec 28             	sub    $0x28,%esp
    unsigned char *output = NULL;
 804b5cc:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    if ((item == NULL) || (output_buffer == NULL))
 804b5d3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804b5d7:	74 06                	je     804b5df <_ZL11print_valuePK5cJSONP11printbuffer+0x19>
 804b5d9:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b5dd:	75 0a                	jne    804b5e9 <_ZL11print_valuePK5cJSONP11printbuffer+0x23>
    {
        return false;
 804b5df:	b8 00 00 00 00       	mov    $0x0,%eax
 804b5e4:	e9 17 02 00 00       	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>
    }

    switch ((item->type) & 0xFF)
 804b5e9:	8b 45 08             	mov    0x8(%ebp),%eax
 804b5ec:	8b 40 0c             	mov    0xc(%eax),%eax
 804b5ef:	25 ff 00 00 00       	and    $0xff,%eax
 804b5f4:	83 f8 08             	cmp    $0x8,%eax
 804b5f7:	0f 84 37 01 00 00    	je     804b734 <_ZL11print_valuePK5cJSONP11printbuffer+0x16e>
 804b5fd:	83 f8 08             	cmp    $0x8,%eax
 804b600:	7f 1c                	jg     804b61e <_ZL11print_valuePK5cJSONP11printbuffer+0x58>
 804b602:	83 f8 02             	cmp    $0x2,%eax
 804b605:	0f 84 de 00 00 00    	je     804b6e9 <_ZL11print_valuePK5cJSONP11printbuffer+0x123>
 804b60b:	83 f8 04             	cmp    $0x4,%eax
 804b60e:	74 43                	je     804b653 <_ZL11print_valuePK5cJSONP11printbuffer+0x8d>
 804b610:	83 f8 01             	cmp    $0x1,%eax
 804b613:	0f 84 85 00 00 00    	je     804b69e <_ZL11print_valuePK5cJSONP11printbuffer+0xd8>
 804b619:	e9 dd 01 00 00       	jmp    804b7fb <_ZL11print_valuePK5cJSONP11printbuffer+0x235>
 804b61e:	83 f8 20             	cmp    $0x20,%eax
 804b621:	0f 84 ac 01 00 00    	je     804b7d3 <_ZL11print_valuePK5cJSONP11printbuffer+0x20d>
 804b627:	83 f8 20             	cmp    $0x20,%eax
 804b62a:	7f 0e                	jg     804b63a <_ZL11print_valuePK5cJSONP11printbuffer+0x74>
 804b62c:	83 f8 10             	cmp    $0x10,%eax
 804b62f:	0f 84 8a 01 00 00    	je     804b7bf <_ZL11print_valuePK5cJSONP11printbuffer+0x1f9>
 804b635:	e9 c1 01 00 00       	jmp    804b7fb <_ZL11print_valuePK5cJSONP11printbuffer+0x235>
 804b63a:	83 f8 40             	cmp    $0x40,%eax
 804b63d:	0f 84 a4 01 00 00    	je     804b7e7 <_ZL11print_valuePK5cJSONP11printbuffer+0x221>
 804b643:	3d 80 00 00 00       	cmp    $0x80,%eax
 804b648:	0f 84 fd 00 00 00    	je     804b74b <_ZL11print_valuePK5cJSONP11printbuffer+0x185>
 804b64e:	e9 a8 01 00 00       	jmp    804b7fb <_ZL11print_valuePK5cJSONP11printbuffer+0x235>
    {
        case cJSON_NULL:
            output = ensure(output_buffer, 5);
 804b653:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
 804b65a:	00 
 804b65b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b65e:	89 04 24             	mov    %eax,(%esp)
 804b661:	e8 71 eb ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804b666:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if (output == NULL)
 804b669:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804b66d:	75 0a                	jne    804b679 <_ZL11print_valuePK5cJSONP11printbuffer+0xb3>
            {
                return false;
 804b66f:	b8 00 00 00 00       	mov    $0x0,%eax
 804b674:	e9 87 01 00 00       	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>
            }
            strcpy((char*)output, "null");
 804b679:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b67c:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
 804b683:	00 
 804b684:	c7 44 24 04 08 df 04 	movl   $0x804df08,0x4(%esp)
 804b68b:	08 
 804b68c:	89 04 24             	mov    %eax,(%esp)
 804b68f:	e8 d0 df ff ff       	call   8049664 <memcpy@plt>
            return true;
 804b694:	b8 01 00 00 00       	mov    $0x1,%eax
 804b699:	e9 62 01 00 00       	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>

        case cJSON_False:
            output = ensure(output_buffer, 6);
 804b69e:	c7 44 24 04 06 00 00 	movl   $0x6,0x4(%esp)
 804b6a5:	00 
 804b6a6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b6a9:	89 04 24             	mov    %eax,(%esp)
 804b6ac:	e8 26 eb ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804b6b1:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if (output == NULL)
 804b6b4:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804b6b8:	75 0a                	jne    804b6c4 <_ZL11print_valuePK5cJSONP11printbuffer+0xfe>
            {
                return false;
 804b6ba:	b8 00 00 00 00       	mov    $0x0,%eax
 804b6bf:	e9 3c 01 00 00       	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>
            }
            strcpy((char*)output, "false");
 804b6c4:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b6c7:	c7 44 24 08 06 00 00 	movl   $0x6,0x8(%esp)
 804b6ce:	00 
 804b6cf:	c7 44 24 04 7d e0 04 	movl   $0x804e07d,0x4(%esp)
 804b6d6:	08 
 804b6d7:	89 04 24             	mov    %eax,(%esp)
 804b6da:	e8 85 df ff ff       	call   8049664 <memcpy@plt>
            return true;
 804b6df:	b8 01 00 00 00       	mov    $0x1,%eax
 804b6e4:	e9 17 01 00 00       	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>

        case cJSON_True:
            output = ensure(output_buffer, 5);
 804b6e9:	c7 44 24 04 05 00 00 	movl   $0x5,0x4(%esp)
 804b6f0:	00 
 804b6f1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b6f4:	89 04 24             	mov    %eax,(%esp)
 804b6f7:	e8 db ea ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804b6fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if (output == NULL)
 804b6ff:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804b703:	75 0a                	jne    804b70f <_ZL11print_valuePK5cJSONP11printbuffer+0x149>
            {
                return false;
 804b705:	b8 00 00 00 00       	mov    $0x0,%eax
 804b70a:	e9 f1 00 00 00       	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>
            }
            strcpy((char*)output, "true");
 804b70f:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b712:	c7 44 24 08 05 00 00 	movl   $0x5,0x8(%esp)
 804b719:	00 
 804b71a:	c7 44 24 04 83 e0 04 	movl   $0x804e083,0x4(%esp)
 804b721:	08 
 804b722:	89 04 24             	mov    %eax,(%esp)
 804b725:	e8 3a df ff ff       	call   8049664 <memcpy@plt>
            return true;
 804b72a:	b8 01 00 00 00       	mov    $0x1,%eax
 804b72f:	e9 cc 00 00 00       	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>

        case cJSON_Number:
            return print_number(item, output_buffer);
 804b734:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b737:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b73b:	8b 45 08             	mov    0x8(%ebp),%eax
 804b73e:	89 04 24             	mov    %eax,(%esp)
 804b741:	e8 a2 ec ff ff       	call   804a3e8 <_ZL12print_numberPK5cJSONP11printbuffer>
 804b746:	e9 b5 00 00 00       	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>

        case cJSON_Raw:
        {
            size_t raw_length = 0;
 804b74b:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            if (item->valuestring == NULL)
 804b752:	8b 45 08             	mov    0x8(%ebp),%eax
 804b755:	8b 40 10             	mov    0x10(%eax),%eax
 804b758:	85 c0                	test   %eax,%eax
 804b75a:	75 0a                	jne    804b766 <_ZL11print_valuePK5cJSONP11printbuffer+0x1a0>
            {
                return false;
 804b75c:	b8 00 00 00 00       	mov    $0x0,%eax
 804b761:	e9 9a 00 00 00       	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>
            }

            raw_length = strlen(item->valuestring) + sizeof("");
 804b766:	8b 45 08             	mov    0x8(%ebp),%eax
 804b769:	8b 40 10             	mov    0x10(%eax),%eax
 804b76c:	89 04 24             	mov    %eax,(%esp)
 804b76f:	e8 00 df ff ff       	call   8049674 <strlen@plt>
 804b774:	83 c0 01             	add    $0x1,%eax
 804b777:	89 45 f4             	mov    %eax,-0xc(%ebp)
            output = ensure(output_buffer, raw_length);
 804b77a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b77d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b781:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b784:	89 04 24             	mov    %eax,(%esp)
 804b787:	e8 4b ea ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804b78c:	89 45 f0             	mov    %eax,-0x10(%ebp)
            if (output == NULL)
 804b78f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804b793:	75 07                	jne    804b79c <_ZL11print_valuePK5cJSONP11printbuffer+0x1d6>
            {
                return false;
 804b795:	b8 00 00 00 00       	mov    $0x0,%eax
 804b79a:	eb 64                	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>
            }
            memcpy(output, item->valuestring, raw_length);
 804b79c:	8b 45 08             	mov    0x8(%ebp),%eax
 804b79f:	8b 40 10             	mov    0x10(%eax),%eax
 804b7a2:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804b7a5:	89 54 24 08          	mov    %edx,0x8(%esp)
 804b7a9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b7ad:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b7b0:	89 04 24             	mov    %eax,(%esp)
 804b7b3:	e8 ac de ff ff       	call   8049664 <memcpy@plt>
            return true;
 804b7b8:	b8 01 00 00 00       	mov    $0x1,%eax
 804b7bd:	eb 41                	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>
        }

        case cJSON_String:
            return print_string(item, output_buffer);
 804b7bf:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b7c2:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b7c6:	8b 45 08             	mov    0x8(%ebp),%eax
 804b7c9:	89 04 24             	mov    %eax,(%esp)
 804b7cc:	e8 c7 f5 ff ff       	call   804ad98 <_ZL12print_stringPK5cJSONP11printbuffer>
 804b7d1:	eb 2d                	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>

        case cJSON_Array:
            return print_array(item, output_buffer);
 804b7d3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b7d6:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b7da:	8b 45 08             	mov    0x8(%ebp),%eax
 804b7dd:	89 04 24             	mov    %eax,(%esp)
 804b7e0:	e8 40 02 00 00       	call   804ba25 <_ZL11print_arrayPK5cJSONP11printbuffer>
 804b7e5:	eb 19                	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>

        case cJSON_Object:
            return print_object(item, output_buffer);
 804b7e7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b7ea:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b7ee:	8b 45 08             	mov    0x8(%ebp),%eax
 804b7f1:	89 04 24             	mov    %eax,(%esp)
 804b7f4:	e8 89 06 00 00       	call   804be82 <_ZL12print_objectPK5cJSONP11printbuffer>
 804b7f9:	eb 05                	jmp    804b800 <_ZL11print_valuePK5cJSONP11printbuffer+0x23a>

        default:
            return false;
 804b7fb:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
 804b800:	c9                   	leave  
 804b801:	c3                   	ret    

0804b802 <_ZL11parse_arrayP5cJSONP12parse_buffer>:

/* Build an array from input text. */
static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
{
 804b802:	55                   	push   %ebp
 804b803:	89 e5                	mov    %esp,%ebp
 804b805:	83 ec 28             	sub    $0x28,%esp
    cJSON *head = NULL; /* head of the linked list */
 804b808:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    cJSON *current_item = NULL;
 804b80f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
 804b816:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b819:	8b 40 0c             	mov    0xc(%eax),%eax
 804b81c:	3d e7 03 00 00       	cmp    $0x3e7,%eax
 804b821:	76 0a                	jbe    804b82d <_ZL11parse_arrayP5cJSONP12parse_buffer+0x2b>
    {
        return false; /* to deeply nested */
 804b823:	b8 00 00 00 00       	mov    $0x0,%eax
 804b828:	e9 f6 01 00 00       	jmp    804ba23 <_ZL11parse_arrayP5cJSONP12parse_buffer+0x221>
    }
    input_buffer->depth++;
 804b82d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b830:	8b 40 0c             	mov    0xc(%eax),%eax
 804b833:	8d 50 01             	lea    0x1(%eax),%edx
 804b836:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b839:	89 50 0c             	mov    %edx,0xc(%eax)

    if (buffer_at_offset(input_buffer)[0] != '[')
 804b83c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b83f:	8b 10                	mov    (%eax),%edx
 804b841:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b844:	8b 40 08             	mov    0x8(%eax),%eax
 804b847:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b84a:	0f b6 00             	movzbl (%eax),%eax
 804b84d:	3c 5b                	cmp    $0x5b,%al
 804b84f:	0f 85 b1 01 00 00    	jne    804ba06 <_ZL11parse_arrayP5cJSONP12parse_buffer+0x204>
    {
        /* not an array */
        goto fail;
    }

    input_buffer->offset++;
 804b855:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b858:	8b 40 08             	mov    0x8(%eax),%eax
 804b85b:	8d 50 01             	lea    0x1(%eax),%edx
 804b85e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b861:	89 50 08             	mov    %edx,0x8(%eax)
    buffer_skip_whitespace(input_buffer);
 804b864:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b867:	89 04 24             	mov    %eax,(%esp)
 804b86a:	e8 46 f5 ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
 804b86f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b873:	74 29                	je     804b89e <_ZL11parse_arrayP5cJSONP12parse_buffer+0x9c>
 804b875:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b878:	8b 50 08             	mov    0x8(%eax),%edx
 804b87b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b87e:	8b 40 04             	mov    0x4(%eax),%eax
 804b881:	39 c2                	cmp    %eax,%edx
 804b883:	73 19                	jae    804b89e <_ZL11parse_arrayP5cJSONP12parse_buffer+0x9c>
 804b885:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b888:	8b 10                	mov    (%eax),%edx
 804b88a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b88d:	8b 40 08             	mov    0x8(%eax),%eax
 804b890:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b893:	0f b6 00             	movzbl (%eax),%eax
 804b896:	3c 5d                	cmp    $0x5d,%al
 804b898:	0f 84 2f 01 00 00    	je     804b9cd <_ZL11parse_arrayP5cJSONP12parse_buffer+0x1cb>
        /* empty array */
        goto success;
    }

    /* check if we skipped to the end of the buffer */
    if (cannot_access_at_index(input_buffer, 0))
 804b89e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b8a2:	74 10                	je     804b8b4 <_ZL11parse_arrayP5cJSONP12parse_buffer+0xb2>
 804b8a4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b8a7:	8b 50 08             	mov    0x8(%eax),%edx
 804b8aa:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b8ad:	8b 40 04             	mov    0x4(%eax),%eax
 804b8b0:	39 c2                	cmp    %eax,%edx
 804b8b2:	72 14                	jb     804b8c8 <_ZL11parse_arrayP5cJSONP12parse_buffer+0xc6>
    {
        input_buffer->offset--;
 804b8b4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b8b7:	8b 40 08             	mov    0x8(%eax),%eax
 804b8ba:	8d 50 ff             	lea    -0x1(%eax),%edx
 804b8bd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b8c0:	89 50 08             	mov    %edx,0x8(%eax)
        goto fail;
 804b8c3:	e9 45 01 00 00       	jmp    804ba0d <_ZL11parse_arrayP5cJSONP12parse_buffer+0x20b>
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
 804b8c8:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b8cb:	8b 40 08             	mov    0x8(%eax),%eax
 804b8ce:	8d 50 ff             	lea    -0x1(%eax),%edx
 804b8d1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b8d4:	89 50 08             	mov    %edx,0x8(%eax)
    /* loop through the comma separated array elements */
    do
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
 804b8d7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b8da:	83 c0 10             	add    $0x10,%eax
 804b8dd:	89 04 24             	mov    %eax,(%esp)
 804b8e0:	e8 c4 e5 ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804b8e5:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (new_item == NULL)
 804b8e8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804b8ec:	0f 84 17 01 00 00    	je     804ba09 <_ZL11parse_arrayP5cJSONP12parse_buffer+0x207>
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
 804b8f2:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804b8f6:	75 0e                	jne    804b906 <_ZL11parse_arrayP5cJSONP12parse_buffer+0x104>
        {
            /* start the linked list */
            current_item = head = new_item;
 804b8f8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b8fb:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804b8fe:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804b901:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804b904:	eb 17                	jmp    804b91d <_ZL11parse_arrayP5cJSONP12parse_buffer+0x11b>
        }
        else
        {
            /* add to the end and advance */
            current_item->next = new_item;
 804b906:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b909:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804b90c:	89 10                	mov    %edx,(%eax)
            new_item->prev = current_item;
 804b90e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b911:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804b914:	89 50 04             	mov    %edx,0x4(%eax)
            current_item = new_item;
 804b917:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804b91a:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }

        /* parse next value */
        input_buffer->offset++;
 804b91d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b920:	8b 40 08             	mov    0x8(%eax),%eax
 804b923:	8d 50 01             	lea    0x1(%eax),%edx
 804b926:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b929:	89 50 08             	mov    %edx,0x8(%eax)
        buffer_skip_whitespace(input_buffer);
 804b92c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b92f:	89 04 24             	mov    %eax,(%esp)
 804b932:	e8 7e f4 ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>
        if (!parse_value(current_item, input_buffer))
 804b937:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b93a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b93e:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804b941:	89 04 24             	mov    %eax,(%esp)
 804b944:	e8 e9 f9 ff ff       	call   804b332 <_ZL11parse_valueP5cJSONP12parse_buffer>
 804b949:	85 c0                	test   %eax,%eax
 804b94b:	0f 94 c0             	sete   %al
 804b94e:	84 c0                	test   %al,%al
 804b950:	0f 85 b6 00 00 00    	jne    804ba0c <_ZL11parse_arrayP5cJSONP12parse_buffer+0x20a>
        {
            goto fail; /* failed to parse value */
        }
        buffer_skip_whitespace(input_buffer);
 804b956:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b959:	89 04 24             	mov    %eax,(%esp)
 804b95c:	e8 54 f4 ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
    /* loop through the comma separated array elements */
    do
 804b961:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b965:	74 2c                	je     804b993 <_ZL11parse_arrayP5cJSONP12parse_buffer+0x191>
 804b967:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b96a:	8b 50 08             	mov    0x8(%eax),%edx
 804b96d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b970:	8b 40 04             	mov    0x4(%eax),%eax
 804b973:	39 c2                	cmp    %eax,%edx
 804b975:	73 1c                	jae    804b993 <_ZL11parse_arrayP5cJSONP12parse_buffer+0x191>
 804b977:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b97a:	8b 10                	mov    (%eax),%edx
 804b97c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b97f:	8b 40 08             	mov    0x8(%eax),%eax
 804b982:	8d 04 02             	lea    (%edx,%eax,1),%eax
        {
            goto fail; /* failed to parse value */
        }
        buffer_skip_whitespace(input_buffer);
    }
    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
 804b985:	0f b6 00             	movzbl (%eax),%eax
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
    /* loop through the comma separated array elements */
    do
 804b988:	3c 2c                	cmp    $0x2c,%al
 804b98a:	75 07                	jne    804b993 <_ZL11parse_arrayP5cJSONP12parse_buffer+0x191>
 804b98c:	b8 01 00 00 00       	mov    $0x1,%eax
 804b991:	eb 05                	jmp    804b998 <_ZL11parse_arrayP5cJSONP12parse_buffer+0x196>
 804b993:	b8 00 00 00 00       	mov    $0x0,%eax
 804b998:	84 c0                	test   %al,%al
 804b99a:	0f 85 37 ff ff ff    	jne    804b8d7 <_ZL11parse_arrayP5cJSONP12parse_buffer+0xd5>
        }
        buffer_skip_whitespace(input_buffer);
    }
    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));

    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
 804b9a0:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804b9a4:	74 67                	je     804ba0d <_ZL11parse_arrayP5cJSONP12parse_buffer+0x20b>
 804b9a6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9a9:	8b 50 08             	mov    0x8(%eax),%edx
 804b9ac:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9af:	8b 40 04             	mov    0x4(%eax),%eax
 804b9b2:	39 c2                	cmp    %eax,%edx
 804b9b4:	73 57                	jae    804ba0d <_ZL11parse_arrayP5cJSONP12parse_buffer+0x20b>
 804b9b6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9b9:	8b 10                	mov    (%eax),%edx
 804b9bb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9be:	8b 40 08             	mov    0x8(%eax),%eax
 804b9c1:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804b9c4:	0f b6 00             	movzbl (%eax),%eax
 804b9c7:	3c 5d                	cmp    $0x5d,%al
 804b9c9:	75 42                	jne    804ba0d <_ZL11parse_arrayP5cJSONP12parse_buffer+0x20b>
 804b9cb:	eb 01                	jmp    804b9ce <_ZL11parse_arrayP5cJSONP12parse_buffer+0x1cc>
    input_buffer->offset++;
    buffer_skip_whitespace(input_buffer);
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
    {
        /* empty array */
        goto success;
 804b9cd:	90                   	nop
    {
        goto fail; /* expected end of array */
    }

success:
    input_buffer->depth--;
 804b9ce:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9d1:	8b 40 0c             	mov    0xc(%eax),%eax
 804b9d4:	8d 50 ff             	lea    -0x1(%eax),%edx
 804b9d7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9da:	89 50 0c             	mov    %edx,0xc(%eax)

    item->type = cJSON_Array;
 804b9dd:	8b 45 08             	mov    0x8(%ebp),%eax
 804b9e0:	c7 40 0c 20 00 00 00 	movl   $0x20,0xc(%eax)
    item->child = head;
 804b9e7:	8b 45 08             	mov    0x8(%ebp),%eax
 804b9ea:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804b9ed:	89 50 08             	mov    %edx,0x8(%eax)

    input_buffer->offset++;
 804b9f0:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9f3:	8b 40 08             	mov    0x8(%eax),%eax
 804b9f6:	8d 50 01             	lea    0x1(%eax),%edx
 804b9f9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804b9fc:	89 50 08             	mov    %edx,0x8(%eax)

    return true;
 804b9ff:	b8 01 00 00 00       	mov    $0x1,%eax
 804ba04:	eb 1d                	jmp    804ba23 <_ZL11parse_arrayP5cJSONP12parse_buffer+0x221>
    input_buffer->depth++;

    if (buffer_at_offset(input_buffer)[0] != '[')
    {
        /* not an array */
        goto fail;
 804ba06:	90                   	nop
 804ba07:	eb 04                	jmp    804ba0d <_ZL11parse_arrayP5cJSONP12parse_buffer+0x20b>
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
        if (new_item == NULL)
        {
            goto fail; /* allocation failure */
 804ba09:	90                   	nop
 804ba0a:	eb 01                	jmp    804ba0d <_ZL11parse_arrayP5cJSONP12parse_buffer+0x20b>
        /* parse next value */
        input_buffer->offset++;
        buffer_skip_whitespace(input_buffer);
        if (!parse_value(current_item, input_buffer))
        {
            goto fail; /* failed to parse value */
 804ba0c:	90                   	nop
    input_buffer->offset++;

    return true;

fail:
    if (head != NULL)
 804ba0d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804ba11:	74 0b                	je     804ba1e <_ZL11parse_arrayP5cJSONP12parse_buffer+0x21c>
    {
        cJSON_Delete(head);
 804ba13:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ba16:	89 04 24             	mov    %eax,(%esp)
 804ba19:	e8 c8 e4 ff ff       	call   8049ee6 <cJSON_Delete>
    }

    return false;
 804ba1e:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804ba23:	c9                   	leave  
 804ba24:	c3                   	ret    

0804ba25 <_ZL11print_arrayPK5cJSONP11printbuffer>:

/* Render an array to text */
static cJSON_bool print_array(const cJSON * const item, printbuffer * const output_buffer)
{
 804ba25:	55                   	push   %ebp
 804ba26:	89 e5                	mov    %esp,%ebp
 804ba28:	83 ec 28             	sub    $0x28,%esp
    unsigned char *output_pointer = NULL;
 804ba2b:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    size_t length = 0;
 804ba32:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cJSON *current_element = item->child;
 804ba39:	8b 45 08             	mov    0x8(%ebp),%eax
 804ba3c:	8b 40 08             	mov    0x8(%eax),%eax
 804ba3f:	89 45 f4             	mov    %eax,-0xc(%ebp)

    if (output_buffer == NULL)
 804ba42:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804ba46:	75 0a                	jne    804ba52 <_ZL11print_arrayPK5cJSONP11printbuffer+0x2d>
    {
        return false;
 804ba48:	b8 00 00 00 00       	mov    $0x0,%eax
 804ba4d:	e9 5c 01 00 00       	jmp    804bbae <_ZL11print_arrayPK5cJSONP11printbuffer+0x189>
    }

    /* Compose the output array. */
    /* opening square bracket */
    output_pointer = ensure(output_buffer, 1);
 804ba52:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804ba59:	00 
 804ba5a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ba5d:	89 04 24             	mov    %eax,(%esp)
 804ba60:	e8 72 e7 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804ba65:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (output_pointer == NULL)
 804ba68:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804ba6c:	75 0a                	jne    804ba78 <_ZL11print_arrayPK5cJSONP11printbuffer+0x53>
    {
        return false;
 804ba6e:	b8 00 00 00 00       	mov    $0x0,%eax
 804ba73:	e9 36 01 00 00       	jmp    804bbae <_ZL11print_arrayPK5cJSONP11printbuffer+0x189>
    }

    *output_pointer = '[';
 804ba78:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804ba7b:	c6 00 5b             	movb   $0x5b,(%eax)
    output_buffer->offset++;
 804ba7e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ba81:	8b 40 08             	mov    0x8(%eax),%eax
 804ba84:	8d 50 01             	lea    0x1(%eax),%edx
 804ba87:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ba8a:	89 50 08             	mov    %edx,0x8(%eax)
    output_buffer->depth++;
 804ba8d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ba90:	8b 40 0c             	mov    0xc(%eax),%eax
 804ba93:	8d 50 01             	lea    0x1(%eax),%edx
 804ba96:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ba99:	89 50 0c             	mov    %edx,0xc(%eax)

    while (current_element != NULL)
 804ba9c:	e9 b7 00 00 00       	jmp    804bb58 <_ZL11print_arrayPK5cJSONP11printbuffer+0x133>
    {
        if (!print_value(current_element, output_buffer))
 804baa1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804baa4:	89 44 24 04          	mov    %eax,0x4(%esp)
 804baa8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804baab:	89 04 24             	mov    %eax,(%esp)
 804baae:	e8 13 fb ff ff       	call   804b5c6 <_ZL11print_valuePK5cJSONP11printbuffer>
 804bab3:	85 c0                	test   %eax,%eax
 804bab5:	0f 94 c0             	sete   %al
 804bab8:	84 c0                	test   %al,%al
 804baba:	74 0a                	je     804bac6 <_ZL11print_arrayPK5cJSONP11printbuffer+0xa1>
        {
            return false;
 804babc:	b8 00 00 00 00       	mov    $0x0,%eax
 804bac1:	e9 e8 00 00 00       	jmp    804bbae <_ZL11print_arrayPK5cJSONP11printbuffer+0x189>
        }
        update_offset(output_buffer);
 804bac6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bac9:	89 04 24             	mov    %eax,(%esp)
 804bacc:	e8 c3 e8 ff ff       	call   804a394 <_ZL13update_offsetP11printbuffer>
        if (current_element->next)
 804bad1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bad4:	8b 00                	mov    (%eax),%eax
 804bad6:	85 c0                	test   %eax,%eax
 804bad8:	74 76                	je     804bb50 <_ZL11print_arrayPK5cJSONP11printbuffer+0x12b>
        {
            length = (size_t) (output_buffer->format ? 2 : 1);
 804bada:	8b 45 0c             	mov    0xc(%ebp),%eax
 804badd:	8b 40 14             	mov    0x14(%eax),%eax
 804bae0:	85 c0                	test   %eax,%eax
 804bae2:	74 07                	je     804baeb <_ZL11print_arrayPK5cJSONP11printbuffer+0xc6>
 804bae4:	b8 02 00 00 00       	mov    $0x2,%eax
 804bae9:	eb 05                	jmp    804baf0 <_ZL11print_arrayPK5cJSONP11printbuffer+0xcb>
 804baeb:	b8 01 00 00 00       	mov    $0x1,%eax
 804baf0:	89 45 f0             	mov    %eax,-0x10(%ebp)
            output_pointer = ensure(output_buffer, length + 1);
 804baf3:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804baf6:	83 c0 01             	add    $0x1,%eax
 804baf9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bafd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bb00:	89 04 24             	mov    %eax,(%esp)
 804bb03:	e8 cf e6 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804bb08:	89 45 ec             	mov    %eax,-0x14(%ebp)
            if (output_pointer == NULL)
 804bb0b:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804bb0f:	75 0a                	jne    804bb1b <_ZL11print_arrayPK5cJSONP11printbuffer+0xf6>
            {
                return false;
 804bb11:	b8 00 00 00 00       	mov    $0x0,%eax
 804bb16:	e9 93 00 00 00       	jmp    804bbae <_ZL11print_arrayPK5cJSONP11printbuffer+0x189>
            }
            *output_pointer++ = ',';
 804bb1b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bb1e:	c6 00 2c             	movb   $0x2c,(%eax)
 804bb21:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
            if(output_buffer->format)
 804bb25:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bb28:	8b 40 14             	mov    0x14(%eax),%eax
 804bb2b:	85 c0                	test   %eax,%eax
 804bb2d:	74 0a                	je     804bb39 <_ZL11print_arrayPK5cJSONP11printbuffer+0x114>
            {
                *output_pointer++ = ' ';
 804bb2f:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bb32:	c6 00 20             	movb   $0x20,(%eax)
 804bb35:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
            }
            *output_pointer = '\0';
 804bb39:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bb3c:	c6 00 00             	movb   $0x0,(%eax)
            output_buffer->offset += length;
 804bb3f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bb42:	8b 40 08             	mov    0x8(%eax),%eax
 804bb45:	89 c2                	mov    %eax,%edx
 804bb47:	03 55 f0             	add    -0x10(%ebp),%edx
 804bb4a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bb4d:	89 50 08             	mov    %edx,0x8(%eax)
        }
        current_element = current_element->next;
 804bb50:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bb53:	8b 00                	mov    (%eax),%eax
 804bb55:	89 45 f4             	mov    %eax,-0xc(%ebp)

    *output_pointer = '[';
    output_buffer->offset++;
    output_buffer->depth++;

    while (current_element != NULL)
 804bb58:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804bb5c:	0f 95 c0             	setne  %al
 804bb5f:	84 c0                	test   %al,%al
 804bb61:	0f 85 3a ff ff ff    	jne    804baa1 <_ZL11print_arrayPK5cJSONP11printbuffer+0x7c>
            output_buffer->offset += length;
        }
        current_element = current_element->next;
    }

    output_pointer = ensure(output_buffer, 2);
 804bb67:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
 804bb6e:	00 
 804bb6f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bb72:	89 04 24             	mov    %eax,(%esp)
 804bb75:	e8 5d e6 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804bb7a:	89 45 ec             	mov    %eax,-0x14(%ebp)
    if (output_pointer == NULL)
 804bb7d:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804bb81:	75 07                	jne    804bb8a <_ZL11print_arrayPK5cJSONP11printbuffer+0x165>
    {
        return false;
 804bb83:	b8 00 00 00 00       	mov    $0x0,%eax
 804bb88:	eb 24                	jmp    804bbae <_ZL11print_arrayPK5cJSONP11printbuffer+0x189>
    }
    *output_pointer++ = ']';
 804bb8a:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bb8d:	c6 00 5d             	movb   $0x5d,(%eax)
 804bb90:	83 45 ec 01          	addl   $0x1,-0x14(%ebp)
    *output_pointer = '\0';
 804bb94:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bb97:	c6 00 00             	movb   $0x0,(%eax)
    output_buffer->depth--;
 804bb9a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bb9d:	8b 40 0c             	mov    0xc(%eax),%eax
 804bba0:	8d 50 ff             	lea    -0x1(%eax),%edx
 804bba3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bba6:	89 50 0c             	mov    %edx,0xc(%eax)

    return true;
 804bba9:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804bbae:	c9                   	leave  
 804bbaf:	c3                   	ret    

0804bbb0 <_ZL12parse_objectP5cJSONP12parse_buffer>:

/* Build an object from the text. */
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
{
 804bbb0:	55                   	push   %ebp
 804bbb1:	89 e5                	mov    %esp,%ebp
 804bbb3:	83 ec 28             	sub    $0x28,%esp
    cJSON *head = NULL; /* linked list head */
 804bbb6:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    cJSON *current_item = NULL;
 804bbbd:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)

    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
 804bbc4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bbc7:	8b 40 0c             	mov    0xc(%eax),%eax
 804bbca:	3d e7 03 00 00       	cmp    $0x3e7,%eax
 804bbcf:	76 0a                	jbe    804bbdb <_ZL12parse_objectP5cJSONP12parse_buffer+0x2b>
    {
        return false; /* to deeply nested */
 804bbd1:	b8 00 00 00 00       	mov    $0x0,%eax
 804bbd6:	e9 a5 02 00 00       	jmp    804be80 <_ZL12parse_objectP5cJSONP12parse_buffer+0x2d0>
    }
    input_buffer->depth++;
 804bbdb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bbde:	8b 40 0c             	mov    0xc(%eax),%eax
 804bbe1:	8d 50 01             	lea    0x1(%eax),%edx
 804bbe4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bbe7:	89 50 0c             	mov    %edx,0xc(%eax)

    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
 804bbea:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804bbee:	0f 84 76 02 00 00    	je     804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
 804bbf4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bbf7:	8b 50 08             	mov    0x8(%eax),%edx
 804bbfa:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bbfd:	8b 40 04             	mov    0x4(%eax),%eax
 804bc00:	39 c2                	cmp    %eax,%edx
 804bc02:	0f 83 62 02 00 00    	jae    804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
 804bc08:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc0b:	8b 10                	mov    (%eax),%edx
 804bc0d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc10:	8b 40 08             	mov    0x8(%eax),%eax
 804bc13:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804bc16:	0f b6 00             	movzbl (%eax),%eax
 804bc19:	3c 7b                	cmp    $0x7b,%al
 804bc1b:	0f 85 49 02 00 00    	jne    804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
    {
        goto fail; /* not an object */
    }

    input_buffer->offset++;
 804bc21:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc24:	8b 40 08             	mov    0x8(%eax),%eax
 804bc27:	8d 50 01             	lea    0x1(%eax),%edx
 804bc2a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc2d:	89 50 08             	mov    %edx,0x8(%eax)
    buffer_skip_whitespace(input_buffer);
 804bc30:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc33:	89 04 24             	mov    %eax,(%esp)
 804bc36:	e8 7a f1 ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
 804bc3b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804bc3f:	74 29                	je     804bc6a <_ZL12parse_objectP5cJSONP12parse_buffer+0xba>
 804bc41:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc44:	8b 50 08             	mov    0x8(%eax),%edx
 804bc47:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc4a:	8b 40 04             	mov    0x4(%eax),%eax
 804bc4d:	39 c2                	cmp    %eax,%edx
 804bc4f:	73 19                	jae    804bc6a <_ZL12parse_objectP5cJSONP12parse_buffer+0xba>
 804bc51:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc54:	8b 10                	mov    (%eax),%edx
 804bc56:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc59:	8b 40 08             	mov    0x8(%eax),%eax
 804bc5c:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804bc5f:	0f b6 00             	movzbl (%eax),%eax
 804bc62:	3c 7d                	cmp    $0x7d,%al
 804bc64:	0f 84 c0 01 00 00    	je     804be2a <_ZL12parse_objectP5cJSONP12parse_buffer+0x27a>
    {
        goto success; /* empty object */
    }

    /* check if we skipped to the end of the buffer */
    if (cannot_access_at_index(input_buffer, 0))
 804bc6a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804bc6e:	74 10                	je     804bc80 <_ZL12parse_objectP5cJSONP12parse_buffer+0xd0>
 804bc70:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc73:	8b 50 08             	mov    0x8(%eax),%edx
 804bc76:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc79:	8b 40 04             	mov    0x4(%eax),%eax
 804bc7c:	39 c2                	cmp    %eax,%edx
 804bc7e:	72 14                	jb     804bc94 <_ZL12parse_objectP5cJSONP12parse_buffer+0xe4>
    {
        input_buffer->offset--;
 804bc80:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc83:	8b 40 08             	mov    0x8(%eax),%eax
 804bc86:	8d 50 ff             	lea    -0x1(%eax),%edx
 804bc89:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc8c:	89 50 08             	mov    %edx,0x8(%eax)
        goto fail;
 804bc8f:	e9 d6 01 00 00       	jmp    804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
 804bc94:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bc97:	8b 40 08             	mov    0x8(%eax),%eax
 804bc9a:	8d 50 ff             	lea    -0x1(%eax),%edx
 804bc9d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bca0:	89 50 08             	mov    %edx,0x8(%eax)
    /* loop through the comma separated array elements */
    do
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
 804bca3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bca6:	83 c0 10             	add    $0x10,%eax
 804bca9:	89 04 24             	mov    %eax,(%esp)
 804bcac:	e8 f8 e1 ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804bcb1:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (new_item == NULL)
 804bcb4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804bcb8:	0f 84 a5 01 00 00    	je     804be63 <_ZL12parse_objectP5cJSONP12parse_buffer+0x2b3>
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
 804bcbe:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804bcc2:	75 0e                	jne    804bcd2 <_ZL12parse_objectP5cJSONP12parse_buffer+0x122>
        {
            /* start the linked list */
            current_item = head = new_item;
 804bcc4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bcc7:	89 45 ec             	mov    %eax,-0x14(%ebp)
 804bcca:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bccd:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804bcd0:	eb 17                	jmp    804bce9 <_ZL12parse_objectP5cJSONP12parse_buffer+0x139>
        }
        else
        {
            /* add to the end and advance */
            current_item->next = new_item;
 804bcd2:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bcd5:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804bcd8:	89 10                	mov    %edx,(%eax)
            new_item->prev = current_item;
 804bcda:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bcdd:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804bce0:	89 50 04             	mov    %edx,0x4(%eax)
            current_item = new_item;
 804bce3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804bce6:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }

        /* parse the name of the child */
        input_buffer->offset++;
 804bce9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bcec:	8b 40 08             	mov    0x8(%eax),%eax
 804bcef:	8d 50 01             	lea    0x1(%eax),%edx
 804bcf2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bcf5:	89 50 08             	mov    %edx,0x8(%eax)
        buffer_skip_whitespace(input_buffer);
 804bcf8:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bcfb:	89 04 24             	mov    %eax,(%esp)
 804bcfe:	e8 b2 f0 ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>
        if (!parse_string(current_item, input_buffer))
 804bd03:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd06:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bd0a:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bd0d:	89 04 24             	mov    %eax,(%esp)
 804bd10:	e8 3b eb ff ff       	call   804a850 <_ZL12parse_stringP5cJSONP12parse_buffer>
 804bd15:	85 c0                	test   %eax,%eax
 804bd17:	0f 94 c0             	sete   %al
 804bd1a:	84 c0                	test   %al,%al
 804bd1c:	0f 85 44 01 00 00    	jne    804be66 <_ZL12parse_objectP5cJSONP12parse_buffer+0x2b6>
        {
            goto fail; /* faile to parse name */
        }
        buffer_skip_whitespace(input_buffer);
 804bd22:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd25:	89 04 24             	mov    %eax,(%esp)
 804bd28:	e8 88 f0 ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>

        /* swap valuestring and string, because we parsed the name */
        current_item->string = current_item->valuestring;
 804bd2d:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bd30:	8b 50 10             	mov    0x10(%eax),%edx
 804bd33:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bd36:	89 50 20             	mov    %edx,0x20(%eax)
        current_item->valuestring = NULL;
 804bd39:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bd3c:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)

        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
 804bd43:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804bd47:	0f 84 1d 01 00 00    	je     804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
 804bd4d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd50:	8b 50 08             	mov    0x8(%eax),%edx
 804bd53:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd56:	8b 40 04             	mov    0x4(%eax),%eax
 804bd59:	39 c2                	cmp    %eax,%edx
 804bd5b:	0f 83 09 01 00 00    	jae    804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
 804bd61:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd64:	8b 10                	mov    (%eax),%edx
 804bd66:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd69:	8b 40 08             	mov    0x8(%eax),%eax
 804bd6c:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804bd6f:	0f b6 00             	movzbl (%eax),%eax
 804bd72:	3c 3a                	cmp    $0x3a,%al
 804bd74:	0f 85 f0 00 00 00    	jne    804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
        {
            goto fail; /* invalid object */
        }

        /* parse the value */
        input_buffer->offset++;
 804bd7a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd7d:	8b 40 08             	mov    0x8(%eax),%eax
 804bd80:	8d 50 01             	lea    0x1(%eax),%edx
 804bd83:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd86:	89 50 08             	mov    %edx,0x8(%eax)
        buffer_skip_whitespace(input_buffer);
 804bd89:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd8c:	89 04 24             	mov    %eax,(%esp)
 804bd8f:	e8 21 f0 ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>
        if (!parse_value(current_item, input_buffer))
 804bd94:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bd97:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bd9b:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804bd9e:	89 04 24             	mov    %eax,(%esp)
 804bda1:	e8 8c f5 ff ff       	call   804b332 <_ZL11parse_valueP5cJSONP12parse_buffer>
 804bda6:	85 c0                	test   %eax,%eax
 804bda8:	0f 94 c0             	sete   %al
 804bdab:	84 c0                	test   %al,%al
 804bdad:	0f 85 b6 00 00 00    	jne    804be69 <_ZL12parse_objectP5cJSONP12parse_buffer+0x2b9>
        {
            goto fail; /* failed to parse value */
        }
        buffer_skip_whitespace(input_buffer);
 804bdb3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bdb6:	89 04 24             	mov    %eax,(%esp)
 804bdb9:	e8 f7 ef ff ff       	call   804adb5 <_ZL22buffer_skip_whitespaceP12parse_buffer>
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
    /* loop through the comma separated array elements */
    do
 804bdbe:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804bdc2:	74 2c                	je     804bdf0 <_ZL12parse_objectP5cJSONP12parse_buffer+0x240>
 804bdc4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bdc7:	8b 50 08             	mov    0x8(%eax),%edx
 804bdca:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bdcd:	8b 40 04             	mov    0x4(%eax),%eax
 804bdd0:	39 c2                	cmp    %eax,%edx
 804bdd2:	73 1c                	jae    804bdf0 <_ZL12parse_objectP5cJSONP12parse_buffer+0x240>
 804bdd4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bdd7:	8b 10                	mov    (%eax),%edx
 804bdd9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bddc:	8b 40 08             	mov    0x8(%eax),%eax
 804bddf:	8d 04 02             	lea    (%edx,%eax,1),%eax
        {
            goto fail; /* failed to parse value */
        }
        buffer_skip_whitespace(input_buffer);
    }
    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
 804bde2:	0f b6 00             	movzbl (%eax),%eax
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
    /* loop through the comma separated array elements */
    do
 804bde5:	3c 2c                	cmp    $0x2c,%al
 804bde7:	75 07                	jne    804bdf0 <_ZL12parse_objectP5cJSONP12parse_buffer+0x240>
 804bde9:	b8 01 00 00 00       	mov    $0x1,%eax
 804bdee:	eb 05                	jmp    804bdf5 <_ZL12parse_objectP5cJSONP12parse_buffer+0x245>
 804bdf0:	b8 00 00 00 00       	mov    $0x0,%eax
 804bdf5:	84 c0                	test   %al,%al
 804bdf7:	0f 85 a6 fe ff ff    	jne    804bca3 <_ZL12parse_objectP5cJSONP12parse_buffer+0xf3>
        }
        buffer_skip_whitespace(input_buffer);
    }
    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));

    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
 804bdfd:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804be01:	74 67                	je     804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
 804be03:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be06:	8b 50 08             	mov    0x8(%eax),%edx
 804be09:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be0c:	8b 40 04             	mov    0x4(%eax),%eax
 804be0f:	39 c2                	cmp    %eax,%edx
 804be11:	73 57                	jae    804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
 804be13:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be16:	8b 10                	mov    (%eax),%edx
 804be18:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be1b:	8b 40 08             	mov    0x8(%eax),%eax
 804be1e:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804be21:	0f b6 00             	movzbl (%eax),%eax
 804be24:	3c 7d                	cmp    $0x7d,%al
 804be26:	75 42                	jne    804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
 804be28:	eb 01                	jmp    804be2b <_ZL12parse_objectP5cJSONP12parse_buffer+0x27b>

    input_buffer->offset++;
    buffer_skip_whitespace(input_buffer);
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
    {
        goto success; /* empty object */
 804be2a:	90                   	nop
    {
        goto fail; /* expected end of object */
    }

success:
    input_buffer->depth--;
 804be2b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be2e:	8b 40 0c             	mov    0xc(%eax),%eax
 804be31:	8d 50 ff             	lea    -0x1(%eax),%edx
 804be34:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be37:	89 50 0c             	mov    %edx,0xc(%eax)

    item->type = cJSON_Object;
 804be3a:	8b 45 08             	mov    0x8(%ebp),%eax
 804be3d:	c7 40 0c 40 00 00 00 	movl   $0x40,0xc(%eax)
    item->child = head;
 804be44:	8b 45 08             	mov    0x8(%ebp),%eax
 804be47:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804be4a:	89 50 08             	mov    %edx,0x8(%eax)

    input_buffer->offset++;
 804be4d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be50:	8b 40 08             	mov    0x8(%eax),%eax
 804be53:	8d 50 01             	lea    0x1(%eax),%edx
 804be56:	8b 45 0c             	mov    0xc(%ebp),%eax
 804be59:	89 50 08             	mov    %edx,0x8(%eax)
    return true;
 804be5c:	b8 01 00 00 00       	mov    $0x1,%eax
 804be61:	eb 1d                	jmp    804be80 <_ZL12parse_objectP5cJSONP12parse_buffer+0x2d0>
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
        if (new_item == NULL)
        {
            goto fail; /* allocation failure */
 804be63:	90                   	nop
 804be64:	eb 04                	jmp    804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
        /* parse the name of the child */
        input_buffer->offset++;
        buffer_skip_whitespace(input_buffer);
        if (!parse_string(current_item, input_buffer))
        {
            goto fail; /* faile to parse name */
 804be66:	90                   	nop
 804be67:	eb 01                	jmp    804be6a <_ZL12parse_objectP5cJSONP12parse_buffer+0x2ba>
        /* parse the value */
        input_buffer->offset++;
        buffer_skip_whitespace(input_buffer);
        if (!parse_value(current_item, input_buffer))
        {
            goto fail; /* failed to parse value */
 804be69:	90                   	nop

    input_buffer->offset++;
    return true;

fail:
    if (head != NULL)
 804be6a:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804be6e:	74 0b                	je     804be7b <_ZL12parse_objectP5cJSONP12parse_buffer+0x2cb>
    {
        cJSON_Delete(head);
 804be70:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804be73:	89 04 24             	mov    %eax,(%esp)
 804be76:	e8 6b e0 ff ff       	call   8049ee6 <cJSON_Delete>
    }

    return false;
 804be7b:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804be80:	c9                   	leave  
 804be81:	c3                   	ret    

0804be82 <_ZL12print_objectPK5cJSONP11printbuffer>:

/* Render an object to text. */
static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer)
{
 804be82:	55                   	push   %ebp
 804be83:	89 e5                	mov    %esp,%ebp
 804be85:	83 ec 38             	sub    $0x38,%esp
    unsigned char *output_pointer = NULL;
 804be88:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    size_t length = 0;
 804be8f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    cJSON *current_item = item->child;
 804be96:	8b 45 08             	mov    0x8(%ebp),%eax
 804be99:	8b 40 08             	mov    0x8(%eax),%eax
 804be9c:	89 45 ec             	mov    %eax,-0x14(%ebp)

    if (output_buffer == NULL)
 804be9f:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804bea3:	75 0a                	jne    804beaf <_ZL12print_objectPK5cJSONP11printbuffer+0x2d>
    {
        return false;
 804bea5:	b8 00 00 00 00       	mov    $0x0,%eax
 804beaa:	e9 00 03 00 00       	jmp    804c1af <_ZL12print_objectPK5cJSONP11printbuffer+0x32d>
    }

    /* Compose the output: */
    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
 804beaf:	8b 45 0c             	mov    0xc(%ebp),%eax
 804beb2:	8b 40 14             	mov    0x14(%eax),%eax
 804beb5:	85 c0                	test   %eax,%eax
 804beb7:	74 07                	je     804bec0 <_ZL12print_objectPK5cJSONP11printbuffer+0x3e>
 804beb9:	b8 02 00 00 00       	mov    $0x2,%eax
 804bebe:	eb 05                	jmp    804bec5 <_ZL12print_objectPK5cJSONP11printbuffer+0x43>
 804bec0:	b8 01 00 00 00       	mov    $0x1,%eax
 804bec5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    output_pointer = ensure(output_buffer, length + 1);
 804bec8:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804becb:	83 c0 01             	add    $0x1,%eax
 804bece:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bed2:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bed5:	89 04 24             	mov    %eax,(%esp)
 804bed8:	e8 fa e2 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804bedd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (output_pointer == NULL)
 804bee0:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804bee4:	75 0a                	jne    804bef0 <_ZL12print_objectPK5cJSONP11printbuffer+0x6e>
    {
        return false;
 804bee6:	b8 00 00 00 00       	mov    $0x0,%eax
 804beeb:	e9 bf 02 00 00       	jmp    804c1af <_ZL12print_objectPK5cJSONP11printbuffer+0x32d>
    }

    *output_pointer++ = '{';
 804bef0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bef3:	c6 00 7b             	movb   $0x7b,(%eax)
 804bef6:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    output_buffer->depth++;
 804befa:	8b 45 0c             	mov    0xc(%ebp),%eax
 804befd:	8b 40 0c             	mov    0xc(%eax),%eax
 804bf00:	8d 50 01             	lea    0x1(%eax),%edx
 804bf03:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf06:	89 50 0c             	mov    %edx,0xc(%eax)
    if (output_buffer->format)
 804bf09:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf0c:	8b 40 14             	mov    0x14(%eax),%eax
 804bf0f:	85 c0                	test   %eax,%eax
 804bf11:	74 0a                	je     804bf1d <_ZL12print_objectPK5cJSONP11printbuffer+0x9b>
    {
        *output_pointer++ = '\n';
 804bf13:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bf16:	c6 00 0a             	movb   $0xa,(%eax)
 804bf19:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    }
    output_buffer->offset += length;
 804bf1d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf20:	8b 40 08             	mov    0x8(%eax),%eax
 804bf23:	89 c2                	mov    %eax,%edx
 804bf25:	03 55 e8             	add    -0x18(%ebp),%edx
 804bf28:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf2b:	89 50 08             	mov    %edx,0x8(%eax)

    while (current_item)
 804bf2e:	e9 dc 01 00 00       	jmp    804c10f <_ZL12print_objectPK5cJSONP11printbuffer+0x28d>
    {
        if (output_buffer->format)
 804bf33:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf36:	8b 40 14             	mov    0x14(%eax),%eax
 804bf39:	85 c0                	test   %eax,%eax
 804bf3b:	74 63                	je     804bfa0 <_ZL12print_objectPK5cJSONP11printbuffer+0x11e>
        {
            size_t i;
            output_pointer = ensure(output_buffer, output_buffer->depth);
 804bf3d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf40:	8b 40 0c             	mov    0xc(%eax),%eax
 804bf43:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bf47:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf4a:	89 04 24             	mov    %eax,(%esp)
 804bf4d:	e8 85 e2 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804bf52:	89 45 e4             	mov    %eax,-0x1c(%ebp)
            if (output_pointer == NULL)
 804bf55:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804bf59:	75 0a                	jne    804bf65 <_ZL12print_objectPK5cJSONP11printbuffer+0xe3>
            {
                return false;
 804bf5b:	b8 00 00 00 00       	mov    $0x0,%eax
 804bf60:	e9 4a 02 00 00       	jmp    804c1af <_ZL12print_objectPK5cJSONP11printbuffer+0x32d>
            }
            for (i = 0; i < output_buffer->depth; i++)
 804bf65:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
 804bf6c:	eb 0e                	jmp    804bf7c <_ZL12print_objectPK5cJSONP11printbuffer+0xfa>
            {
                *output_pointer++ = '\t';
 804bf6e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804bf71:	c6 00 09             	movb   $0x9,(%eax)
 804bf74:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
            output_pointer = ensure(output_buffer, output_buffer->depth);
            if (output_pointer == NULL)
            {
                return false;
            }
            for (i = 0; i < output_buffer->depth; i++)
 804bf78:	83 45 f0 01          	addl   $0x1,-0x10(%ebp)
 804bf7c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf7f:	8b 40 0c             	mov    0xc(%eax),%eax
 804bf82:	3b 45 f0             	cmp    -0x10(%ebp),%eax
 804bf85:	0f 97 c0             	seta   %al
 804bf88:	84 c0                	test   %al,%al
 804bf8a:	75 e2                	jne    804bf6e <_ZL12print_objectPK5cJSONP11printbuffer+0xec>
            {
                *output_pointer++ = '\t';
            }
            output_buffer->offset += output_buffer->depth;
 804bf8c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf8f:	8b 50 08             	mov    0x8(%eax),%edx
 804bf92:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf95:	8b 40 0c             	mov    0xc(%eax),%eax
 804bf98:	01 c2                	add    %eax,%edx
 804bf9a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bf9d:	89 50 08             	mov    %edx,0x8(%eax)
        }

        /* print key */
        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
 804bfa0:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804bfa3:	8b 40 20             	mov    0x20(%eax),%eax
 804bfa6:	8b 55 0c             	mov    0xc(%ebp),%edx
 804bfa9:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bfad:	89 04 24             	mov    %eax,(%esp)
 804bfb0:	e8 62 eb ff ff       	call   804ab17 <_ZL16print_string_ptrPKhP11printbuffer>
 804bfb5:	85 c0                	test   %eax,%eax
 804bfb7:	0f 94 c0             	sete   %al
 804bfba:	84 c0                	test   %al,%al
 804bfbc:	74 0a                	je     804bfc8 <_ZL12print_objectPK5cJSONP11printbuffer+0x146>
        {
            return false;
 804bfbe:	b8 00 00 00 00       	mov    $0x0,%eax
 804bfc3:	e9 e7 01 00 00       	jmp    804c1af <_ZL12print_objectPK5cJSONP11printbuffer+0x32d>
        }
        update_offset(output_buffer);
 804bfc8:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bfcb:	89 04 24             	mov    %eax,(%esp)
 804bfce:	e8 c1 e3 ff ff       	call   804a394 <_ZL13update_offsetP11printbuffer>

        length = (size_t) (output_buffer->format ? 2 : 1);
 804bfd3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bfd6:	8b 40 14             	mov    0x14(%eax),%eax
 804bfd9:	85 c0                	test   %eax,%eax
 804bfdb:	74 07                	je     804bfe4 <_ZL12print_objectPK5cJSONP11printbuffer+0x162>
 804bfdd:	b8 02 00 00 00       	mov    $0x2,%eax
 804bfe2:	eb 05                	jmp    804bfe9 <_ZL12print_objectPK5cJSONP11printbuffer+0x167>
 804bfe4:	b8 01 00 00 00       	mov    $0x1,%eax
 804bfe9:	89 45 e8             	mov    %eax,-0x18(%ebp)
        output_pointer = ensure(output_buffer, length);
 804bfec:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804bfef:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bff3:	8b 45 0c             	mov    0xc(%ebp),%eax
 804bff6:	89 04 24             	mov    %eax,(%esp)
 804bff9:	e8 d9 e1 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804bffe:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (output_pointer == NULL)
 804c001:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804c005:	75 0a                	jne    804c011 <_ZL12print_objectPK5cJSONP11printbuffer+0x18f>
        {
            return false;
 804c007:	b8 00 00 00 00       	mov    $0x0,%eax
 804c00c:	e9 9e 01 00 00       	jmp    804c1af <_ZL12print_objectPK5cJSONP11printbuffer+0x32d>
        }
        *output_pointer++ = ':';
 804c011:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c014:	c6 00 3a             	movb   $0x3a,(%eax)
 804c017:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        if (output_buffer->format)
 804c01b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c01e:	8b 40 14             	mov    0x14(%eax),%eax
 804c021:	85 c0                	test   %eax,%eax
 804c023:	74 0a                	je     804c02f <_ZL12print_objectPK5cJSONP11printbuffer+0x1ad>
        {
            *output_pointer++ = '\t';
 804c025:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c028:	c6 00 09             	movb   $0x9,(%eax)
 804c02b:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        }
        output_buffer->offset += length;
 804c02f:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c032:	8b 40 08             	mov    0x8(%eax),%eax
 804c035:	89 c2                	mov    %eax,%edx
 804c037:	03 55 e8             	add    -0x18(%ebp),%edx
 804c03a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c03d:	89 50 08             	mov    %edx,0x8(%eax)

        /* print value */
        if (!print_value(current_item, output_buffer))
 804c040:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c043:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c047:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c04a:	89 04 24             	mov    %eax,(%esp)
 804c04d:	e8 74 f5 ff ff       	call   804b5c6 <_ZL11print_valuePK5cJSONP11printbuffer>
 804c052:	85 c0                	test   %eax,%eax
 804c054:	0f 94 c0             	sete   %al
 804c057:	84 c0                	test   %al,%al
 804c059:	74 0a                	je     804c065 <_ZL12print_objectPK5cJSONP11printbuffer+0x1e3>
        {
            return false;
 804c05b:	b8 00 00 00 00       	mov    $0x0,%eax
 804c060:	e9 4a 01 00 00       	jmp    804c1af <_ZL12print_objectPK5cJSONP11printbuffer+0x32d>
        }
        update_offset(output_buffer);
 804c065:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c068:	89 04 24             	mov    %eax,(%esp)
 804c06b:	e8 24 e3 ff ff       	call   804a394 <_ZL13update_offsetP11printbuffer>

        /* print comma if not last */
        length = (size_t) ((output_buffer->format ? 1 : 0) + (current_item->next ? 1 : 0));
 804c070:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c073:	8b 40 14             	mov    0x14(%eax),%eax
 804c076:	85 c0                	test   %eax,%eax
 804c078:	74 07                	je     804c081 <_ZL12print_objectPK5cJSONP11printbuffer+0x1ff>
 804c07a:	ba 01 00 00 00       	mov    $0x1,%edx
 804c07f:	eb 05                	jmp    804c086 <_ZL12print_objectPK5cJSONP11printbuffer+0x204>
 804c081:	ba 00 00 00 00       	mov    $0x0,%edx
 804c086:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c089:	8b 00                	mov    (%eax),%eax
 804c08b:	85 c0                	test   %eax,%eax
 804c08d:	74 07                	je     804c096 <_ZL12print_objectPK5cJSONP11printbuffer+0x214>
 804c08f:	b8 01 00 00 00       	mov    $0x1,%eax
 804c094:	eb 05                	jmp    804c09b <_ZL12print_objectPK5cJSONP11printbuffer+0x219>
 804c096:	b8 00 00 00 00       	mov    $0x0,%eax
 804c09b:	8d 04 02             	lea    (%edx,%eax,1),%eax
 804c09e:	89 45 e8             	mov    %eax,-0x18(%ebp)
        output_pointer = ensure(output_buffer, length + 1);
 804c0a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804c0a4:	83 c0 01             	add    $0x1,%eax
 804c0a7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c0ab:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c0ae:	89 04 24             	mov    %eax,(%esp)
 804c0b1:	e8 21 e1 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804c0b6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
        if (output_pointer == NULL)
 804c0b9:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804c0bd:	75 0a                	jne    804c0c9 <_ZL12print_objectPK5cJSONP11printbuffer+0x247>
        {
            return false;
 804c0bf:	b8 00 00 00 00       	mov    $0x0,%eax
 804c0c4:	e9 e6 00 00 00       	jmp    804c1af <_ZL12print_objectPK5cJSONP11printbuffer+0x32d>
        }
        if (current_item->next)
 804c0c9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c0cc:	8b 00                	mov    (%eax),%eax
 804c0ce:	85 c0                	test   %eax,%eax
 804c0d0:	74 0a                	je     804c0dc <_ZL12print_objectPK5cJSONP11printbuffer+0x25a>
        {
            *output_pointer++ = ',';
 804c0d2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c0d5:	c6 00 2c             	movb   $0x2c,(%eax)
 804c0d8:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        }

        if (output_buffer->format)
 804c0dc:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c0df:	8b 40 14             	mov    0x14(%eax),%eax
 804c0e2:	85 c0                	test   %eax,%eax
 804c0e4:	74 0a                	je     804c0f0 <_ZL12print_objectPK5cJSONP11printbuffer+0x26e>
        {
            *output_pointer++ = '\n';
 804c0e6:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c0e9:	c6 00 0a             	movb   $0xa,(%eax)
 804c0ec:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        }
        *output_pointer = '\0';
 804c0f0:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c0f3:	c6 00 00             	movb   $0x0,(%eax)
        output_buffer->offset += length;
 804c0f6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c0f9:	8b 40 08             	mov    0x8(%eax),%eax
 804c0fc:	89 c2                	mov    %eax,%edx
 804c0fe:	03 55 e8             	add    -0x18(%ebp),%edx
 804c101:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c104:	89 50 08             	mov    %edx,0x8(%eax)

        current_item = current_item->next;
 804c107:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804c10a:	8b 00                	mov    (%eax),%eax
 804c10c:	89 45 ec             	mov    %eax,-0x14(%ebp)
    {
        *output_pointer++ = '\n';
    }
    output_buffer->offset += length;

    while (current_item)
 804c10f:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804c113:	0f 95 c0             	setne  %al
 804c116:	84 c0                	test   %al,%al
 804c118:	0f 85 15 fe ff ff    	jne    804bf33 <_ZL12print_objectPK5cJSONP11printbuffer+0xb1>
        output_buffer->offset += length;

        current_item = current_item->next;
    }

    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
 804c11e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c121:	8b 40 14             	mov    0x14(%eax),%eax
 804c124:	85 c0                	test   %eax,%eax
 804c126:	74 0b                	je     804c133 <_ZL12print_objectPK5cJSONP11printbuffer+0x2b1>
 804c128:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c12b:	8b 40 0c             	mov    0xc(%eax),%eax
 804c12e:	83 c0 01             	add    $0x1,%eax
 804c131:	eb 05                	jmp    804c138 <_ZL12print_objectPK5cJSONP11printbuffer+0x2b6>
 804c133:	b8 02 00 00 00       	mov    $0x2,%eax
 804c138:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c13c:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c13f:	89 04 24             	mov    %eax,(%esp)
 804c142:	e8 90 e0 ff ff       	call   804a1d7 <_ZL6ensureP11printbufferj>
 804c147:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (output_pointer == NULL)
 804c14a:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
 804c14e:	75 07                	jne    804c157 <_ZL12print_objectPK5cJSONP11printbuffer+0x2d5>
    {
        return false;
 804c150:	b8 00 00 00 00       	mov    $0x0,%eax
 804c155:	eb 58                	jmp    804c1af <_ZL12print_objectPK5cJSONP11printbuffer+0x32d>
    }
    if (output_buffer->format)
 804c157:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c15a:	8b 40 14             	mov    0x14(%eax),%eax
 804c15d:	85 c0                	test   %eax,%eax
 804c15f:	74 2a                	je     804c18b <_ZL12print_objectPK5cJSONP11printbuffer+0x309>
    {
        size_t i;
        for (i = 0; i < (output_buffer->depth - 1); i++)
 804c161:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
 804c168:	eb 0e                	jmp    804c178 <_ZL12print_objectPK5cJSONP11printbuffer+0x2f6>
        {
            *output_pointer++ = '\t';
 804c16a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c16d:	c6 00 09             	movb   $0x9,(%eax)
 804c170:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
        return false;
    }
    if (output_buffer->format)
    {
        size_t i;
        for (i = 0; i < (output_buffer->depth - 1); i++)
 804c174:	83 45 f4 01          	addl   $0x1,-0xc(%ebp)
 804c178:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c17b:	8b 40 0c             	mov    0xc(%eax),%eax
 804c17e:	83 e8 01             	sub    $0x1,%eax
 804c181:	3b 45 f4             	cmp    -0xc(%ebp),%eax
 804c184:	0f 97 c0             	seta   %al
 804c187:	84 c0                	test   %al,%al
 804c189:	75 df                	jne    804c16a <_ZL12print_objectPK5cJSONP11printbuffer+0x2e8>
        {
            *output_pointer++ = '\t';
        }
    }
    *output_pointer++ = '}';
 804c18b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c18e:	c6 00 7d             	movb   $0x7d,(%eax)
 804c191:	83 45 e4 01          	addl   $0x1,-0x1c(%ebp)
    *output_pointer = '\0';
 804c195:	8b 45 e4             	mov    -0x1c(%ebp),%eax
 804c198:	c6 00 00             	movb   $0x0,(%eax)
    output_buffer->depth--;
 804c19b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c19e:	8b 40 0c             	mov    0xc(%eax),%eax
 804c1a1:	8d 50 ff             	lea    -0x1(%eax),%edx
 804c1a4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c1a7:	89 50 0c             	mov    %edx,0xc(%eax)

    return true;
 804c1aa:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804c1af:	c9                   	leave  
 804c1b0:	c3                   	ret    

0804c1b1 <cJSON_GetArraySize>:

/* Get Array size/item / object item. */
CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
{
 804c1b1:	55                   	push   %ebp
 804c1b2:	89 e5                	mov    %esp,%ebp
 804c1b4:	83 ec 10             	sub    $0x10,%esp
    cJSON *child = NULL;
 804c1b7:	c7 45 f8 00 00 00 00 	movl   $0x0,-0x8(%ebp)
    size_t size = 0;
 804c1be:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if (array == NULL)
 804c1c5:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c1c9:	75 07                	jne    804c1d2 <cJSON_GetArraySize+0x21>
    {
        return 0;
 804c1cb:	b8 00 00 00 00       	mov    $0x0,%eax
 804c1d0:	eb 25                	jmp    804c1f7 <cJSON_GetArraySize+0x46>
    }

    child = array->child;
 804c1d2:	8b 45 08             	mov    0x8(%ebp),%eax
 804c1d5:	8b 40 08             	mov    0x8(%eax),%eax
 804c1d8:	89 45 f8             	mov    %eax,-0x8(%ebp)

    while(child != NULL)
 804c1db:	eb 0c                	jmp    804c1e9 <cJSON_GetArraySize+0x38>
    {
        size++;
 804c1dd:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
        child = child->next;
 804c1e1:	8b 45 f8             	mov    -0x8(%ebp),%eax
 804c1e4:	8b 00                	mov    (%eax),%eax
 804c1e6:	89 45 f8             	mov    %eax,-0x8(%ebp)
        return 0;
    }

    child = array->child;

    while(child != NULL)
 804c1e9:	83 7d f8 00          	cmpl   $0x0,-0x8(%ebp)
 804c1ed:	0f 95 c0             	setne  %al
 804c1f0:	84 c0                	test   %al,%al
 804c1f2:	75 e9                	jne    804c1dd <cJSON_GetArraySize+0x2c>
        child = child->next;
    }

    /* FIXME: Can overflow here. Cannot be fixed without breaking the API */

    return (int)size;
 804c1f4:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804c1f7:	c9                   	leave  
 804c1f8:	c3                   	ret    

0804c1f9 <_ZL14get_array_itemPK5cJSONj>:

static cJSON* get_array_item(const cJSON *array, size_t index)
{
 804c1f9:	55                   	push   %ebp
 804c1fa:	89 e5                	mov    %esp,%ebp
 804c1fc:	83 ec 10             	sub    $0x10,%esp
    cJSON *current_child = NULL;
 804c1ff:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if (array == NULL)
 804c206:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c20a:	75 07                	jne    804c213 <_ZL14get_array_itemPK5cJSONj+0x1a>
    {
        return NULL;
 804c20c:	b8 00 00 00 00       	mov    $0x0,%eax
 804c211:	eb 36                	jmp    804c249 <_ZL14get_array_itemPK5cJSONj+0x50>
    }

    current_child = array->child;
 804c213:	8b 45 08             	mov    0x8(%ebp),%eax
 804c216:	8b 40 08             	mov    0x8(%eax),%eax
 804c219:	89 45 fc             	mov    %eax,-0x4(%ebp)
    while ((current_child != NULL) && (index > 0))
 804c21c:	eb 0c                	jmp    804c22a <_ZL14get_array_itemPK5cJSONj+0x31>
    {
        index--;
 804c21e:	83 6d 0c 01          	subl   $0x1,0xc(%ebp)
        current_child = current_child->next;
 804c222:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804c225:	8b 00                	mov    (%eax),%eax
 804c227:	89 45 fc             	mov    %eax,-0x4(%ebp)
    {
        return NULL;
    }

    current_child = array->child;
    while ((current_child != NULL) && (index > 0))
 804c22a:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
 804c22e:	74 0d                	je     804c23d <_ZL14get_array_itemPK5cJSONj+0x44>
 804c230:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c234:	74 07                	je     804c23d <_ZL14get_array_itemPK5cJSONj+0x44>
 804c236:	b8 01 00 00 00       	mov    $0x1,%eax
 804c23b:	eb 05                	jmp    804c242 <_ZL14get_array_itemPK5cJSONj+0x49>
 804c23d:	b8 00 00 00 00       	mov    $0x0,%eax
 804c242:	84 c0                	test   %al,%al
 804c244:	75 d8                	jne    804c21e <_ZL14get_array_itemPK5cJSONj+0x25>
    {
        index--;
        current_child = current_child->next;
    }

    return current_child;
 804c246:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 804c249:	c9                   	leave  
 804c24a:	c3                   	ret    

0804c24b <cJSON_GetArrayItem>:

CJSON_PUBLIC(cJSON *) cJSON_GetArrayItem(const cJSON *array, int index)
{
 804c24b:	55                   	push   %ebp
 804c24c:	89 e5                	mov    %esp,%ebp
 804c24e:	83 ec 08             	sub    $0x8,%esp
    if (index < 0)
 804c251:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c255:	79 07                	jns    804c25e <cJSON_GetArrayItem+0x13>
    {
        return NULL;
 804c257:	b8 00 00 00 00       	mov    $0x0,%eax
 804c25c:	eb 12                	jmp    804c270 <cJSON_GetArrayItem+0x25>
    }

    return get_array_item(array, (size_t)index);
 804c25e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c261:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c265:	8b 45 08             	mov    0x8(%ebp),%eax
 804c268:	89 04 24             	mov    %eax,(%esp)
 804c26b:	e8 89 ff ff ff       	call   804c1f9 <_ZL14get_array_itemPK5cJSONj>
}
 804c270:	c9                   	leave  
 804c271:	c3                   	ret    

0804c272 <_ZL15get_object_itemPK5cJSONPKci>:

static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
 804c272:	55                   	push   %ebp
 804c273:	89 e5                	mov    %esp,%ebp
 804c275:	83 ec 28             	sub    $0x28,%esp
    cJSON *current_element = NULL;
 804c278:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if ((object == NULL) || (name == NULL))
 804c27f:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c283:	74 06                	je     804c28b <_ZL15get_object_itemPK5cJSONPKci+0x19>
 804c285:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c289:	75 0a                	jne    804c295 <_ZL15get_object_itemPK5cJSONPKci+0x23>
    {
        return NULL;
 804c28b:	b8 00 00 00 00       	mov    $0x0,%eax
 804c290:	e9 86 00 00 00       	jmp    804c31b <_ZL15get_object_itemPK5cJSONPKci+0xa9>
    }

    current_element = object->child;
 804c295:	8b 45 08             	mov    0x8(%ebp),%eax
 804c298:	8b 40 08             	mov    0x8(%eax),%eax
 804c29b:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (case_sensitive)
 804c29e:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804c2a2:	74 43                	je     804c2e7 <_ZL15get_object_itemPK5cJSONPKci+0x75>
    {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
 804c2a4:	eb 08                	jmp    804c2ae <_ZL15get_object_itemPK5cJSONPKci+0x3c>
        {
            current_element = current_element->next;
 804c2a6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c2a9:	8b 00                	mov    (%eax),%eax
 804c2ab:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    current_element = object->child;
    if (case_sensitive)
    {
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
 804c2ae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c2b2:	74 20                	je     804c2d4 <_ZL15get_object_itemPK5cJSONPKci+0x62>
 804c2b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c2b7:	8b 40 20             	mov    0x20(%eax),%eax
 804c2ba:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c2be:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c2c1:	89 04 24             	mov    %eax,(%esp)
 804c2c4:	e8 3b d4 ff ff       	call   8049704 <strcmp@plt>
 804c2c9:	85 c0                	test   %eax,%eax
 804c2cb:	74 07                	je     804c2d4 <_ZL15get_object_itemPK5cJSONPKci+0x62>
 804c2cd:	b8 01 00 00 00       	mov    $0x1,%eax
 804c2d2:	eb 05                	jmp    804c2d9 <_ZL15get_object_itemPK5cJSONPKci+0x67>
 804c2d4:	b8 00 00 00 00       	mov    $0x0,%eax
 804c2d9:	84 c0                	test   %al,%al
 804c2db:	75 c9                	jne    804c2a6 <_ZL15get_object_itemPK5cJSONPKci+0x34>
 804c2dd:	eb 39                	jmp    804c318 <_ZL15get_object_itemPK5cJSONPKci+0xa6>
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
 804c2df:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c2e2:	8b 00                	mov    (%eax),%eax
 804c2e4:	89 45 f4             	mov    %eax,-0xc(%ebp)
            current_element = current_element->next;
        }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
 804c2e7:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c2eb:	74 22                	je     804c30f <_ZL15get_object_itemPK5cJSONPKci+0x9d>
 804c2ed:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c2f0:	8b 40 20             	mov    0x20(%eax),%eax
 804c2f3:	89 c2                	mov    %eax,%edx
 804c2f5:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c2f8:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c2fc:	89 04 24             	mov    %eax,(%esp)
 804c2ff:	e8 06 da ff ff       	call   8049d0a <_ZL23case_insensitive_strcmpPKhS0_>
 804c304:	85 c0                	test   %eax,%eax
 804c306:	74 07                	je     804c30f <_ZL15get_object_itemPK5cJSONPKci+0x9d>
 804c308:	b8 01 00 00 00       	mov    $0x1,%eax
 804c30d:	eb 05                	jmp    804c314 <_ZL15get_object_itemPK5cJSONPKci+0xa2>
 804c30f:	b8 00 00 00 00       	mov    $0x0,%eax
 804c314:	84 c0                	test   %al,%al
 804c316:	75 c7                	jne    804c2df <_ZL15get_object_itemPK5cJSONPKci+0x6d>
        {
            current_element = current_element->next;
        }
    }

    return current_element;
 804c318:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804c31b:	c9                   	leave  
 804c31c:	c3                   	ret    

0804c31d <cJSON_GetObjectItem>:

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
{
 804c31d:	55                   	push   %ebp
 804c31e:	89 e5                	mov    %esp,%ebp
 804c320:	83 ec 18             	sub    $0x18,%esp
    return get_object_item(object, string, false);
 804c323:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804c32a:	00 
 804c32b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c32e:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c332:	8b 45 08             	mov    0x8(%ebp),%eax
 804c335:	89 04 24             	mov    %eax,(%esp)
 804c338:	e8 35 ff ff ff       	call   804c272 <_ZL15get_object_itemPK5cJSONPKci>
}
 804c33d:	c9                   	leave  
 804c33e:	c3                   	ret    

0804c33f <cJSON_GetObjectItemCaseSensitive>:

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
{
 804c33f:	55                   	push   %ebp
 804c340:	89 e5                	mov    %esp,%ebp
 804c342:	83 ec 18             	sub    $0x18,%esp
    return get_object_item(object, string, true);
 804c345:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
 804c34c:	00 
 804c34d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c350:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c354:	8b 45 08             	mov    0x8(%ebp),%eax
 804c357:	89 04 24             	mov    %eax,(%esp)
 804c35a:	e8 13 ff ff ff       	call   804c272 <_ZL15get_object_itemPK5cJSONPKci>
}
 804c35f:	c9                   	leave  
 804c360:	c3                   	ret    

0804c361 <cJSON_HasObjectItem>:

CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
{
 804c361:	55                   	push   %ebp
 804c362:	89 e5                	mov    %esp,%ebp
 804c364:	83 ec 18             	sub    $0x18,%esp
    return cJSON_GetObjectItem(object, string) ? 1 : 0;
 804c367:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c36a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c36e:	8b 45 08             	mov    0x8(%ebp),%eax
 804c371:	89 04 24             	mov    %eax,(%esp)
 804c374:	e8 a4 ff ff ff       	call   804c31d <cJSON_GetObjectItem>
 804c379:	85 c0                	test   %eax,%eax
 804c37b:	74 07                	je     804c384 <cJSON_HasObjectItem+0x23>
 804c37d:	b8 01 00 00 00       	mov    $0x1,%eax
 804c382:	eb 05                	jmp    804c389 <cJSON_HasObjectItem+0x28>
 804c384:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c389:	c9                   	leave  
 804c38a:	c3                   	ret    

0804c38b <_ZL13suffix_objectP5cJSONS0_>:

/* Utility for array list handling. */
static void suffix_object(cJSON *prev, cJSON *item)
{
 804c38b:	55                   	push   %ebp
 804c38c:	89 e5                	mov    %esp,%ebp
    prev->next = item;
 804c38e:	8b 45 08             	mov    0x8(%ebp),%eax
 804c391:	8b 55 0c             	mov    0xc(%ebp),%edx
 804c394:	89 10                	mov    %edx,(%eax)
    item->prev = prev;
 804c396:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c399:	8b 55 08             	mov    0x8(%ebp),%edx
 804c39c:	89 50 04             	mov    %edx,0x4(%eax)
}
 804c39f:	5d                   	pop    %ebp
 804c3a0:	c3                   	ret    

0804c3a1 <_ZL16create_referencePK5cJSONPK14internal_hooks>:

/* Utility for handling references. */
static cJSON *create_reference(const cJSON *item, const internal_hooks * const hooks)
{
 804c3a1:	55                   	push   %ebp
 804c3a2:	89 e5                	mov    %esp,%ebp
 804c3a4:	83 ec 28             	sub    $0x28,%esp
    cJSON *reference = NULL;
 804c3a7:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
    if (item == NULL)
 804c3ae:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c3b2:	75 07                	jne    804c3bb <_ZL16create_referencePK5cJSONPK14internal_hooks+0x1a>
    {
        return NULL;
 804c3b4:	b8 00 00 00 00       	mov    $0x0,%eax
 804c3b9:	eb 68                	jmp    804c423 <_ZL16create_referencePK5cJSONPK14internal_hooks+0x82>
    }

    reference = cJSON_New_Item(hooks);
 804c3bb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c3be:	89 04 24             	mov    %eax,(%esp)
 804c3c1:	e8 e3 da ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804c3c6:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (reference == NULL)
 804c3c9:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804c3cd:	75 07                	jne    804c3d6 <_ZL16create_referencePK5cJSONPK14internal_hooks+0x35>
    {
        return NULL;
 804c3cf:	b8 00 00 00 00       	mov    $0x0,%eax
 804c3d4:	eb 4d                	jmp    804c423 <_ZL16create_referencePK5cJSONPK14internal_hooks+0x82>
    }

    memcpy(reference, item, sizeof(cJSON));
 804c3d6:	c7 44 24 08 24 00 00 	movl   $0x24,0x8(%esp)
 804c3dd:	00 
 804c3de:	8b 45 08             	mov    0x8(%ebp),%eax
 804c3e1:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c3e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c3e8:	89 04 24             	mov    %eax,(%esp)
 804c3eb:	e8 74 d2 ff ff       	call   8049664 <memcpy@plt>
    reference->string = NULL;
 804c3f0:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c3f3:	c7 40 20 00 00 00 00 	movl   $0x0,0x20(%eax)
    reference->type |= cJSON_IsReference;
 804c3fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c3fd:	8b 40 0c             	mov    0xc(%eax),%eax
 804c400:	89 c2                	mov    %eax,%edx
 804c402:	80 ce 01             	or     $0x1,%dh
 804c405:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c408:	89 50 0c             	mov    %edx,0xc(%eax)
    reference->next = reference->prev = NULL;
 804c40b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c40e:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
 804c415:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c418:	8b 50 04             	mov    0x4(%eax),%edx
 804c41b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c41e:	89 10                	mov    %edx,(%eax)
    return reference;
 804c420:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804c423:	c9                   	leave  
 804c424:	c3                   	ret    

0804c425 <_ZL17add_item_to_arrayP5cJSONS0_>:

static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
{
 804c425:	55                   	push   %ebp
 804c426:	89 e5                	mov    %esp,%ebp
 804c428:	83 ec 18             	sub    $0x18,%esp
    cJSON *child = NULL;
 804c42b:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if ((item == NULL) || (array == NULL))
 804c432:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c436:	74 06                	je     804c43e <_ZL17add_item_to_arrayP5cJSONS0_+0x19>
 804c438:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c43c:	75 07                	jne    804c445 <_ZL17add_item_to_arrayP5cJSONS0_+0x20>
    {
        return false;
 804c43e:	b8 00 00 00 00       	mov    $0x0,%eax
 804c443:	eb 47                	jmp    804c48c <_ZL17add_item_to_arrayP5cJSONS0_+0x67>
    }

    child = array->child;
 804c445:	8b 45 08             	mov    0x8(%ebp),%eax
 804c448:	8b 40 08             	mov    0x8(%eax),%eax
 804c44b:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if (child == NULL)
 804c44e:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
 804c452:	75 13                	jne    804c467 <_ZL17add_item_to_arrayP5cJSONS0_+0x42>
    {
        /* list is empty, start new one */
        array->child = item;
 804c454:	8b 45 08             	mov    0x8(%ebp),%eax
 804c457:	8b 55 0c             	mov    0xc(%ebp),%edx
 804c45a:	89 50 08             	mov    %edx,0x8(%eax)
 804c45d:	eb 28                	jmp    804c487 <_ZL17add_item_to_arrayP5cJSONS0_+0x62>
    else
    {
        /* append to the end */
        while (child->next)
        {
            child = child->next;
 804c45f:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804c462:	8b 00                	mov    (%eax),%eax
 804c464:	89 45 fc             	mov    %eax,-0x4(%ebp)
        array->child = item;
    }
    else
    {
        /* append to the end */
        while (child->next)
 804c467:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804c46a:	8b 00                	mov    (%eax),%eax
 804c46c:	85 c0                	test   %eax,%eax
 804c46e:	0f 95 c0             	setne  %al
 804c471:	84 c0                	test   %al,%al
 804c473:	75 ea                	jne    804c45f <_ZL17add_item_to_arrayP5cJSONS0_+0x3a>
        {
            child = child->next;
        }
        suffix_object(child, item);
 804c475:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c478:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c47c:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804c47f:	89 04 24             	mov    %eax,(%esp)
 804c482:	e8 04 ff ff ff       	call   804c38b <_ZL13suffix_objectP5cJSONS0_>
    }

    return true;
 804c487:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804c48c:	c9                   	leave  
 804c48d:	c3                   	ret    

0804c48e <cJSON_AddItemToArray>:

/* Add item to array/object. */
CJSON_PUBLIC(void) cJSON_AddItemToArray(cJSON *array, cJSON *item)
{
 804c48e:	55                   	push   %ebp
 804c48f:	89 e5                	mov    %esp,%ebp
 804c491:	83 ec 08             	sub    $0x8,%esp
    add_item_to_array(array, item);
 804c494:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c497:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c49b:	8b 45 08             	mov    0x8(%ebp),%eax
 804c49e:	89 04 24             	mov    %eax,(%esp)
 804c4a1:	e8 7f ff ff ff       	call   804c425 <_ZL17add_item_to_arrayP5cJSONS0_>
}
 804c4a6:	c9                   	leave  
 804c4a7:	c3                   	ret    

0804c4a8 <_ZL15cast_away_constPKv>:
#ifdef __GNUC__
#pragma GCC diagnostic ignored "-Wcast-qual"
#endif
/* helper function to cast away const */
static void* cast_away_const(const void* string)
{
 804c4a8:	55                   	push   %ebp
 804c4a9:	89 e5                	mov    %esp,%ebp
    return (void*)string;
 804c4ab:	8b 45 08             	mov    0x8(%ebp),%eax
}
 804c4ae:	5d                   	pop    %ebp
 804c4af:	c3                   	ret    

0804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>:
    #pragma GCC diagnostic pop
#endif


static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
{
 804c4b0:	55                   	push   %ebp
 804c4b1:	89 e5                	mov    %esp,%ebp
 804c4b3:	83 ec 28             	sub    $0x28,%esp
    char *new_key = NULL;
 804c4b6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    int new_type = cJSON_Invalid;
 804c4bd:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if ((object == NULL) || (string == NULL) || (item == NULL))
 804c4c4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c4c8:	74 0c                	je     804c4d6 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0x26>
 804c4ca:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c4ce:	74 06                	je     804c4d6 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0x26>
 804c4d0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804c4d4:	75 0a                	jne    804c4e0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0x30>
    {
        return false;
 804c4d6:	b8 00 00 00 00       	mov    $0x0,%eax
 804c4db:	e9 9e 00 00 00       	jmp    804c57e <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0xce>
    }

    if (constant_key)
 804c4e0:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
 804c4e4:	74 1c                	je     804c502 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0x52>
    {
        new_key = (char*)cast_away_const(string);
 804c4e6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c4e9:	89 04 24             	mov    %eax,(%esp)
 804c4ec:	e8 b7 ff ff ff       	call   804c4a8 <_ZL15cast_away_constPKv>
 804c4f1:	89 45 f0             	mov    %eax,-0x10(%ebp)
        new_type = item->type | cJSON_StringIsConst;
 804c4f4:	8b 45 10             	mov    0x10(%ebp),%eax
 804c4f7:	8b 40 0c             	mov    0xc(%eax),%eax
 804c4fa:	80 cc 02             	or     $0x2,%ah
 804c4fd:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804c500:	eb 2e                	jmp    804c530 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0x80>
    }
    else
    {
        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
 804c502:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c505:	8b 55 14             	mov    0x14(%ebp),%edx
 804c508:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c50c:	89 04 24             	mov    %eax,(%esp)
 804c50f:	e8 95 d8 ff ff       	call   8049da9 <_ZL12cJSON_strdupPKhPK14internal_hooks>
 804c514:	89 45 f0             	mov    %eax,-0x10(%ebp)
        if (new_key == NULL)
 804c517:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804c51b:	75 07                	jne    804c524 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0x74>
        {
            return false;
 804c51d:	b8 00 00 00 00       	mov    $0x0,%eax
 804c522:	eb 5a                	jmp    804c57e <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0xce>
        }

        new_type = item->type & ~cJSON_StringIsConst;
 804c524:	8b 45 10             	mov    0x10(%ebp),%eax
 804c527:	8b 40 0c             	mov    0xc(%eax),%eax
 804c52a:	80 e4 fd             	and    $0xfd,%ah
 804c52d:	89 45 f4             	mov    %eax,-0xc(%ebp)
    }

    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
 804c530:	8b 45 10             	mov    0x10(%ebp),%eax
 804c533:	8b 40 0c             	mov    0xc(%eax),%eax
 804c536:	25 00 02 00 00       	and    $0x200,%eax
 804c53b:	85 c0                	test   %eax,%eax
 804c53d:	75 1b                	jne    804c55a <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0xaa>
 804c53f:	8b 45 10             	mov    0x10(%ebp),%eax
 804c542:	8b 40 20             	mov    0x20(%eax),%eax
 804c545:	85 c0                	test   %eax,%eax
 804c547:	74 11                	je     804c55a <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi+0xaa>
    {
        hooks->deallocate(item->string);
 804c549:	8b 45 14             	mov    0x14(%ebp),%eax
 804c54c:	8b 40 04             	mov    0x4(%eax),%eax
 804c54f:	8b 55 10             	mov    0x10(%ebp),%edx
 804c552:	8b 52 20             	mov    0x20(%edx),%edx
 804c555:	89 14 24             	mov    %edx,(%esp)
 804c558:	ff d0                	call   *%eax
    }

    item->string = new_key;
 804c55a:	8b 45 10             	mov    0x10(%ebp),%eax
 804c55d:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804c560:	89 50 20             	mov    %edx,0x20(%eax)
    item->type = new_type;
 804c563:	8b 45 10             	mov    0x10(%ebp),%eax
 804c566:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804c569:	89 50 0c             	mov    %edx,0xc(%eax)

    return add_item_to_array(object, item);
 804c56c:	8b 45 10             	mov    0x10(%ebp),%eax
 804c56f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c573:	8b 45 08             	mov    0x8(%ebp),%eax
 804c576:	89 04 24             	mov    %eax,(%esp)
 804c579:	e8 a7 fe ff ff       	call   804c425 <_ZL17add_item_to_arrayP5cJSONS0_>
}
 804c57e:	c9                   	leave  
 804c57f:	c3                   	ret    

0804c580 <cJSON_AddItemToObject>:

CJSON_PUBLIC(void) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
{
 804c580:	55                   	push   %ebp
 804c581:	89 e5                	mov    %esp,%ebp
 804c583:	83 ec 28             	sub    $0x28,%esp
    add_item_to_object(object, string, item, &global_hooks, false);
 804c586:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c58d:	00 
 804c58e:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c595:	08 
 804c596:	8b 45 10             	mov    0x10(%ebp),%eax
 804c599:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c59d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c5a0:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c5a4:	8b 45 08             	mov    0x8(%ebp),%eax
 804c5a7:	89 04 24             	mov    %eax,(%esp)
 804c5aa:	e8 01 ff ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
}
 804c5af:	c9                   	leave  
 804c5b0:	c3                   	ret    

0804c5b1 <cJSON_AddItemToObjectCS>:

/* Add an item to an object with constant string as key */
CJSON_PUBLIC(void) cJSON_AddItemToObjectCS(cJSON *object, const char *string, cJSON *item)
{
 804c5b1:	55                   	push   %ebp
 804c5b2:	89 e5                	mov    %esp,%ebp
 804c5b4:	83 ec 28             	sub    $0x28,%esp
    add_item_to_object(object, string, item, &global_hooks, true);
 804c5b7:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
 804c5be:	00 
 804c5bf:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c5c6:	08 
 804c5c7:	8b 45 10             	mov    0x10(%ebp),%eax
 804c5ca:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c5ce:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c5d1:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c5d5:	8b 45 08             	mov    0x8(%ebp),%eax
 804c5d8:	89 04 24             	mov    %eax,(%esp)
 804c5db:	e8 d0 fe ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
}
 804c5e0:	c9                   	leave  
 804c5e1:	c3                   	ret    

0804c5e2 <cJSON_AddItemReferenceToArray>:

CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
{
 804c5e2:	55                   	push   %ebp
 804c5e3:	89 e5                	mov    %esp,%ebp
 804c5e5:	83 ec 18             	sub    $0x18,%esp
    if (array == NULL)
 804c5e8:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c5ec:	74 24                	je     804c612 <cJSON_AddItemReferenceToArray+0x30>
    {
        return;
    }

    add_item_to_array(array, create_reference(item, &global_hooks));
 804c5ee:	c7 44 24 04 04 04 05 	movl   $0x8050404,0x4(%esp)
 804c5f5:	08 
 804c5f6:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c5f9:	89 04 24             	mov    %eax,(%esp)
 804c5fc:	e8 a0 fd ff ff       	call   804c3a1 <_ZL16create_referencePK5cJSONPK14internal_hooks>
 804c601:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c605:	8b 45 08             	mov    0x8(%ebp),%eax
 804c608:	89 04 24             	mov    %eax,(%esp)
 804c60b:	e8 15 fe ff ff       	call   804c425 <_ZL17add_item_to_arrayP5cJSONS0_>
 804c610:	eb 01                	jmp    804c613 <cJSON_AddItemReferenceToArray+0x31>

CJSON_PUBLIC(void) cJSON_AddItemReferenceToArray(cJSON *array, cJSON *item)
{
    if (array == NULL)
    {
        return;
 804c612:	90                   	nop
    }

    add_item_to_array(array, create_reference(item, &global_hooks));
}
 804c613:	c9                   	leave  
 804c614:	c3                   	ret    

0804c615 <cJSON_AddItemReferenceToObject>:

CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
{
 804c615:	55                   	push   %ebp
 804c616:	89 e5                	mov    %esp,%ebp
 804c618:	83 ec 28             	sub    $0x28,%esp
    if ((object == NULL) || (string == NULL))
 804c61b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c61f:	74 41                	je     804c662 <cJSON_AddItemReferenceToObject+0x4d>
 804c621:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c625:	74 3e                	je     804c665 <cJSON_AddItemReferenceToObject+0x50>
    {
        return;
    }

    add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
 804c627:	c7 44 24 04 04 04 05 	movl   $0x8050404,0x4(%esp)
 804c62e:	08 
 804c62f:	8b 45 10             	mov    0x10(%ebp),%eax
 804c632:	89 04 24             	mov    %eax,(%esp)
 804c635:	e8 67 fd ff ff       	call   804c3a1 <_ZL16create_referencePK5cJSONPK14internal_hooks>
 804c63a:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c641:	00 
 804c642:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c649:	08 
 804c64a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c64e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c651:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c655:	8b 45 08             	mov    0x8(%ebp),%eax
 804c658:	89 04 24             	mov    %eax,(%esp)
 804c65b:	e8 50 fe ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c660:	eb 04                	jmp    804c666 <cJSON_AddItemReferenceToObject+0x51>

CJSON_PUBLIC(void) cJSON_AddItemReferenceToObject(cJSON *object, const char *string, cJSON *item)
{
    if ((object == NULL) || (string == NULL))
    {
        return;
 804c662:	90                   	nop
 804c663:	eb 01                	jmp    804c666 <cJSON_AddItemReferenceToObject+0x51>
 804c665:	90                   	nop
    }

    add_item_to_object(object, string, create_reference(item, &global_hooks), &global_hooks, false);
}
 804c666:	c9                   	leave  
 804c667:	c3                   	ret    

0804c668 <cJSON_AddNullToObject>:

CJSON_PUBLIC(cJSON*) cJSON_AddNullToObject(cJSON * const object, const char * const name)
{
 804c668:	55                   	push   %ebp
 804c669:	89 e5                	mov    %esp,%ebp
 804c66b:	83 ec 38             	sub    $0x38,%esp
    cJSON *null = cJSON_CreateNull();
 804c66e:	e8 f2 06 00 00       	call   804cd65 <cJSON_CreateNull>
 804c673:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (add_item_to_object(object, name, null, &global_hooks, false))
 804c676:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c67d:	00 
 804c67e:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c685:	08 
 804c686:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c689:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c68d:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c690:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c694:	8b 45 08             	mov    0x8(%ebp),%eax
 804c697:	89 04 24             	mov    %eax,(%esp)
 804c69a:	e8 11 fe ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c69f:	85 c0                	test   %eax,%eax
 804c6a1:	0f 95 c0             	setne  %al
 804c6a4:	84 c0                	test   %al,%al
 804c6a6:	74 05                	je     804c6ad <cJSON_AddNullToObject+0x45>
    {
        return null;
 804c6a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c6ab:	eb 10                	jmp    804c6bd <cJSON_AddNullToObject+0x55>
    }

    cJSON_Delete(null);
 804c6ad:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c6b0:	89 04 24             	mov    %eax,(%esp)
 804c6b3:	e8 2e d8 ff ff       	call   8049ee6 <cJSON_Delete>
    return NULL;
 804c6b8:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c6bd:	c9                   	leave  
 804c6be:	c3                   	ret    

0804c6bf <cJSON_AddTrueToObject>:

CJSON_PUBLIC(cJSON*) cJSON_AddTrueToObject(cJSON * const object, const char * const name)
{
 804c6bf:	55                   	push   %ebp
 804c6c0:	89 e5                	mov    %esp,%ebp
 804c6c2:	83 ec 38             	sub    $0x38,%esp
    cJSON *true_item = cJSON_CreateTrue();
 804c6c5:	e8 c5 06 00 00       	call   804cd8f <cJSON_CreateTrue>
 804c6ca:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (add_item_to_object(object, name, true_item, &global_hooks, false))
 804c6cd:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c6d4:	00 
 804c6d5:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c6dc:	08 
 804c6dd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c6e0:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c6e4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c6e7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c6eb:	8b 45 08             	mov    0x8(%ebp),%eax
 804c6ee:	89 04 24             	mov    %eax,(%esp)
 804c6f1:	e8 ba fd ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c6f6:	85 c0                	test   %eax,%eax
 804c6f8:	0f 95 c0             	setne  %al
 804c6fb:	84 c0                	test   %al,%al
 804c6fd:	74 05                	je     804c704 <cJSON_AddTrueToObject+0x45>
    {
        return true_item;
 804c6ff:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c702:	eb 10                	jmp    804c714 <cJSON_AddTrueToObject+0x55>
    }

    cJSON_Delete(true_item);
 804c704:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c707:	89 04 24             	mov    %eax,(%esp)
 804c70a:	e8 d7 d7 ff ff       	call   8049ee6 <cJSON_Delete>
    return NULL;
 804c70f:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c714:	c9                   	leave  
 804c715:	c3                   	ret    

0804c716 <cJSON_AddFalseToObject>:

CJSON_PUBLIC(cJSON*) cJSON_AddFalseToObject(cJSON * const object, const char * const name)
{
 804c716:	55                   	push   %ebp
 804c717:	89 e5                	mov    %esp,%ebp
 804c719:	83 ec 38             	sub    $0x38,%esp
    cJSON *false_item = cJSON_CreateFalse();
 804c71c:	e8 98 06 00 00       	call   804cdb9 <cJSON_CreateFalse>
 804c721:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (add_item_to_object(object, name, false_item, &global_hooks, false))
 804c724:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c72b:	00 
 804c72c:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c733:	08 
 804c734:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c737:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c73b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c73e:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c742:	8b 45 08             	mov    0x8(%ebp),%eax
 804c745:	89 04 24             	mov    %eax,(%esp)
 804c748:	e8 63 fd ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c74d:	85 c0                	test   %eax,%eax
 804c74f:	0f 95 c0             	setne  %al
 804c752:	84 c0                	test   %al,%al
 804c754:	74 05                	je     804c75b <cJSON_AddFalseToObject+0x45>
    {
        return false_item;
 804c756:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c759:	eb 10                	jmp    804c76b <cJSON_AddFalseToObject+0x55>
    }

    cJSON_Delete(false_item);
 804c75b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c75e:	89 04 24             	mov    %eax,(%esp)
 804c761:	e8 80 d7 ff ff       	call   8049ee6 <cJSON_Delete>
    return NULL;
 804c766:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c76b:	c9                   	leave  
 804c76c:	c3                   	ret    

0804c76d <cJSON_AddBoolToObject>:

CJSON_PUBLIC(cJSON*) cJSON_AddBoolToObject(cJSON * const object, const char * const name, const cJSON_bool boolean)
{
 804c76d:	55                   	push   %ebp
 804c76e:	89 e5                	mov    %esp,%ebp
 804c770:	83 ec 38             	sub    $0x38,%esp
    cJSON *bool_item = cJSON_CreateBool(boolean);
 804c773:	8b 45 10             	mov    0x10(%ebp),%eax
 804c776:	89 04 24             	mov    %eax,(%esp)
 804c779:	e8 65 06 00 00       	call   804cde3 <cJSON_CreateBool>
 804c77e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (add_item_to_object(object, name, bool_item, &global_hooks, false))
 804c781:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c788:	00 
 804c789:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c790:	08 
 804c791:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c794:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c798:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c79b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c79f:	8b 45 08             	mov    0x8(%ebp),%eax
 804c7a2:	89 04 24             	mov    %eax,(%esp)
 804c7a5:	e8 06 fd ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c7aa:	85 c0                	test   %eax,%eax
 804c7ac:	0f 95 c0             	setne  %al
 804c7af:	84 c0                	test   %al,%al
 804c7b1:	74 05                	je     804c7b8 <cJSON_AddBoolToObject+0x4b>
    {
        return bool_item;
 804c7b3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c7b6:	eb 10                	jmp    804c7c8 <cJSON_AddBoolToObject+0x5b>
    }

    cJSON_Delete(bool_item);
 804c7b8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c7bb:	89 04 24             	mov    %eax,(%esp)
 804c7be:	e8 23 d7 ff ff       	call   8049ee6 <cJSON_Delete>
    return NULL;
 804c7c3:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c7c8:	c9                   	leave  
 804c7c9:	c3                   	ret    

0804c7ca <cJSON_AddNumberToObject>:

CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
{
 804c7ca:	55                   	push   %ebp
 804c7cb:	89 e5                	mov    %esp,%ebp
 804c7cd:	83 ec 48             	sub    $0x48,%esp
 804c7d0:	8b 45 10             	mov    0x10(%ebp),%eax
 804c7d3:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804c7d6:	8b 45 14             	mov    0x14(%ebp),%eax
 804c7d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    cJSON *number_item = cJSON_CreateNumber(number);
 804c7dc:	dd 45 e0             	fldl   -0x20(%ebp)
 804c7df:	dd 1c 24             	fstpl  (%esp)
 804c7e2:	e8 34 06 00 00       	call   804ce1b <cJSON_CreateNumber>
 804c7e7:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (add_item_to_object(object, name, number_item, &global_hooks, false))
 804c7ea:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c7f1:	00 
 804c7f2:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c7f9:	08 
 804c7fa:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c7fd:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c801:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c804:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c808:	8b 45 08             	mov    0x8(%ebp),%eax
 804c80b:	89 04 24             	mov    %eax,(%esp)
 804c80e:	e8 9d fc ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c813:	85 c0                	test   %eax,%eax
 804c815:	0f 95 c0             	setne  %al
 804c818:	84 c0                	test   %al,%al
 804c81a:	74 05                	je     804c821 <cJSON_AddNumberToObject+0x57>
    {
        return number_item;
 804c81c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c81f:	eb 10                	jmp    804c831 <cJSON_AddNumberToObject+0x67>
    }

    cJSON_Delete(number_item);
 804c821:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c824:	89 04 24             	mov    %eax,(%esp)
 804c827:	e8 ba d6 ff ff       	call   8049ee6 <cJSON_Delete>
    return NULL;
 804c82c:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c831:	c9                   	leave  
 804c832:	c3                   	ret    

0804c833 <cJSON_AddStringToObject>:

CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
{
 804c833:	55                   	push   %ebp
 804c834:	89 e5                	mov    %esp,%ebp
 804c836:	83 ec 38             	sub    $0x38,%esp
    cJSON *string_item = cJSON_CreateString(string);
 804c839:	8b 45 10             	mov    0x10(%ebp),%eax
 804c83c:	89 04 24             	mov    %eax,(%esp)
 804c83f:	e8 7a 06 00 00       	call   804cebe <cJSON_CreateString>
 804c844:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (add_item_to_object(object, name, string_item, &global_hooks, false))
 804c847:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c84e:	00 
 804c84f:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c856:	08 
 804c857:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c85a:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c85e:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c861:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c865:	8b 45 08             	mov    0x8(%ebp),%eax
 804c868:	89 04 24             	mov    %eax,(%esp)
 804c86b:	e8 40 fc ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c870:	85 c0                	test   %eax,%eax
 804c872:	0f 95 c0             	setne  %al
 804c875:	84 c0                	test   %al,%al
 804c877:	74 05                	je     804c87e <cJSON_AddStringToObject+0x4b>
    {
        return string_item;
 804c879:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c87c:	eb 10                	jmp    804c88e <cJSON_AddStringToObject+0x5b>
    }

    cJSON_Delete(string_item);
 804c87e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c881:	89 04 24             	mov    %eax,(%esp)
 804c884:	e8 5d d6 ff ff       	call   8049ee6 <cJSON_Delete>
    return NULL;
 804c889:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c88e:	c9                   	leave  
 804c88f:	c3                   	ret    

0804c890 <cJSON_AddRawToObject>:

CJSON_PUBLIC(cJSON*) cJSON_AddRawToObject(cJSON * const object, const char * const name, const char * const raw)
{
 804c890:	55                   	push   %ebp
 804c891:	89 e5                	mov    %esp,%ebp
 804c893:	83 ec 38             	sub    $0x38,%esp
    cJSON *raw_item = cJSON_CreateRaw(raw);
 804c896:	8b 45 10             	mov    0x10(%ebp),%eax
 804c899:	89 04 24             	mov    %eax,(%esp)
 804c89c:	e8 35 07 00 00       	call   804cfd6 <cJSON_CreateRaw>
 804c8a1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (add_item_to_object(object, name, raw_item, &global_hooks, false))
 804c8a4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c8ab:	00 
 804c8ac:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c8b3:	08 
 804c8b4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c8b7:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c8bb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c8be:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c8c2:	8b 45 08             	mov    0x8(%ebp),%eax
 804c8c5:	89 04 24             	mov    %eax,(%esp)
 804c8c8:	e8 e3 fb ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c8cd:	85 c0                	test   %eax,%eax
 804c8cf:	0f 95 c0             	setne  %al
 804c8d2:	84 c0                	test   %al,%al
 804c8d4:	74 05                	je     804c8db <cJSON_AddRawToObject+0x4b>
    {
        return raw_item;
 804c8d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c8d9:	eb 10                	jmp    804c8eb <cJSON_AddRawToObject+0x5b>
    }

    cJSON_Delete(raw_item);
 804c8db:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c8de:	89 04 24             	mov    %eax,(%esp)
 804c8e1:	e8 00 d6 ff ff       	call   8049ee6 <cJSON_Delete>
    return NULL;
 804c8e6:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c8eb:	c9                   	leave  
 804c8ec:	c3                   	ret    

0804c8ed <cJSON_AddObjectToObject>:

CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
{
 804c8ed:	55                   	push   %ebp
 804c8ee:	89 e5                	mov    %esp,%ebp
 804c8f0:	83 ec 38             	sub    $0x38,%esp
    cJSON *object_item = cJSON_CreateObject();
 804c8f3:	e8 69 07 00 00       	call   804d061 <cJSON_CreateObject>
 804c8f8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (add_item_to_object(object, name, object_item, &global_hooks, false))
 804c8fb:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c902:	00 
 804c903:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c90a:	08 
 804c90b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c90e:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c912:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c915:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c919:	8b 45 08             	mov    0x8(%ebp),%eax
 804c91c:	89 04 24             	mov    %eax,(%esp)
 804c91f:	e8 8c fb ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c924:	85 c0                	test   %eax,%eax
 804c926:	0f 95 c0             	setne  %al
 804c929:	84 c0                	test   %al,%al
 804c92b:	74 05                	je     804c932 <cJSON_AddObjectToObject+0x45>
    {
        return object_item;
 804c92d:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c930:	eb 10                	jmp    804c942 <cJSON_AddObjectToObject+0x55>
    }

    cJSON_Delete(object_item);
 804c932:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c935:	89 04 24             	mov    %eax,(%esp)
 804c938:	e8 a9 d5 ff ff       	call   8049ee6 <cJSON_Delete>
    return NULL;
 804c93d:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c942:	c9                   	leave  
 804c943:	c3                   	ret    

0804c944 <cJSON_AddArrayToObject>:

CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
{
 804c944:	55                   	push   %ebp
 804c945:	89 e5                	mov    %esp,%ebp
 804c947:	83 ec 38             	sub    $0x38,%esp
    cJSON *array = cJSON_CreateArray();
 804c94a:	e8 e8 06 00 00       	call   804d037 <cJSON_CreateArray>
 804c94f:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (add_item_to_object(object, name, array, &global_hooks, false))
 804c952:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
 804c959:	00 
 804c95a:	c7 44 24 0c 04 04 05 	movl   $0x8050404,0xc(%esp)
 804c961:	08 
 804c962:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c965:	89 44 24 08          	mov    %eax,0x8(%esp)
 804c969:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c96c:	89 44 24 04          	mov    %eax,0x4(%esp)
 804c970:	8b 45 08             	mov    0x8(%ebp),%eax
 804c973:	89 04 24             	mov    %eax,(%esp)
 804c976:	e8 35 fb ff ff       	call   804c4b0 <_ZL18add_item_to_objectP5cJSONPKcS0_PK14internal_hooksi>
 804c97b:	85 c0                	test   %eax,%eax
 804c97d:	0f 95 c0             	setne  %al
 804c980:	84 c0                	test   %al,%al
 804c982:	74 05                	je     804c989 <cJSON_AddArrayToObject+0x45>
    {
        return array;
 804c984:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c987:	eb 10                	jmp    804c999 <cJSON_AddArrayToObject+0x55>
    }

    cJSON_Delete(array);
 804c989:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804c98c:	89 04 24             	mov    %eax,(%esp)
 804c98f:	e8 52 d5 ff ff       	call   8049ee6 <cJSON_Delete>
    return NULL;
 804c994:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804c999:	c9                   	leave  
 804c99a:	c3                   	ret    

0804c99b <cJSON_DetachItemViaPointer>:

CJSON_PUBLIC(cJSON *) cJSON_DetachItemViaPointer(cJSON *parent, cJSON * const item)
{
 804c99b:	55                   	push   %ebp
 804c99c:	89 e5                	mov    %esp,%ebp
    if ((parent == NULL) || (item == NULL))
 804c99e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804c9a2:	74 06                	je     804c9aa <cJSON_DetachItemViaPointer+0xf>
 804c9a4:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804c9a8:	75 07                	jne    804c9b1 <cJSON_DetachItemViaPointer+0x16>
    {
        return NULL;
 804c9aa:	b8 00 00 00 00       	mov    $0x0,%eax
 804c9af:	eb 5a                	jmp    804ca0b <cJSON_DetachItemViaPointer+0x70>
    }

    if (item->prev != NULL)
 804c9b1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c9b4:	8b 40 04             	mov    0x4(%eax),%eax
 804c9b7:	85 c0                	test   %eax,%eax
 804c9b9:	74 0d                	je     804c9c8 <cJSON_DetachItemViaPointer+0x2d>
    {
        /* not the first element */
        item->prev->next = item->next;
 804c9bb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c9be:	8b 40 04             	mov    0x4(%eax),%eax
 804c9c1:	8b 55 0c             	mov    0xc(%ebp),%edx
 804c9c4:	8b 12                	mov    (%edx),%edx
 804c9c6:	89 10                	mov    %edx,(%eax)
    }
    if (item->next != NULL)
 804c9c8:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c9cb:	8b 00                	mov    (%eax),%eax
 804c9cd:	85 c0                	test   %eax,%eax
 804c9cf:	74 0e                	je     804c9df <cJSON_DetachItemViaPointer+0x44>
    {
        /* not the last element */
        item->next->prev = item->prev;
 804c9d1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c9d4:	8b 00                	mov    (%eax),%eax
 804c9d6:	8b 55 0c             	mov    0xc(%ebp),%edx
 804c9d9:	8b 52 04             	mov    0x4(%edx),%edx
 804c9dc:	89 50 04             	mov    %edx,0x4(%eax)
    }

    if (item == parent->child)
 804c9df:	8b 45 08             	mov    0x8(%ebp),%eax
 804c9e2:	8b 40 08             	mov    0x8(%eax),%eax
 804c9e5:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804c9e8:	75 0b                	jne    804c9f5 <cJSON_DetachItemViaPointer+0x5a>
    {
        /* first element */
        parent->child = item->next;
 804c9ea:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c9ed:	8b 10                	mov    (%eax),%edx
 804c9ef:	8b 45 08             	mov    0x8(%ebp),%eax
 804c9f2:	89 50 08             	mov    %edx,0x8(%eax)
    }
    /* make sure the detached item doesn't point anywhere anymore */
    item->prev = NULL;
 804c9f5:	8b 45 0c             	mov    0xc(%ebp),%eax
 804c9f8:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    item->next = NULL;
 804c9ff:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ca02:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    return item;
 804ca08:	8b 45 0c             	mov    0xc(%ebp),%eax
}
 804ca0b:	5d                   	pop    %ebp
 804ca0c:	c3                   	ret    

0804ca0d <cJSON_DetachItemFromArray>:

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromArray(cJSON *array, int which)
{
 804ca0d:	55                   	push   %ebp
 804ca0e:	89 e5                	mov    %esp,%ebp
 804ca10:	83 ec 08             	sub    $0x8,%esp
    if (which < 0)
 804ca13:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804ca17:	79 07                	jns    804ca20 <cJSON_DetachItemFromArray+0x13>
    {
        return NULL;
 804ca19:	b8 00 00 00 00       	mov    $0x0,%eax
 804ca1e:	eb 21                	jmp    804ca41 <cJSON_DetachItemFromArray+0x34>
    }

    return cJSON_DetachItemViaPointer(array, get_array_item(array, (size_t)which));
 804ca20:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ca23:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ca27:	8b 45 08             	mov    0x8(%ebp),%eax
 804ca2a:	89 04 24             	mov    %eax,(%esp)
 804ca2d:	e8 c7 f7 ff ff       	call   804c1f9 <_ZL14get_array_itemPK5cJSONj>
 804ca32:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ca36:	8b 45 08             	mov    0x8(%ebp),%eax
 804ca39:	89 04 24             	mov    %eax,(%esp)
 804ca3c:	e8 5a ff ff ff       	call   804c99b <cJSON_DetachItemViaPointer>
}
 804ca41:	c9                   	leave  
 804ca42:	c3                   	ret    

0804ca43 <cJSON_DeleteItemFromArray>:

CJSON_PUBLIC(void) cJSON_DeleteItemFromArray(cJSON *array, int which)
{
 804ca43:	55                   	push   %ebp
 804ca44:	89 e5                	mov    %esp,%ebp
 804ca46:	83 ec 18             	sub    $0x18,%esp
    cJSON_Delete(cJSON_DetachItemFromArray(array, which));
 804ca49:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ca4c:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ca50:	8b 45 08             	mov    0x8(%ebp),%eax
 804ca53:	89 04 24             	mov    %eax,(%esp)
 804ca56:	e8 b2 ff ff ff       	call   804ca0d <cJSON_DetachItemFromArray>
 804ca5b:	89 04 24             	mov    %eax,(%esp)
 804ca5e:	e8 83 d4 ff ff       	call   8049ee6 <cJSON_Delete>
}
 804ca63:	c9                   	leave  
 804ca64:	c3                   	ret    

0804ca65 <cJSON_DetachItemFromObject>:

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObject(cJSON *object, const char *string)
{
 804ca65:	55                   	push   %ebp
 804ca66:	89 e5                	mov    %esp,%ebp
 804ca68:	83 ec 28             	sub    $0x28,%esp
    cJSON *to_detach = cJSON_GetObjectItem(object, string);
 804ca6b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ca6e:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ca72:	8b 45 08             	mov    0x8(%ebp),%eax
 804ca75:	89 04 24             	mov    %eax,(%esp)
 804ca78:	e8 a0 f8 ff ff       	call   804c31d <cJSON_GetObjectItem>
 804ca7d:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return cJSON_DetachItemViaPointer(object, to_detach);
 804ca80:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ca83:	89 44 24 04          	mov    %eax,0x4(%esp)
 804ca87:	8b 45 08             	mov    0x8(%ebp),%eax
 804ca8a:	89 04 24             	mov    %eax,(%esp)
 804ca8d:	e8 09 ff ff ff       	call   804c99b <cJSON_DetachItemViaPointer>
}
 804ca92:	c9                   	leave  
 804ca93:	c3                   	ret    

0804ca94 <cJSON_DetachItemFromObjectCaseSensitive>:

CJSON_PUBLIC(cJSON *) cJSON_DetachItemFromObjectCaseSensitive(cJSON *object, const char *string)
{
 804ca94:	55                   	push   %ebp
 804ca95:	89 e5                	mov    %esp,%ebp
 804ca97:	83 ec 28             	sub    $0x28,%esp
    cJSON *to_detach = cJSON_GetObjectItemCaseSensitive(object, string);
 804ca9a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ca9d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804caa1:	8b 45 08             	mov    0x8(%ebp),%eax
 804caa4:	89 04 24             	mov    %eax,(%esp)
 804caa7:	e8 93 f8 ff ff       	call   804c33f <cJSON_GetObjectItemCaseSensitive>
 804caac:	89 45 f4             	mov    %eax,-0xc(%ebp)

    return cJSON_DetachItemViaPointer(object, to_detach);
 804caaf:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cab2:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cab6:	8b 45 08             	mov    0x8(%ebp),%eax
 804cab9:	89 04 24             	mov    %eax,(%esp)
 804cabc:	e8 da fe ff ff       	call   804c99b <cJSON_DetachItemViaPointer>
}
 804cac1:	c9                   	leave  
 804cac2:	c3                   	ret    

0804cac3 <cJSON_DeleteItemFromObject>:

CJSON_PUBLIC(void) cJSON_DeleteItemFromObject(cJSON *object, const char *string)
{
 804cac3:	55                   	push   %ebp
 804cac4:	89 e5                	mov    %esp,%ebp
 804cac6:	83 ec 18             	sub    $0x18,%esp
    cJSON_Delete(cJSON_DetachItemFromObject(object, string));
 804cac9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cacc:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cad0:	8b 45 08             	mov    0x8(%ebp),%eax
 804cad3:	89 04 24             	mov    %eax,(%esp)
 804cad6:	e8 8a ff ff ff       	call   804ca65 <cJSON_DetachItemFromObject>
 804cadb:	89 04 24             	mov    %eax,(%esp)
 804cade:	e8 03 d4 ff ff       	call   8049ee6 <cJSON_Delete>
}
 804cae3:	c9                   	leave  
 804cae4:	c3                   	ret    

0804cae5 <cJSON_DeleteItemFromObjectCaseSensitive>:

CJSON_PUBLIC(void) cJSON_DeleteItemFromObjectCaseSensitive(cJSON *object, const char *string)
{
 804cae5:	55                   	push   %ebp
 804cae6:	89 e5                	mov    %esp,%ebp
 804cae8:	83 ec 18             	sub    $0x18,%esp
    cJSON_Delete(cJSON_DetachItemFromObjectCaseSensitive(object, string));
 804caeb:	8b 45 0c             	mov    0xc(%ebp),%eax
 804caee:	89 44 24 04          	mov    %eax,0x4(%esp)
 804caf2:	8b 45 08             	mov    0x8(%ebp),%eax
 804caf5:	89 04 24             	mov    %eax,(%esp)
 804caf8:	e8 97 ff ff ff       	call   804ca94 <cJSON_DetachItemFromObjectCaseSensitive>
 804cafd:	89 04 24             	mov    %eax,(%esp)
 804cb00:	e8 e1 d3 ff ff       	call   8049ee6 <cJSON_Delete>
}
 804cb05:	c9                   	leave  
 804cb06:	c3                   	ret    

0804cb07 <cJSON_InsertItemInArray>:

/* Replace array/object items with new ones. */
CJSON_PUBLIC(void) cJSON_InsertItemInArray(cJSON *array, int which, cJSON *newitem)
{
 804cb07:	55                   	push   %ebp
 804cb08:	89 e5                	mov    %esp,%ebp
 804cb0a:	83 ec 18             	sub    $0x18,%esp
    cJSON *after_inserted = NULL;
 804cb0d:	c7 45 fc 00 00 00 00 	movl   $0x0,-0x4(%ebp)

    if (which < 0)
 804cb14:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804cb18:	78 6f                	js     804cb89 <cJSON_InsertItemInArray+0x82>
    {
        return;
    }

    after_inserted = get_array_item(array, (size_t)which);
 804cb1a:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cb1d:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cb21:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb24:	89 04 24             	mov    %eax,(%esp)
 804cb27:	e8 cd f6 ff ff       	call   804c1f9 <_ZL14get_array_itemPK5cJSONj>
 804cb2c:	89 45 fc             	mov    %eax,-0x4(%ebp)
    if (after_inserted == NULL)
 804cb2f:	83 7d fc 00          	cmpl   $0x0,-0x4(%ebp)
 804cb33:	75 14                	jne    804cb49 <cJSON_InsertItemInArray+0x42>
    {
        add_item_to_array(array, newitem);
 804cb35:	8b 45 10             	mov    0x10(%ebp),%eax
 804cb38:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cb3c:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb3f:	89 04 24             	mov    %eax,(%esp)
 804cb42:	e8 de f8 ff ff       	call   804c425 <_ZL17add_item_to_arrayP5cJSONS0_>
        return;
 804cb47:	eb 41                	jmp    804cb8a <cJSON_InsertItemInArray+0x83>
    }

    newitem->next = after_inserted;
 804cb49:	8b 45 10             	mov    0x10(%ebp),%eax
 804cb4c:	8b 55 fc             	mov    -0x4(%ebp),%edx
 804cb4f:	89 10                	mov    %edx,(%eax)
    newitem->prev = after_inserted->prev;
 804cb51:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cb54:	8b 50 04             	mov    0x4(%eax),%edx
 804cb57:	8b 45 10             	mov    0x10(%ebp),%eax
 804cb5a:	89 50 04             	mov    %edx,0x4(%eax)
    after_inserted->prev = newitem;
 804cb5d:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804cb60:	8b 55 10             	mov    0x10(%ebp),%edx
 804cb63:	89 50 04             	mov    %edx,0x4(%eax)
    if (after_inserted == array->child)
 804cb66:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb69:	8b 40 08             	mov    0x8(%eax),%eax
 804cb6c:	3b 45 fc             	cmp    -0x4(%ebp),%eax
 804cb6f:	75 0b                	jne    804cb7c <cJSON_InsertItemInArray+0x75>
    {
        array->child = newitem;
 804cb71:	8b 45 08             	mov    0x8(%ebp),%eax
 804cb74:	8b 55 10             	mov    0x10(%ebp),%edx
 804cb77:	89 50 08             	mov    %edx,0x8(%eax)
 804cb7a:	eb 0e                	jmp    804cb8a <cJSON_InsertItemInArray+0x83>
    }
    else
    {
        newitem->prev->next = newitem;
 804cb7c:	8b 45 10             	mov    0x10(%ebp),%eax
 804cb7f:	8b 40 04             	mov    0x4(%eax),%eax
 804cb82:	8b 55 10             	mov    0x10(%ebp),%edx
 804cb85:	89 10                	mov    %edx,(%eax)
 804cb87:	eb 01                	jmp    804cb8a <cJSON_InsertItemInArray+0x83>
{
    cJSON *after_inserted = NULL;

    if (which < 0)
    {
        return;
 804cb89:	90                   	nop
    }
    else
    {
        newitem->prev->next = newitem;
    }
}
 804cb8a:	c9                   	leave  
 804cb8b:	c3                   	ret    

0804cb8c <cJSON_ReplaceItemViaPointer>:

CJSON_PUBLIC(cJSON_bool) cJSON_ReplaceItemViaPointer(cJSON * const parent, cJSON * const item, cJSON * replacement)
{
 804cb8c:	55                   	push   %ebp
 804cb8d:	89 e5                	mov    %esp,%ebp
 804cb8f:	83 ec 18             	sub    $0x18,%esp
    if ((parent == NULL) || (replacement == NULL) || (item == NULL))
 804cb92:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804cb96:	74 0c                	je     804cba4 <cJSON_ReplaceItemViaPointer+0x18>
 804cb98:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804cb9c:	74 06                	je     804cba4 <cJSON_ReplaceItemViaPointer+0x18>
 804cb9e:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804cba2:	75 0a                	jne    804cbae <cJSON_ReplaceItemViaPointer+0x22>
    {
        return false;
 804cba4:	b8 00 00 00 00       	mov    $0x0,%eax
 804cba9:	e9 85 00 00 00       	jmp    804cc33 <cJSON_ReplaceItemViaPointer+0xa7>
    }

    if (replacement == item)
 804cbae:	8b 45 10             	mov    0x10(%ebp),%eax
 804cbb1:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804cbb4:	75 07                	jne    804cbbd <cJSON_ReplaceItemViaPointer+0x31>
    {
        return true;
 804cbb6:	b8 01 00 00 00       	mov    $0x1,%eax
 804cbbb:	eb 76                	jmp    804cc33 <cJSON_ReplaceItemViaPointer+0xa7>
    }

    replacement->next = item->next;
 804cbbd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cbc0:	8b 10                	mov    (%eax),%edx
 804cbc2:	8b 45 10             	mov    0x10(%ebp),%eax
 804cbc5:	89 10                	mov    %edx,(%eax)
    replacement->prev = item->prev;
 804cbc7:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cbca:	8b 50 04             	mov    0x4(%eax),%edx
 804cbcd:	8b 45 10             	mov    0x10(%ebp),%eax
 804cbd0:	89 50 04             	mov    %edx,0x4(%eax)

    if (replacement->next != NULL)
 804cbd3:	8b 45 10             	mov    0x10(%ebp),%eax
 804cbd6:	8b 00                	mov    (%eax),%eax
 804cbd8:	85 c0                	test   %eax,%eax
 804cbda:	74 0b                	je     804cbe7 <cJSON_ReplaceItemViaPointer+0x5b>
    {
        replacement->next->prev = replacement;
 804cbdc:	8b 45 10             	mov    0x10(%ebp),%eax
 804cbdf:	8b 00                	mov    (%eax),%eax
 804cbe1:	8b 55 10             	mov    0x10(%ebp),%edx
 804cbe4:	89 50 04             	mov    %edx,0x4(%eax)
    }
    if (replacement->prev != NULL)
 804cbe7:	8b 45 10             	mov    0x10(%ebp),%eax
 804cbea:	8b 40 04             	mov    0x4(%eax),%eax
 804cbed:	85 c0                	test   %eax,%eax
 804cbef:	74 0b                	je     804cbfc <cJSON_ReplaceItemViaPointer+0x70>
    {
        replacement->prev->next = replacement;
 804cbf1:	8b 45 10             	mov    0x10(%ebp),%eax
 804cbf4:	8b 40 04             	mov    0x4(%eax),%eax
 804cbf7:	8b 55 10             	mov    0x10(%ebp),%edx
 804cbfa:	89 10                	mov    %edx,(%eax)
    }
    if (parent->child == item)
 804cbfc:	8b 45 08             	mov    0x8(%ebp),%eax
 804cbff:	8b 40 08             	mov    0x8(%eax),%eax
 804cc02:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804cc05:	75 09                	jne    804cc10 <cJSON_ReplaceItemViaPointer+0x84>
    {
        parent->child = replacement;
 804cc07:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc0a:	8b 55 10             	mov    0x10(%ebp),%edx
 804cc0d:	89 50 08             	mov    %edx,0x8(%eax)
    }

    item->next = NULL;
 804cc10:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cc13:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    item->prev = NULL;
 804cc19:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cc1c:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    cJSON_Delete(item);
 804cc23:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cc26:	89 04 24             	mov    %eax,(%esp)
 804cc29:	e8 b8 d2 ff ff       	call   8049ee6 <cJSON_Delete>

    return true;
 804cc2e:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804cc33:	c9                   	leave  
 804cc34:	c3                   	ret    

0804cc35 <cJSON_ReplaceItemInArray>:

CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
{
 804cc35:	55                   	push   %ebp
 804cc36:	89 e5                	mov    %esp,%ebp
 804cc38:	83 ec 18             	sub    $0x18,%esp
    if (which < 0)
 804cc3b:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804cc3f:	78 2a                	js     804cc6b <cJSON_ReplaceItemInArray+0x36>
    {
        return;
    }

    cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
 804cc41:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cc44:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cc48:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc4b:	89 04 24             	mov    %eax,(%esp)
 804cc4e:	e8 a6 f5 ff ff       	call   804c1f9 <_ZL14get_array_itemPK5cJSONj>
 804cc53:	8b 55 10             	mov    0x10(%ebp),%edx
 804cc56:	89 54 24 08          	mov    %edx,0x8(%esp)
 804cc5a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cc5e:	8b 45 08             	mov    0x8(%ebp),%eax
 804cc61:	89 04 24             	mov    %eax,(%esp)
 804cc64:	e8 23 ff ff ff       	call   804cb8c <cJSON_ReplaceItemViaPointer>
 804cc69:	eb 01                	jmp    804cc6c <cJSON_ReplaceItemInArray+0x37>

CJSON_PUBLIC(void) cJSON_ReplaceItemInArray(cJSON *array, int which, cJSON *newitem)
{
    if (which < 0)
    {
        return;
 804cc6b:	90                   	nop
    }

    cJSON_ReplaceItemViaPointer(array, get_array_item(array, (size_t)which), newitem);
}
 804cc6c:	c9                   	leave  
 804cc6d:	c3                   	ret    

0804cc6e <_ZL22replace_item_in_objectP5cJSONPKcS0_i>:

static cJSON_bool replace_item_in_object(cJSON *object, const char *string, cJSON *replacement, cJSON_bool case_sensitive)
{
 804cc6e:	55                   	push   %ebp
 804cc6f:	89 e5                	mov    %esp,%ebp
 804cc71:	83 ec 18             	sub    $0x18,%esp
    if ((replacement == NULL) || (string == NULL))
 804cc74:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
 804cc78:	74 06                	je     804cc80 <_ZL22replace_item_in_objectP5cJSONPKcS0_i+0x12>
 804cc7a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804cc7e:	75 0a                	jne    804cc8a <_ZL22replace_item_in_objectP5cJSONPKcS0_i+0x1c>
    {
        return false;
 804cc80:	b8 00 00 00 00       	mov    $0x0,%eax
 804cc85:	e9 87 00 00 00       	jmp    804cd11 <_ZL22replace_item_in_objectP5cJSONPKcS0_i+0xa3>
    }

    /* replace the name in the replacement */
    if (!(replacement->type & cJSON_StringIsConst) && (replacement->string != NULL))
 804cc8a:	8b 45 10             	mov    0x10(%ebp),%eax
 804cc8d:	8b 40 0c             	mov    0xc(%eax),%eax
 804cc90:	25 00 02 00 00       	and    $0x200,%eax
 804cc95:	85 c0                	test   %eax,%eax
 804cc97:	75 18                	jne    804ccb1 <_ZL22replace_item_in_objectP5cJSONPKcS0_i+0x43>
 804cc99:	8b 45 10             	mov    0x10(%ebp),%eax
 804cc9c:	8b 40 20             	mov    0x20(%eax),%eax
 804cc9f:	85 c0                	test   %eax,%eax
 804cca1:	74 0e                	je     804ccb1 <_ZL22replace_item_in_objectP5cJSONPKcS0_i+0x43>
    {
        cJSON_free(replacement->string);
 804cca3:	8b 45 10             	mov    0x10(%ebp),%eax
 804cca6:	8b 40 20             	mov    0x20(%eax),%eax
 804cca9:	89 04 24             	mov    %eax,(%esp)
 804ccac:	e8 2c 0f 00 00       	call   804dbdd <cJSON_free>
    }
    replacement->string = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
 804ccb1:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ccb4:	c7 44 24 04 04 04 05 	movl   $0x8050404,0x4(%esp)
 804ccbb:	08 
 804ccbc:	89 04 24             	mov    %eax,(%esp)
 804ccbf:	e8 e5 d0 ff ff       	call   8049da9 <_ZL12cJSON_strdupPKhPK14internal_hooks>
 804ccc4:	89 c2                	mov    %eax,%edx
 804ccc6:	8b 45 10             	mov    0x10(%ebp),%eax
 804ccc9:	89 50 20             	mov    %edx,0x20(%eax)
    replacement->type &= ~cJSON_StringIsConst;
 804cccc:	8b 45 10             	mov    0x10(%ebp),%eax
 804cccf:	8b 40 0c             	mov    0xc(%eax),%eax
 804ccd2:	89 c2                	mov    %eax,%edx
 804ccd4:	80 e6 fd             	and    $0xfd,%dh
 804ccd7:	8b 45 10             	mov    0x10(%ebp),%eax
 804ccda:	89 50 0c             	mov    %edx,0xc(%eax)

    cJSON_ReplaceItemViaPointer(object, get_object_item(object, string, case_sensitive), replacement);
 804ccdd:	8b 45 14             	mov    0x14(%ebp),%eax
 804cce0:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cce4:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cce7:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cceb:	8b 45 08             	mov    0x8(%ebp),%eax
 804ccee:	89 04 24             	mov    %eax,(%esp)
 804ccf1:	e8 7c f5 ff ff       	call   804c272 <_ZL15get_object_itemPK5cJSONPKci>
 804ccf6:	8b 55 10             	mov    0x10(%ebp),%edx
 804ccf9:	89 54 24 08          	mov    %edx,0x8(%esp)
 804ccfd:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cd01:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd04:	89 04 24             	mov    %eax,(%esp)
 804cd07:	e8 80 fe ff ff       	call   804cb8c <cJSON_ReplaceItemViaPointer>

    return true;
 804cd0c:	b8 01 00 00 00       	mov    $0x1,%eax
}
 804cd11:	c9                   	leave  
 804cd12:	c3                   	ret    

0804cd13 <cJSON_ReplaceItemInObject>:

CJSON_PUBLIC(void) cJSON_ReplaceItemInObject(cJSON *object, const char *string, cJSON *newitem)
{
 804cd13:	55                   	push   %ebp
 804cd14:	89 e5                	mov    %esp,%ebp
 804cd16:	83 ec 18             	sub    $0x18,%esp
    replace_item_in_object(object, string, newitem, false);
 804cd19:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 804cd20:	00 
 804cd21:	8b 45 10             	mov    0x10(%ebp),%eax
 804cd24:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cd28:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cd2b:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cd2f:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd32:	89 04 24             	mov    %eax,(%esp)
 804cd35:	e8 34 ff ff ff       	call   804cc6e <_ZL22replace_item_in_objectP5cJSONPKcS0_i>
}
 804cd3a:	c9                   	leave  
 804cd3b:	c3                   	ret    

0804cd3c <cJSON_ReplaceItemInObjectCaseSensitive>:

CJSON_PUBLIC(void) cJSON_ReplaceItemInObjectCaseSensitive(cJSON *object, const char *string, cJSON *newitem)
{
 804cd3c:	55                   	push   %ebp
 804cd3d:	89 e5                	mov    %esp,%ebp
 804cd3f:	83 ec 18             	sub    $0x18,%esp
    replace_item_in_object(object, string, newitem, true);
 804cd42:	c7 44 24 0c 01 00 00 	movl   $0x1,0xc(%esp)
 804cd49:	00 
 804cd4a:	8b 45 10             	mov    0x10(%ebp),%eax
 804cd4d:	89 44 24 08          	mov    %eax,0x8(%esp)
 804cd51:	8b 45 0c             	mov    0xc(%ebp),%eax
 804cd54:	89 44 24 04          	mov    %eax,0x4(%esp)
 804cd58:	8b 45 08             	mov    0x8(%ebp),%eax
 804cd5b:	89 04 24             	mov    %eax,(%esp)
 804cd5e:	e8 0b ff ff ff       	call   804cc6e <_ZL22replace_item_in_objectP5cJSONPKcS0_i>
}
 804cd63:	c9                   	leave  
 804cd64:	c3                   	ret    

0804cd65 <cJSON_CreateNull>:

/* Create basic types: */
CJSON_PUBLIC(cJSON *) cJSON_CreateNull(void)
{
 804cd65:	55                   	push   %ebp
 804cd66:	89 e5                	mov    %esp,%ebp
 804cd68:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804cd6b:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804cd72:	e8 32 d1 ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804cd77:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(item)
 804cd7a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804cd7e:	74 0a                	je     804cd8a <cJSON_CreateNull+0x25>
    {
        item->type = cJSON_NULL;
 804cd80:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cd83:	c7 40 0c 04 00 00 00 	movl   $0x4,0xc(%eax)
    }

    return item;
 804cd8a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804cd8d:	c9                   	leave  
 804cd8e:	c3                   	ret    

0804cd8f <cJSON_CreateTrue>:

CJSON_PUBLIC(cJSON *) cJSON_CreateTrue(void)
{
 804cd8f:	55                   	push   %ebp
 804cd90:	89 e5                	mov    %esp,%ebp
 804cd92:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804cd95:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804cd9c:	e8 08 d1 ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804cda1:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(item)
 804cda4:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804cda8:	74 0a                	je     804cdb4 <cJSON_CreateTrue+0x25>
    {
        item->type = cJSON_True;
 804cdaa:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cdad:	c7 40 0c 02 00 00 00 	movl   $0x2,0xc(%eax)
    }

    return item;
 804cdb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804cdb7:	c9                   	leave  
 804cdb8:	c3                   	ret    

0804cdb9 <cJSON_CreateFalse>:

CJSON_PUBLIC(cJSON *) cJSON_CreateFalse(void)
{
 804cdb9:	55                   	push   %ebp
 804cdba:	89 e5                	mov    %esp,%ebp
 804cdbc:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804cdbf:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804cdc6:	e8 de d0 ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804cdcb:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(item)
 804cdce:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804cdd2:	74 0a                	je     804cdde <cJSON_CreateFalse+0x25>
    {
        item->type = cJSON_False;
 804cdd4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cdd7:	c7 40 0c 01 00 00 00 	movl   $0x1,0xc(%eax)
    }

    return item;
 804cdde:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804cde1:	c9                   	leave  
 804cde2:	c3                   	ret    

0804cde3 <cJSON_CreateBool>:

CJSON_PUBLIC(cJSON *) cJSON_CreateBool(cJSON_bool b)
{
 804cde3:	55                   	push   %ebp
 804cde4:	89 e5                	mov    %esp,%ebp
 804cde6:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804cde9:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804cdf0:	e8 b4 d0 ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804cdf5:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(item)
 804cdf8:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804cdfc:	74 18                	je     804ce16 <cJSON_CreateBool+0x33>
    {
        item->type = b ? cJSON_True : cJSON_False;
 804cdfe:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804ce02:	74 07                	je     804ce0b <cJSON_CreateBool+0x28>
 804ce04:	b8 02 00 00 00       	mov    $0x2,%eax
 804ce09:	eb 05                	jmp    804ce10 <cJSON_CreateBool+0x2d>
 804ce0b:	b8 01 00 00 00       	mov    $0x1,%eax
 804ce10:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804ce13:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    return item;
 804ce16:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804ce19:	c9                   	leave  
 804ce1a:	c3                   	ret    

0804ce1b <cJSON_CreateNumber>:

CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
{
 804ce1b:	55                   	push   %ebp
 804ce1c:	89 e5                	mov    %esp,%ebp
 804ce1e:	83 ec 38             	sub    $0x38,%esp
 804ce21:	8b 45 08             	mov    0x8(%ebp),%eax
 804ce24:	89 45 e0             	mov    %eax,-0x20(%ebp)
 804ce27:	8b 45 0c             	mov    0xc(%ebp),%eax
 804ce2a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    cJSON *item = cJSON_New_Item(&global_hooks);
 804ce2d:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804ce34:	e8 70 d0 ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804ce39:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(item)
 804ce3c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804ce40:	74 77                	je     804ceb9 <cJSON_CreateNumber+0x9e>
    {
        item->type = cJSON_Number;
 804ce42:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ce45:	c7 40 0c 08 00 00 00 	movl   $0x8,0xc(%eax)
        item->valuedouble = num;
 804ce4c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ce4f:	dd 45 e0             	fldl   -0x20(%ebp)
 804ce52:	dd 58 18             	fstpl  0x18(%eax)

        /* use saturation in case of overflow */
        if (num >= INT_MAX)
 804ce55:	dd 45 e0             	fldl   -0x20(%ebp)
 804ce58:	dd 05 90 e0 04 08    	fldl   0x804e090
 804ce5e:	d9 c9                	fxch   %st(1)
 804ce60:	df e9                	fucomip %st(1),%st
 804ce62:	dd d8                	fstp   %st(0)
 804ce64:	0f 93 c0             	setae  %al
 804ce67:	84 c0                	test   %al,%al
 804ce69:	74 0c                	je     804ce77 <cJSON_CreateNumber+0x5c>
        {
            item->valueint = INT_MAX;
 804ce6b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ce6e:	c7 40 14 ff ff ff 7f 	movl   $0x7fffffff,0x14(%eax)
 804ce75:	eb 42                	jmp    804ceb9 <cJSON_CreateNumber+0x9e>
        }
        else if (num <= INT_MIN)
 804ce77:	dd 45 e0             	fldl   -0x20(%ebp)
 804ce7a:	dd 05 98 e0 04 08    	fldl   0x804e098
 804ce80:	df e9                	fucomip %st(1),%st
 804ce82:	dd d8                	fstp   %st(0)
 804ce84:	0f 93 c0             	setae  %al
 804ce87:	84 c0                	test   %al,%al
 804ce89:	74 0c                	je     804ce97 <cJSON_CreateNumber+0x7c>
        {
            item->valueint = INT_MIN;
 804ce8b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ce8e:	c7 40 14 00 00 00 80 	movl   $0x80000000,0x14(%eax)
 804ce95:	eb 22                	jmp    804ceb9 <cJSON_CreateNumber+0x9e>
        }
        else
        {
            item->valueint = (int)num;
 804ce97:	dd 45 e0             	fldl   -0x20(%ebp)
 804ce9a:	d9 7d de             	fnstcw -0x22(%ebp)
 804ce9d:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
 804cea1:	b4 0c                	mov    $0xc,%ah
 804cea3:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
 804cea7:	d9 6d dc             	fldcw  -0x24(%ebp)
 804ceaa:	db 5d d8             	fistpl -0x28(%ebp)
 804cead:	d9 6d de             	fldcw  -0x22(%ebp)
 804ceb0:	8b 55 d8             	mov    -0x28(%ebp),%edx
 804ceb3:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804ceb6:	89 50 14             	mov    %edx,0x14(%eax)
        }
    }

    return item;
 804ceb9:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804cebc:	c9                   	leave  
 804cebd:	c3                   	ret    

0804cebe <cJSON_CreateString>:

CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
{
 804cebe:	55                   	push   %ebp
 804cebf:	89 e5                	mov    %esp,%ebp
 804cec1:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804cec4:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804cecb:	e8 d9 cf ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804ced0:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(item)
 804ced3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804ced7:	74 41                	je     804cf1a <cJSON_CreateString+0x5c>
    {
        item->type = cJSON_String;
 804ced9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cedc:	c7 40 0c 10 00 00 00 	movl   $0x10,0xc(%eax)
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
 804cee3:	8b 45 08             	mov    0x8(%ebp),%eax
 804cee6:	c7 44 24 04 04 04 05 	movl   $0x8050404,0x4(%esp)
 804ceed:	08 
 804ceee:	89 04 24             	mov    %eax,(%esp)
 804cef1:	e8 b3 ce ff ff       	call   8049da9 <_ZL12cJSON_strdupPKhPK14internal_hooks>
 804cef6:	89 c2                	mov    %eax,%edx
 804cef8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cefb:	89 50 10             	mov    %edx,0x10(%eax)
        if(!item->valuestring)
 804cefe:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cf01:	8b 40 10             	mov    0x10(%eax),%eax
 804cf04:	85 c0                	test   %eax,%eax
 804cf06:	75 12                	jne    804cf1a <cJSON_CreateString+0x5c>
        {
            cJSON_Delete(item);
 804cf08:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cf0b:	89 04 24             	mov    %eax,(%esp)
 804cf0e:	e8 d3 cf ff ff       	call   8049ee6 <cJSON_Delete>
            return NULL;
 804cf13:	b8 00 00 00 00       	mov    $0x0,%eax
 804cf18:	eb 03                	jmp    804cf1d <cJSON_CreateString+0x5f>
        }
    }

    return item;
 804cf1a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804cf1d:	c9                   	leave  
 804cf1e:	c3                   	ret    

0804cf1f <cJSON_CreateStringReference>:

CJSON_PUBLIC(cJSON *) cJSON_CreateStringReference(const char *string)
{
 804cf1f:	55                   	push   %ebp
 804cf20:	89 e5                	mov    %esp,%ebp
 804cf22:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804cf25:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804cf2c:	e8 78 cf ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804cf31:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (item != NULL)
 804cf34:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804cf38:	74 1d                	je     804cf57 <cJSON_CreateStringReference+0x38>
    {
        item->type = cJSON_String | cJSON_IsReference;
 804cf3a:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cf3d:	c7 40 0c 10 01 00 00 	movl   $0x110,0xc(%eax)
        item->valuestring = (char*)cast_away_const(string);
 804cf44:	8b 45 08             	mov    0x8(%ebp),%eax
 804cf47:	89 04 24             	mov    %eax,(%esp)
 804cf4a:	e8 59 f5 ff ff       	call   804c4a8 <_ZL15cast_away_constPKv>
 804cf4f:	89 c2                	mov    %eax,%edx
 804cf51:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cf54:	89 50 10             	mov    %edx,0x10(%eax)
    }

    return item;
 804cf57:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804cf5a:	c9                   	leave  
 804cf5b:	c3                   	ret    

0804cf5c <cJSON_CreateObjectReference>:

CJSON_PUBLIC(cJSON *) cJSON_CreateObjectReference(const cJSON *child)
{
 804cf5c:	55                   	push   %ebp
 804cf5d:	89 e5                	mov    %esp,%ebp
 804cf5f:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804cf62:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804cf69:	e8 3b cf ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804cf6e:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (item != NULL) {
 804cf71:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804cf75:	74 1d                	je     804cf94 <cJSON_CreateObjectReference+0x38>
        item->type = cJSON_Object | cJSON_IsReference;
 804cf77:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cf7a:	c7 40 0c 40 01 00 00 	movl   $0x140,0xc(%eax)
        item->child = (cJSON*)cast_away_const(child);
 804cf81:	8b 45 08             	mov    0x8(%ebp),%eax
 804cf84:	89 04 24             	mov    %eax,(%esp)
 804cf87:	e8 1c f5 ff ff       	call   804c4a8 <_ZL15cast_away_constPKv>
 804cf8c:	89 c2                	mov    %eax,%edx
 804cf8e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cf91:	89 50 08             	mov    %edx,0x8(%eax)
    }

    return item;
 804cf94:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804cf97:	c9                   	leave  
 804cf98:	c3                   	ret    

0804cf99 <cJSON_CreateArrayReference>:

CJSON_PUBLIC(cJSON *) cJSON_CreateArrayReference(const cJSON *child) {
 804cf99:	55                   	push   %ebp
 804cf9a:	89 e5                	mov    %esp,%ebp
 804cf9c:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804cf9f:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804cfa6:	e8 fe ce ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804cfab:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (item != NULL) {
 804cfae:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804cfb2:	74 1d                	je     804cfd1 <cJSON_CreateArrayReference+0x38>
        item->type = cJSON_Array | cJSON_IsReference;
 804cfb4:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cfb7:	c7 40 0c 20 01 00 00 	movl   $0x120,0xc(%eax)
        item->child = (cJSON*)cast_away_const(child);
 804cfbe:	8b 45 08             	mov    0x8(%ebp),%eax
 804cfc1:	89 04 24             	mov    %eax,(%esp)
 804cfc4:	e8 df f4 ff ff       	call   804c4a8 <_ZL15cast_away_constPKv>
 804cfc9:	89 c2                	mov    %eax,%edx
 804cfcb:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cfce:	89 50 08             	mov    %edx,0x8(%eax)
    }

    return item;
 804cfd1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804cfd4:	c9                   	leave  
 804cfd5:	c3                   	ret    

0804cfd6 <cJSON_CreateRaw>:

CJSON_PUBLIC(cJSON *) cJSON_CreateRaw(const char *raw)
{
 804cfd6:	55                   	push   %ebp
 804cfd7:	89 e5                	mov    %esp,%ebp
 804cfd9:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804cfdc:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804cfe3:	e8 c1 ce ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804cfe8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(item)
 804cfeb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804cfef:	74 41                	je     804d032 <cJSON_CreateRaw+0x5c>
    {
        item->type = cJSON_Raw;
 804cff1:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804cff4:	c7 40 0c 80 00 00 00 	movl   $0x80,0xc(%eax)
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)raw, &global_hooks);
 804cffb:	8b 45 08             	mov    0x8(%ebp),%eax
 804cffe:	c7 44 24 04 04 04 05 	movl   $0x8050404,0x4(%esp)
 804d005:	08 
 804d006:	89 04 24             	mov    %eax,(%esp)
 804d009:	e8 9b cd ff ff       	call   8049da9 <_ZL12cJSON_strdupPKhPK14internal_hooks>
 804d00e:	89 c2                	mov    %eax,%edx
 804d010:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d013:	89 50 10             	mov    %edx,0x10(%eax)
        if(!item->valuestring)
 804d016:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d019:	8b 40 10             	mov    0x10(%eax),%eax
 804d01c:	85 c0                	test   %eax,%eax
 804d01e:	75 12                	jne    804d032 <cJSON_CreateRaw+0x5c>
        {
            cJSON_Delete(item);
 804d020:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d023:	89 04 24             	mov    %eax,(%esp)
 804d026:	e8 bb ce ff ff       	call   8049ee6 <cJSON_Delete>
            return NULL;
 804d02b:	b8 00 00 00 00       	mov    $0x0,%eax
 804d030:	eb 03                	jmp    804d035 <cJSON_CreateRaw+0x5f>
        }
    }

    return item;
 804d032:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d035:	c9                   	leave  
 804d036:	c3                   	ret    

0804d037 <cJSON_CreateArray>:

CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
{
 804d037:	55                   	push   %ebp
 804d038:	89 e5                	mov    %esp,%ebp
 804d03a:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804d03d:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804d044:	e8 60 ce ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804d049:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if(item)
 804d04c:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804d050:	74 0a                	je     804d05c <cJSON_CreateArray+0x25>
    {
        item->type=cJSON_Array;
 804d052:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d055:	c7 40 0c 20 00 00 00 	movl   $0x20,0xc(%eax)
    }

    return item;
 804d05c:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d05f:	c9                   	leave  
 804d060:	c3                   	ret    

0804d061 <cJSON_CreateObject>:

CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
{
 804d061:	55                   	push   %ebp
 804d062:	89 e5                	mov    %esp,%ebp
 804d064:	83 ec 28             	sub    $0x28,%esp
    cJSON *item = cJSON_New_Item(&global_hooks);
 804d067:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804d06e:	e8 36 ce ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804d073:	89 45 f4             	mov    %eax,-0xc(%ebp)
    if (item)
 804d076:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804d07a:	74 0a                	je     804d086 <cJSON_CreateObject+0x25>
    {
        item->type = cJSON_Object;
 804d07c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d07f:	c7 40 0c 40 00 00 00 	movl   $0x40,0xc(%eax)
    }

    return item;
 804d086:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d089:	c9                   	leave  
 804d08a:	c3                   	ret    

0804d08b <cJSON_CreateIntArray>:

/* Create Arrays: */
CJSON_PUBLIC(cJSON *) cJSON_CreateIntArray(const int *numbers, int count)
{
 804d08b:	55                   	push   %ebp
 804d08c:	89 e5                	mov    %esp,%ebp
 804d08e:	83 ec 38             	sub    $0x38,%esp
    size_t i = 0;
 804d091:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    cJSON *n = NULL;
 804d098:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    cJSON *p = NULL;
 804d09f:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cJSON *a = NULL;
 804d0a6:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if ((count < 0) || (numbers == NULL))
 804d0ad:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804d0b1:	78 06                	js     804d0b9 <cJSON_CreateIntArray+0x2e>
 804d0b3:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d0b7:	75 0a                	jne    804d0c3 <cJSON_CreateIntArray+0x38>
    {
        return NULL;
 804d0b9:	b8 00 00 00 00       	mov    $0x0,%eax
 804d0be:	e9 93 00 00 00       	jmp    804d156 <cJSON_CreateIntArray+0xcb>
    }

    a = cJSON_CreateArray();
 804d0c3:	e8 6f ff ff ff       	call   804d037 <cJSON_CreateArray>
 804d0c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
    for(i = 0; a && (i < (size_t)count); i++)
 804d0cb:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 804d0d2:	eb 61                	jmp    804d135 <cJSON_CreateIntArray+0xaa>
    {
        n = cJSON_CreateNumber(numbers[i]);
 804d0d4:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d0d7:	c1 e0 02             	shl    $0x2,%eax
 804d0da:	03 45 08             	add    0x8(%ebp),%eax
 804d0dd:	8b 00                	mov    (%eax),%eax
 804d0df:	89 45 e4             	mov    %eax,-0x1c(%ebp)
 804d0e2:	db 45 e4             	fildl  -0x1c(%ebp)
 804d0e5:	dd 1c 24             	fstpl  (%esp)
 804d0e8:	e8 2e fd ff ff       	call   804ce1b <cJSON_CreateNumber>
 804d0ed:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if (!n)
 804d0f0:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804d0f4:	75 12                	jne    804d108 <cJSON_CreateIntArray+0x7d>
        {
            cJSON_Delete(a);
 804d0f6:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d0f9:	89 04 24             	mov    %eax,(%esp)
 804d0fc:	e8 e5 cd ff ff       	call   8049ee6 <cJSON_Delete>
            return NULL;
 804d101:	b8 00 00 00 00       	mov    $0x0,%eax
 804d106:	eb 4e                	jmp    804d156 <cJSON_CreateIntArray+0xcb>
        }
        if(!i)
 804d108:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804d10c:	75 0b                	jne    804d119 <cJSON_CreateIntArray+0x8e>
        {
            a->child = n;
 804d10e:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d111:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804d114:	89 50 08             	mov    %edx,0x8(%eax)
 804d117:	eb 12                	jmp    804d12b <cJSON_CreateIntArray+0xa0>
        }
        else
        {
            suffix_object(p, n);
 804d119:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d11c:	89 44 24 04          	mov    %eax,0x4(%esp)
 804d120:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d123:	89 04 24             	mov    %eax,(%esp)
 804d126:	e8 60 f2 ff ff       	call   804c38b <_ZL13suffix_objectP5cJSONS0_>
        }
        p = n;
 804d12b:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d12e:	89 45 f0             	mov    %eax,-0x10(%ebp)
    {
        return NULL;
    }

    a = cJSON_CreateArray();
    for(i = 0; a && (i < (size_t)count); i++)
 804d131:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
 804d135:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804d139:	74 0f                	je     804d14a <cJSON_CreateIntArray+0xbf>
 804d13b:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d13e:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 804d141:	76 07                	jbe    804d14a <cJSON_CreateIntArray+0xbf>
 804d143:	b8 01 00 00 00       	mov    $0x1,%eax
 804d148:	eb 05                	jmp    804d14f <cJSON_CreateIntArray+0xc4>
 804d14a:	b8 00 00 00 00       	mov    $0x0,%eax
 804d14f:	84 c0                	test   %al,%al
 804d151:	75 81                	jne    804d0d4 <cJSON_CreateIntArray+0x49>
            suffix_object(p, n);
        }
        p = n;
    }

    return a;
 804d153:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d156:	c9                   	leave  
 804d157:	c3                   	ret    

0804d158 <cJSON_CreateFloatArray>:

CJSON_PUBLIC(cJSON *) cJSON_CreateFloatArray(const float *numbers, int count)
{
 804d158:	55                   	push   %ebp
 804d159:	89 e5                	mov    %esp,%ebp
 804d15b:	83 ec 28             	sub    $0x28,%esp
    size_t i = 0;
 804d15e:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    cJSON *n = NULL;
 804d165:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    cJSON *p = NULL;
 804d16c:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cJSON *a = NULL;
 804d173:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if ((count < 0) || (numbers == NULL))
 804d17a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804d17e:	78 06                	js     804d186 <cJSON_CreateFloatArray+0x2e>
 804d180:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d184:	75 0a                	jne    804d190 <cJSON_CreateFloatArray+0x38>
    {
        return NULL;
 804d186:	b8 00 00 00 00       	mov    $0x0,%eax
 804d18b:	e9 8d 00 00 00       	jmp    804d21d <cJSON_CreateFloatArray+0xc5>
    }

    a = cJSON_CreateArray();
 804d190:	e8 a2 fe ff ff       	call   804d037 <cJSON_CreateArray>
 804d195:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(i = 0; a && (i < (size_t)count); i++)
 804d198:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 804d19f:	eb 5b                	jmp    804d1fc <cJSON_CreateFloatArray+0xa4>
    {
        n = cJSON_CreateNumber((double)numbers[i]);
 804d1a1:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d1a4:	c1 e0 02             	shl    $0x2,%eax
 804d1a7:	03 45 08             	add    0x8(%ebp),%eax
 804d1aa:	d9 00                	flds   (%eax)
 804d1ac:	dd 1c 24             	fstpl  (%esp)
 804d1af:	e8 67 fc ff ff       	call   804ce1b <cJSON_CreateNumber>
 804d1b4:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(!n)
 804d1b7:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804d1bb:	75 12                	jne    804d1cf <cJSON_CreateFloatArray+0x77>
        {
            cJSON_Delete(a);
 804d1bd:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d1c0:	89 04 24             	mov    %eax,(%esp)
 804d1c3:	e8 1e cd ff ff       	call   8049ee6 <cJSON_Delete>
            return NULL;
 804d1c8:	b8 00 00 00 00       	mov    $0x0,%eax
 804d1cd:	eb 4e                	jmp    804d21d <cJSON_CreateFloatArray+0xc5>
        }
        if(!i)
 804d1cf:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804d1d3:	75 0b                	jne    804d1e0 <cJSON_CreateFloatArray+0x88>
        {
            a->child = n;
 804d1d5:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d1d8:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804d1db:	89 50 08             	mov    %edx,0x8(%eax)
 804d1de:	eb 12                	jmp    804d1f2 <cJSON_CreateFloatArray+0x9a>
        }
        else
        {
            suffix_object(p, n);
 804d1e0:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d1e3:	89 44 24 04          	mov    %eax,0x4(%esp)
 804d1e7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d1ea:	89 04 24             	mov    %eax,(%esp)
 804d1ed:	e8 99 f1 ff ff       	call   804c38b <_ZL13suffix_objectP5cJSONS0_>
        }
        p = n;
 804d1f2:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d1f5:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0; a && (i < (size_t)count); i++)
 804d1f8:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
 804d1fc:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804d200:	74 0f                	je     804d211 <cJSON_CreateFloatArray+0xb9>
 804d202:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d205:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 804d208:	76 07                	jbe    804d211 <cJSON_CreateFloatArray+0xb9>
 804d20a:	b8 01 00 00 00       	mov    $0x1,%eax
 804d20f:	eb 05                	jmp    804d216 <cJSON_CreateFloatArray+0xbe>
 804d211:	b8 00 00 00 00       	mov    $0x0,%eax
 804d216:	84 c0                	test   %al,%al
 804d218:	75 87                	jne    804d1a1 <cJSON_CreateFloatArray+0x49>
            suffix_object(p, n);
        }
        p = n;
    }

    return a;
 804d21a:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d21d:	c9                   	leave  
 804d21e:	c3                   	ret    

0804d21f <cJSON_CreateDoubleArray>:

CJSON_PUBLIC(cJSON *) cJSON_CreateDoubleArray(const double *numbers, int count)
{
 804d21f:	55                   	push   %ebp
 804d220:	89 e5                	mov    %esp,%ebp
 804d222:	83 ec 28             	sub    $0x28,%esp
    size_t i = 0;
 804d225:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    cJSON *n = NULL;
 804d22c:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    cJSON *p = NULL;
 804d233:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cJSON *a = NULL;
 804d23a:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if ((count < 0) || (numbers == NULL))
 804d241:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804d245:	78 06                	js     804d24d <cJSON_CreateDoubleArray+0x2e>
 804d247:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d24b:	75 0a                	jne    804d257 <cJSON_CreateDoubleArray+0x38>
    {
        return NULL;
 804d24d:	b8 00 00 00 00       	mov    $0x0,%eax
 804d252:	e9 8d 00 00 00       	jmp    804d2e4 <cJSON_CreateDoubleArray+0xc5>
    }

    a = cJSON_CreateArray();
 804d257:	e8 db fd ff ff       	call   804d037 <cJSON_CreateArray>
 804d25c:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for(i = 0;a && (i < (size_t)count); i++)
 804d25f:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 804d266:	eb 5b                	jmp    804d2c3 <cJSON_CreateDoubleArray+0xa4>
    {
        n = cJSON_CreateNumber(numbers[i]);
 804d268:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d26b:	c1 e0 03             	shl    $0x3,%eax
 804d26e:	03 45 08             	add    0x8(%ebp),%eax
 804d271:	dd 00                	fldl   (%eax)
 804d273:	dd 1c 24             	fstpl  (%esp)
 804d276:	e8 a0 fb ff ff       	call   804ce1b <cJSON_CreateNumber>
 804d27b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(!n)
 804d27e:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804d282:	75 12                	jne    804d296 <cJSON_CreateDoubleArray+0x77>
        {
            cJSON_Delete(a);
 804d284:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d287:	89 04 24             	mov    %eax,(%esp)
 804d28a:	e8 57 cc ff ff       	call   8049ee6 <cJSON_Delete>
            return NULL;
 804d28f:	b8 00 00 00 00       	mov    $0x0,%eax
 804d294:	eb 4e                	jmp    804d2e4 <cJSON_CreateDoubleArray+0xc5>
        }
        if(!i)
 804d296:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804d29a:	75 0b                	jne    804d2a7 <cJSON_CreateDoubleArray+0x88>
        {
            a->child = n;
 804d29c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d29f:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804d2a2:	89 50 08             	mov    %edx,0x8(%eax)
 804d2a5:	eb 12                	jmp    804d2b9 <cJSON_CreateDoubleArray+0x9a>
        }
        else
        {
            suffix_object(p, n);
 804d2a7:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d2aa:	89 44 24 04          	mov    %eax,0x4(%esp)
 804d2ae:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d2b1:	89 04 24             	mov    %eax,(%esp)
 804d2b4:	e8 d2 f0 ff ff       	call   804c38b <_ZL13suffix_objectP5cJSONS0_>
        }
        p = n;
 804d2b9:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d2bc:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return NULL;
    }

    a = cJSON_CreateArray();

    for(i = 0;a && (i < (size_t)count); i++)
 804d2bf:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
 804d2c3:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804d2c7:	74 0f                	je     804d2d8 <cJSON_CreateDoubleArray+0xb9>
 804d2c9:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d2cc:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 804d2cf:	76 07                	jbe    804d2d8 <cJSON_CreateDoubleArray+0xb9>
 804d2d1:	b8 01 00 00 00       	mov    $0x1,%eax
 804d2d6:	eb 05                	jmp    804d2dd <cJSON_CreateDoubleArray+0xbe>
 804d2d8:	b8 00 00 00 00       	mov    $0x0,%eax
 804d2dd:	84 c0                	test   %al,%al
 804d2df:	75 87                	jne    804d268 <cJSON_CreateDoubleArray+0x49>
            suffix_object(p, n);
        }
        p = n;
    }

    return a;
 804d2e1:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d2e4:	c9                   	leave  
 804d2e5:	c3                   	ret    

0804d2e6 <cJSON_CreateStringArray>:

CJSON_PUBLIC(cJSON *) cJSON_CreateStringArray(const char **strings, int count)
{
 804d2e6:	55                   	push   %ebp
 804d2e7:	89 e5                	mov    %esp,%ebp
 804d2e9:	83 ec 28             	sub    $0x28,%esp
    size_t i = 0;
 804d2ec:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    cJSON *n = NULL;
 804d2f3:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    cJSON *p = NULL;
 804d2fa:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cJSON *a = NULL;
 804d301:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    if ((count < 0) || (strings == NULL))
 804d308:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804d30c:	78 06                	js     804d314 <cJSON_CreateStringArray+0x2e>
 804d30e:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d312:	75 0a                	jne    804d31e <cJSON_CreateStringArray+0x38>
    {
        return NULL;
 804d314:	b8 00 00 00 00       	mov    $0x0,%eax
 804d319:	e9 8d 00 00 00       	jmp    804d3ab <cJSON_CreateStringArray+0xc5>
    }

    a = cJSON_CreateArray();
 804d31e:	e8 14 fd ff ff       	call   804d037 <cJSON_CreateArray>
 804d323:	89 45 f4             	mov    %eax,-0xc(%ebp)

    for (i = 0; a && (i < (size_t)count); i++)
 804d326:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
 804d32d:	eb 5b                	jmp    804d38a <cJSON_CreateStringArray+0xa4>
    {
        n = cJSON_CreateString(strings[i]);
 804d32f:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d332:	c1 e0 02             	shl    $0x2,%eax
 804d335:	03 45 08             	add    0x8(%ebp),%eax
 804d338:	8b 00                	mov    (%eax),%eax
 804d33a:	89 04 24             	mov    %eax,(%esp)
 804d33d:	e8 7c fb ff ff       	call   804cebe <cJSON_CreateString>
 804d342:	89 45 ec             	mov    %eax,-0x14(%ebp)
        if(!n)
 804d345:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804d349:	75 12                	jne    804d35d <cJSON_CreateStringArray+0x77>
        {
            cJSON_Delete(a);
 804d34b:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d34e:	89 04 24             	mov    %eax,(%esp)
 804d351:	e8 90 cb ff ff       	call   8049ee6 <cJSON_Delete>
            return NULL;
 804d356:	b8 00 00 00 00       	mov    $0x0,%eax
 804d35b:	eb 4e                	jmp    804d3ab <cJSON_CreateStringArray+0xc5>
        }
        if(!i)
 804d35d:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804d361:	75 0b                	jne    804d36e <cJSON_CreateStringArray+0x88>
        {
            a->child = n;
 804d363:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d366:	8b 55 ec             	mov    -0x14(%ebp),%edx
 804d369:	89 50 08             	mov    %edx,0x8(%eax)
 804d36c:	eb 12                	jmp    804d380 <cJSON_CreateStringArray+0x9a>
        }
        else
        {
            suffix_object(p,n);
 804d36e:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d371:	89 44 24 04          	mov    %eax,0x4(%esp)
 804d375:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d378:	89 04 24             	mov    %eax,(%esp)
 804d37b:	e8 0b f0 ff ff       	call   804c38b <_ZL13suffix_objectP5cJSONS0_>
        }
        p = n;
 804d380:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d383:	89 45 f0             	mov    %eax,-0x10(%ebp)
        return NULL;
    }

    a = cJSON_CreateArray();

    for (i = 0; a && (i < (size_t)count); i++)
 804d386:	83 45 e8 01          	addl   $0x1,-0x18(%ebp)
 804d38a:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804d38e:	74 0f                	je     804d39f <cJSON_CreateStringArray+0xb9>
 804d390:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d393:	3b 45 e8             	cmp    -0x18(%ebp),%eax
 804d396:	76 07                	jbe    804d39f <cJSON_CreateStringArray+0xb9>
 804d398:	b8 01 00 00 00       	mov    $0x1,%eax
 804d39d:	eb 05                	jmp    804d3a4 <cJSON_CreateStringArray+0xbe>
 804d39f:	b8 00 00 00 00       	mov    $0x0,%eax
 804d3a4:	84 c0                	test   %al,%al
 804d3a6:	75 87                	jne    804d32f <cJSON_CreateStringArray+0x49>
            suffix_object(p,n);
        }
        p = n;
    }

    return a;
 804d3a8:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
 804d3ab:	c9                   	leave  
 804d3ac:	c3                   	ret    

0804d3ad <cJSON_Duplicate>:

/* Duplication */
CJSON_PUBLIC(cJSON *) cJSON_Duplicate(const cJSON *item, cJSON_bool recurse)
{
 804d3ad:	55                   	push   %ebp
 804d3ae:	89 e5                	mov    %esp,%ebp
 804d3b0:	83 ec 28             	sub    $0x28,%esp
    cJSON *newitem = NULL;
 804d3b3:	c7 45 e8 00 00 00 00 	movl   $0x0,-0x18(%ebp)
    cJSON *child = NULL;
 804d3ba:	c7 45 ec 00 00 00 00 	movl   $0x0,-0x14(%ebp)
    cJSON *next = NULL;
 804d3c1:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
    cJSON *newchild = NULL;
 804d3c8:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

    /* Bail on bad ptr */
    if (!item)
 804d3cf:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d3d3:	0f 84 3e 01 00 00    	je     804d517 <cJSON_Duplicate+0x16a>
    {
        goto fail;
    }
    /* Create new item */
    newitem = cJSON_New_Item(&global_hooks);
 804d3d9:	c7 04 24 04 04 05 08 	movl   $0x8050404,(%esp)
 804d3e0:	e8 c4 ca ff ff       	call   8049ea9 <_ZL14cJSON_New_ItemPK14internal_hooks>
 804d3e5:	89 45 e8             	mov    %eax,-0x18(%ebp)
    if (!newitem)
 804d3e8:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804d3ec:	0f 84 28 01 00 00    	je     804d51a <cJSON_Duplicate+0x16d>
    {
        goto fail;
    }
    /* Copy over all vars */
    newitem->type = item->type & (~cJSON_IsReference);
 804d3f2:	8b 45 08             	mov    0x8(%ebp),%eax
 804d3f5:	8b 40 0c             	mov    0xc(%eax),%eax
 804d3f8:	89 c2                	mov    %eax,%edx
 804d3fa:	80 e6 fe             	and    $0xfe,%dh
 804d3fd:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d400:	89 50 0c             	mov    %edx,0xc(%eax)
    newitem->valueint = item->valueint;
 804d403:	8b 45 08             	mov    0x8(%ebp),%eax
 804d406:	8b 50 14             	mov    0x14(%eax),%edx
 804d409:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d40c:	89 50 14             	mov    %edx,0x14(%eax)
    newitem->valuedouble = item->valuedouble;
 804d40f:	8b 45 08             	mov    0x8(%ebp),%eax
 804d412:	dd 40 18             	fldl   0x18(%eax)
 804d415:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d418:	dd 58 18             	fstpl  0x18(%eax)
    if (item->valuestring)
 804d41b:	8b 45 08             	mov    0x8(%ebp),%eax
 804d41e:	8b 40 10             	mov    0x10(%eax),%eax
 804d421:	85 c0                	test   %eax,%eax
 804d423:	74 2c                	je     804d451 <cJSON_Duplicate+0xa4>
    {
        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
 804d425:	8b 45 08             	mov    0x8(%ebp),%eax
 804d428:	8b 40 10             	mov    0x10(%eax),%eax
 804d42b:	c7 44 24 04 04 04 05 	movl   $0x8050404,0x4(%esp)
 804d432:	08 
 804d433:	89 04 24             	mov    %eax,(%esp)
 804d436:	e8 6e c9 ff ff       	call   8049da9 <_ZL12cJSON_strdupPKhPK14internal_hooks>
 804d43b:	89 c2                	mov    %eax,%edx
 804d43d:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d440:	89 50 10             	mov    %edx,0x10(%eax)
        if (!newitem->valuestring)
 804d443:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d446:	8b 40 10             	mov    0x10(%eax),%eax
 804d449:	85 c0                	test   %eax,%eax
 804d44b:	0f 84 cc 00 00 00    	je     804d51d <cJSON_Duplicate+0x170>
        {
            goto fail;
        }
    }
    if (item->string)
 804d451:	8b 45 08             	mov    0x8(%ebp),%eax
 804d454:	8b 40 20             	mov    0x20(%eax),%eax
 804d457:	85 c0                	test   %eax,%eax
 804d459:	74 41                	je     804d49c <cJSON_Duplicate+0xef>
    {
        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
 804d45b:	8b 45 08             	mov    0x8(%ebp),%eax
 804d45e:	8b 40 0c             	mov    0xc(%eax),%eax
 804d461:	25 00 02 00 00       	and    $0x200,%eax
 804d466:	85 c0                	test   %eax,%eax
 804d468:	74 08                	je     804d472 <cJSON_Duplicate+0xc5>
 804d46a:	8b 45 08             	mov    0x8(%ebp),%eax
 804d46d:	8b 40 20             	mov    0x20(%eax),%eax
 804d470:	eb 16                	jmp    804d488 <cJSON_Duplicate+0xdb>
 804d472:	8b 45 08             	mov    0x8(%ebp),%eax
 804d475:	8b 40 20             	mov    0x20(%eax),%eax
 804d478:	c7 44 24 04 04 04 05 	movl   $0x8050404,0x4(%esp)
 804d47f:	08 
 804d480:	89 04 24             	mov    %eax,(%esp)
 804d483:	e8 21 c9 ff ff       	call   8049da9 <_ZL12cJSON_strdupPKhPK14internal_hooks>
 804d488:	8b 55 e8             	mov    -0x18(%ebp),%edx
 804d48b:	89 42 20             	mov    %eax,0x20(%edx)
        if (!newitem->string)
 804d48e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d491:	8b 40 20             	mov    0x20(%eax),%eax
 804d494:	85 c0                	test   %eax,%eax
 804d496:	0f 84 84 00 00 00    	je     804d520 <cJSON_Duplicate+0x173>
        {
            goto fail;
        }
    }
    /* If non-recursive, then we're done! */
    if (!recurse)
 804d49c:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804d4a0:	75 08                	jne    804d4aa <cJSON_Duplicate+0xfd>
    {
        return newitem;
 804d4a2:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d4a5:	e9 90 00 00 00       	jmp    804d53a <cJSON_Duplicate+0x18d>
    }
    /* Walk the ->next chain for the child. */
    child = item->child;
 804d4aa:	8b 45 08             	mov    0x8(%ebp),%eax
 804d4ad:	8b 40 08             	mov    0x8(%eax),%eax
 804d4b0:	89 45 ec             	mov    %eax,-0x14(%ebp)
    while (child != NULL)
 804d4b3:	eb 52                	jmp    804d507 <cJSON_Duplicate+0x15a>
    {
        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
 804d4b5:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
 804d4bc:	00 
 804d4bd:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d4c0:	89 04 24             	mov    %eax,(%esp)
 804d4c3:	e8 e5 fe ff ff       	call   804d3ad <cJSON_Duplicate>
 804d4c8:	89 45 f4             	mov    %eax,-0xc(%ebp)
        if (!newchild)
 804d4cb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804d4cf:	74 52                	je     804d523 <cJSON_Duplicate+0x176>
        {
            goto fail;
        }
        if (next != NULL)
 804d4d1:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804d4d5:	74 19                	je     804d4f0 <cJSON_Duplicate+0x143>
        {
            /* If newitem->child already set, then crosswire ->prev and ->next and move on */
            next->next = newchild;
 804d4d7:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804d4da:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804d4dd:	89 10                	mov    %edx,(%eax)
            newchild->prev = next;
 804d4df:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d4e2:	8b 55 f0             	mov    -0x10(%ebp),%edx
 804d4e5:	89 50 04             	mov    %edx,0x4(%eax)
            next = newchild;
 804d4e8:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d4eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804d4ee:	eb 0f                	jmp    804d4ff <cJSON_Duplicate+0x152>
        }
        else
        {
            /* Set newitem->child and move to it */
            newitem->child = newchild;
 804d4f0:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d4f3:	8b 55 f4             	mov    -0xc(%ebp),%edx
 804d4f6:	89 50 08             	mov    %edx,0x8(%eax)
            next = newchild;
 804d4f9:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804d4fc:	89 45 f0             	mov    %eax,-0x10(%ebp)
        }
        child = child->next;
 804d4ff:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804d502:	8b 00                	mov    (%eax),%eax
 804d504:	89 45 ec             	mov    %eax,-0x14(%ebp)
    {
        return newitem;
    }
    /* Walk the ->next chain for the child. */
    child = item->child;
    while (child != NULL)
 804d507:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804d50b:	0f 95 c0             	setne  %al
 804d50e:	84 c0                	test   %al,%al
 804d510:	75 a3                	jne    804d4b5 <cJSON_Duplicate+0x108>
            next = newchild;
        }
        child = child->next;
    }

    return newitem;
 804d512:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d515:	eb 23                	jmp    804d53a <cJSON_Duplicate+0x18d>
    cJSON *newchild = NULL;

    /* Bail on bad ptr */
    if (!item)
    {
        goto fail;
 804d517:	90                   	nop
 804d518:	eb 0a                	jmp    804d524 <cJSON_Duplicate+0x177>
    }
    /* Create new item */
    newitem = cJSON_New_Item(&global_hooks);
    if (!newitem)
    {
        goto fail;
 804d51a:	90                   	nop
 804d51b:	eb 07                	jmp    804d524 <cJSON_Duplicate+0x177>
    if (item->valuestring)
    {
        newitem->valuestring = (char*)cJSON_strdup((unsigned char*)item->valuestring, &global_hooks);
        if (!newitem->valuestring)
        {
            goto fail;
 804d51d:	90                   	nop
 804d51e:	eb 04                	jmp    804d524 <cJSON_Duplicate+0x177>
    if (item->string)
    {
        newitem->string = (item->type&cJSON_StringIsConst) ? item->string : (char*)cJSON_strdup((unsigned char*)item->string, &global_hooks);
        if (!newitem->string)
        {
            goto fail;
 804d520:	90                   	nop
 804d521:	eb 01                	jmp    804d524 <cJSON_Duplicate+0x177>
    while (child != NULL)
    {
        newchild = cJSON_Duplicate(child, true); /* Duplicate (with recurse) each item in the ->next chain */
        if (!newchild)
        {
            goto fail;
 804d523:	90                   	nop
    }

    return newitem;

fail:
    if (newitem != NULL)
 804d524:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804d528:	74 0b                	je     804d535 <cJSON_Duplicate+0x188>
    {
        cJSON_Delete(newitem);
 804d52a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804d52d:	89 04 24             	mov    %eax,(%esp)
 804d530:	e8 b1 c9 ff ff       	call   8049ee6 <cJSON_Delete>
    }

    return NULL;
 804d535:	b8 00 00 00 00       	mov    $0x0,%eax
}
 804d53a:	c9                   	leave  
 804d53b:	c3                   	ret    

0804d53c <cJSON_Minify>:

CJSON_PUBLIC(void) cJSON_Minify(char *json)
{
 804d53c:	55                   	push   %ebp
 804d53d:	89 e5                	mov    %esp,%ebp
 804d53f:	83 ec 10             	sub    $0x10,%esp
    unsigned char *into = (unsigned char*)json;
 804d542:	8b 45 08             	mov    0x8(%ebp),%eax
 804d545:	89 45 fc             	mov    %eax,-0x4(%ebp)

    if (json == NULL)
 804d548:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d54c:	0f 85 97 01 00 00    	jne    804d6e9 <cJSON_Minify+0x1ad>
    {
        return;
 804d552:	e9 ab 01 00 00       	jmp    804d702 <cJSON_Minify+0x1c6>
    }

    while (*json)
    {
        if (*json == ' ')
 804d557:	8b 45 08             	mov    0x8(%ebp),%eax
 804d55a:	0f b6 00             	movzbl (%eax),%eax
 804d55d:	3c 20                	cmp    $0x20,%al
 804d55f:	75 09                	jne    804d56a <cJSON_Minify+0x2e>
        {
            json++;
 804d561:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804d565:	e9 7f 01 00 00       	jmp    804d6e9 <cJSON_Minify+0x1ad>
        }
        else if (*json == '\t')
 804d56a:	8b 45 08             	mov    0x8(%ebp),%eax
 804d56d:	0f b6 00             	movzbl (%eax),%eax
 804d570:	3c 09                	cmp    $0x9,%al
 804d572:	75 09                	jne    804d57d <cJSON_Minify+0x41>
        {
            /* Whitespace characters. */
            json++;
 804d574:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804d578:	e9 6c 01 00 00       	jmp    804d6e9 <cJSON_Minify+0x1ad>
        }
        else if (*json == '\r')
 804d57d:	8b 45 08             	mov    0x8(%ebp),%eax
 804d580:	0f b6 00             	movzbl (%eax),%eax
 804d583:	3c 0d                	cmp    $0xd,%al
 804d585:	75 09                	jne    804d590 <cJSON_Minify+0x54>
        {
            json++;
 804d587:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804d58b:	e9 59 01 00 00       	jmp    804d6e9 <cJSON_Minify+0x1ad>
        }
        else if (*json=='\n')
 804d590:	8b 45 08             	mov    0x8(%ebp),%eax
 804d593:	0f b6 00             	movzbl (%eax),%eax
 804d596:	3c 0a                	cmp    $0xa,%al
 804d598:	75 09                	jne    804d5a3 <cJSON_Minify+0x67>
        {
            json++;
 804d59a:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804d59e:	e9 46 01 00 00       	jmp    804d6e9 <cJSON_Minify+0x1ad>
        }
        else if ((*json == '/') && (json[1] == '/'))
 804d5a3:	8b 45 08             	mov    0x8(%ebp),%eax
 804d5a6:	0f b6 00             	movzbl (%eax),%eax
 804d5a9:	3c 2f                	cmp    $0x2f,%al
 804d5ab:	75 3c                	jne    804d5e9 <cJSON_Minify+0xad>
 804d5ad:	8b 45 08             	mov    0x8(%ebp),%eax
 804d5b0:	83 c0 01             	add    $0x1,%eax
 804d5b3:	0f b6 00             	movzbl (%eax),%eax
 804d5b6:	3c 2f                	cmp    $0x2f,%al
 804d5b8:	75 2f                	jne    804d5e9 <cJSON_Minify+0xad>
        {
            /* double-slash comments, to end of line. */
            while (*json && (*json != '\n'))
 804d5ba:	eb 04                	jmp    804d5c0 <cJSON_Minify+0x84>
            {
                json++;
 804d5bc:	83 45 08 01          	addl   $0x1,0x8(%ebp)
            json++;
        }
        else if ((*json == '/') && (json[1] == '/'))
        {
            /* double-slash comments, to end of line. */
            while (*json && (*json != '\n'))
 804d5c0:	8b 45 08             	mov    0x8(%ebp),%eax
 804d5c3:	0f b6 00             	movzbl (%eax),%eax
 804d5c6:	84 c0                	test   %al,%al
 804d5c8:	74 11                	je     804d5db <cJSON_Minify+0x9f>
 804d5ca:	8b 45 08             	mov    0x8(%ebp),%eax
 804d5cd:	0f b6 00             	movzbl (%eax),%eax
 804d5d0:	3c 0a                	cmp    $0xa,%al
 804d5d2:	74 07                	je     804d5db <cJSON_Minify+0x9f>
 804d5d4:	b8 01 00 00 00       	mov    $0x1,%eax
 804d5d9:	eb 05                	jmp    804d5e0 <cJSON_Minify+0xa4>
 804d5db:	b8 00 00 00 00       	mov    $0x0,%eax
 804d5e0:	84 c0                	test   %al,%al
 804d5e2:	75 d8                	jne    804d5bc <cJSON_Minify+0x80>
        }
        else if (*json=='\n')
        {
            json++;
        }
        else if ((*json == '/') && (json[1] == '/'))
 804d5e4:	e9 00 01 00 00       	jmp    804d6e9 <cJSON_Minify+0x1ad>
            while (*json && (*json != '\n'))
            {
                json++;
            }
        }
        else if ((*json == '/') && (json[1] == '*'))
 804d5e9:	8b 45 08             	mov    0x8(%ebp),%eax
 804d5ec:	0f b6 00             	movzbl (%eax),%eax
 804d5ef:	3c 2f                	cmp    $0x2f,%al
 804d5f1:	75 4d                	jne    804d640 <cJSON_Minify+0x104>
 804d5f3:	8b 45 08             	mov    0x8(%ebp),%eax
 804d5f6:	83 c0 01             	add    $0x1,%eax
 804d5f9:	0f b6 00             	movzbl (%eax),%eax
 804d5fc:	3c 2a                	cmp    $0x2a,%al
 804d5fe:	75 40                	jne    804d640 <cJSON_Minify+0x104>
        {
            /* multiline comments. */
            while (*json && !((*json == '*') && (json[1] == '/')))
 804d600:	eb 04                	jmp    804d606 <cJSON_Minify+0xca>
            {
                json++;
 804d602:	83 45 08 01          	addl   $0x1,0x8(%ebp)
            }
        }
        else if ((*json == '/') && (json[1] == '*'))
        {
            /* multiline comments. */
            while (*json && !((*json == '*') && (json[1] == '/')))
 804d606:	8b 45 08             	mov    0x8(%ebp),%eax
 804d609:	0f b6 00             	movzbl (%eax),%eax
 804d60c:	84 c0                	test   %al,%al
 804d60e:	74 1e                	je     804d62e <cJSON_Minify+0xf2>
 804d610:	8b 45 08             	mov    0x8(%ebp),%eax
 804d613:	0f b6 00             	movzbl (%eax),%eax
 804d616:	3c 2a                	cmp    $0x2a,%al
 804d618:	75 0d                	jne    804d627 <cJSON_Minify+0xeb>
 804d61a:	8b 45 08             	mov    0x8(%ebp),%eax
 804d61d:	83 c0 01             	add    $0x1,%eax
 804d620:	0f b6 00             	movzbl (%eax),%eax
 804d623:	3c 2f                	cmp    $0x2f,%al
 804d625:	74 07                	je     804d62e <cJSON_Minify+0xf2>
 804d627:	b8 01 00 00 00       	mov    $0x1,%eax
 804d62c:	eb 05                	jmp    804d633 <cJSON_Minify+0xf7>
 804d62e:	b8 00 00 00 00       	mov    $0x0,%eax
 804d633:	84 c0                	test   %al,%al
 804d635:	75 cb                	jne    804d602 <cJSON_Minify+0xc6>
            {
                json++;
            }
            json += 2;
 804d637:	83 45 08 02          	addl   $0x2,0x8(%ebp)
            while (*json && (*json != '\n'))
            {
                json++;
            }
        }
        else if ((*json == '/') && (json[1] == '*'))
 804d63b:	e9 a9 00 00 00       	jmp    804d6e9 <cJSON_Minify+0x1ad>
            {
                json++;
            }
            json += 2;
        }
        else if (*json == '\"')
 804d640:	8b 45 08             	mov    0x8(%ebp),%eax
 804d643:	0f b6 00             	movzbl (%eax),%eax
 804d646:	3c 22                	cmp    $0x22,%al
 804d648:	0f 85 86 00 00 00    	jne    804d6d4 <cJSON_Minify+0x198>
        {
            /* string literals, which are \" sensitive. */
            *into++ = (unsigned char)*json++;
 804d64e:	8b 45 08             	mov    0x8(%ebp),%eax
 804d651:	0f b6 00             	movzbl (%eax),%eax
 804d654:	89 c2                	mov    %eax,%edx
 804d656:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d659:	88 10                	mov    %dl,(%eax)
 804d65b:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804d65f:	83 45 08 01          	addl   $0x1,0x8(%ebp)
            while (*json && (*json != '\"'))
 804d663:	eb 34                	jmp    804d699 <cJSON_Minify+0x15d>
            {
                if (*json == '\\')
 804d665:	8b 45 08             	mov    0x8(%ebp),%eax
 804d668:	0f b6 00             	movzbl (%eax),%eax
 804d66b:	3c 5c                	cmp    $0x5c,%al
 804d66d:	75 15                	jne    804d684 <cJSON_Minify+0x148>
                {
                    *into++ = (unsigned char)*json++;
 804d66f:	8b 45 08             	mov    0x8(%ebp),%eax
 804d672:	0f b6 00             	movzbl (%eax),%eax
 804d675:	89 c2                	mov    %eax,%edx
 804d677:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d67a:	88 10                	mov    %dl,(%eax)
 804d67c:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804d680:	83 45 08 01          	addl   $0x1,0x8(%ebp)
                }
                *into++ = (unsigned char)*json++;
 804d684:	8b 45 08             	mov    0x8(%ebp),%eax
 804d687:	0f b6 00             	movzbl (%eax),%eax
 804d68a:	89 c2                	mov    %eax,%edx
 804d68c:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d68f:	88 10                	mov    %dl,(%eax)
 804d691:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804d695:	83 45 08 01          	addl   $0x1,0x8(%ebp)
        }
        else if (*json == '\"')
        {
            /* string literals, which are \" sensitive. */
            *into++ = (unsigned char)*json++;
            while (*json && (*json != '\"'))
 804d699:	8b 45 08             	mov    0x8(%ebp),%eax
 804d69c:	0f b6 00             	movzbl (%eax),%eax
 804d69f:	84 c0                	test   %al,%al
 804d6a1:	74 11                	je     804d6b4 <cJSON_Minify+0x178>
 804d6a3:	8b 45 08             	mov    0x8(%ebp),%eax
 804d6a6:	0f b6 00             	movzbl (%eax),%eax
 804d6a9:	3c 22                	cmp    $0x22,%al
 804d6ab:	74 07                	je     804d6b4 <cJSON_Minify+0x178>
 804d6ad:	b8 01 00 00 00       	mov    $0x1,%eax
 804d6b2:	eb 05                	jmp    804d6b9 <cJSON_Minify+0x17d>
 804d6b4:	b8 00 00 00 00       	mov    $0x0,%eax
 804d6b9:	84 c0                	test   %al,%al
 804d6bb:	75 a8                	jne    804d665 <cJSON_Minify+0x129>
                {
                    *into++ = (unsigned char)*json++;
                }
                *into++ = (unsigned char)*json++;
            }
            *into++ = (unsigned char)*json++;
 804d6bd:	8b 45 08             	mov    0x8(%ebp),%eax
 804d6c0:	0f b6 00             	movzbl (%eax),%eax
 804d6c3:	89 c2                	mov    %eax,%edx
 804d6c5:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d6c8:	88 10                	mov    %dl,(%eax)
 804d6ca:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804d6ce:	83 45 08 01          	addl   $0x1,0x8(%ebp)
 804d6d2:	eb 15                	jmp    804d6e9 <cJSON_Minify+0x1ad>
        }
        else
        {
            /* All other characters. */
            *into++ = (unsigned char)*json++;
 804d6d4:	8b 45 08             	mov    0x8(%ebp),%eax
 804d6d7:	0f b6 00             	movzbl (%eax),%eax
 804d6da:	89 c2                	mov    %eax,%edx
 804d6dc:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d6df:	88 10                	mov    %dl,(%eax)
 804d6e1:	83 45 fc 01          	addl   $0x1,-0x4(%ebp)
 804d6e5:	83 45 08 01          	addl   $0x1,0x8(%ebp)
    if (json == NULL)
    {
        return;
    }

    while (*json)
 804d6e9:	8b 45 08             	mov    0x8(%ebp),%eax
 804d6ec:	0f b6 00             	movzbl (%eax),%eax
 804d6ef:	84 c0                	test   %al,%al
 804d6f1:	0f 95 c0             	setne  %al
 804d6f4:	84 c0                	test   %al,%al
 804d6f6:	0f 85 5b fe ff ff    	jne    804d557 <cJSON_Minify+0x1b>
            *into++ = (unsigned char)*json++;
        }
    }

    /* and null-terminate. */
    *into = '\0';
 804d6fc:	8b 45 fc             	mov    -0x4(%ebp),%eax
 804d6ff:	c6 00 00             	movb   $0x0,(%eax)
}
 804d702:	c9                   	leave  
 804d703:	c3                   	ret    

0804d704 <cJSON_IsInvalid>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsInvalid(const cJSON * const item)
{
 804d704:	55                   	push   %ebp
 804d705:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d707:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d70b:	75 07                	jne    804d714 <cJSON_IsInvalid+0x10>
    {
        return false;
 804d70d:	b8 00 00 00 00       	mov    $0x0,%eax
 804d712:	eb 13                	jmp    804d727 <cJSON_IsInvalid+0x23>
    }

    return (item->type & 0xFF) == cJSON_Invalid;
 804d714:	8b 45 08             	mov    0x8(%ebp),%eax
 804d717:	8b 40 0c             	mov    0xc(%eax),%eax
 804d71a:	25 ff 00 00 00       	and    $0xff,%eax
 804d71f:	85 c0                	test   %eax,%eax
 804d721:	0f 94 c0             	sete   %al
 804d724:	0f b6 c0             	movzbl %al,%eax
}
 804d727:	5d                   	pop    %ebp
 804d728:	c3                   	ret    

0804d729 <cJSON_IsFalse>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsFalse(const cJSON * const item)
{
 804d729:	55                   	push   %ebp
 804d72a:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d72c:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d730:	75 07                	jne    804d739 <cJSON_IsFalse+0x10>
    {
        return false;
 804d732:	b8 00 00 00 00       	mov    $0x0,%eax
 804d737:	eb 14                	jmp    804d74d <cJSON_IsFalse+0x24>
    }

    return (item->type & 0xFF) == cJSON_False;
 804d739:	8b 45 08             	mov    0x8(%ebp),%eax
 804d73c:	8b 40 0c             	mov    0xc(%eax),%eax
 804d73f:	25 ff 00 00 00       	and    $0xff,%eax
 804d744:	83 f8 01             	cmp    $0x1,%eax
 804d747:	0f 94 c0             	sete   %al
 804d74a:	0f b6 c0             	movzbl %al,%eax
}
 804d74d:	5d                   	pop    %ebp
 804d74e:	c3                   	ret    

0804d74f <cJSON_IsTrue>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsTrue(const cJSON * const item)
{
 804d74f:	55                   	push   %ebp
 804d750:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d752:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d756:	75 07                	jne    804d75f <cJSON_IsTrue+0x10>
    {
        return false;
 804d758:	b8 00 00 00 00       	mov    $0x0,%eax
 804d75d:	eb 14                	jmp    804d773 <cJSON_IsTrue+0x24>
    }

    return (item->type & 0xff) == cJSON_True;
 804d75f:	8b 45 08             	mov    0x8(%ebp),%eax
 804d762:	8b 40 0c             	mov    0xc(%eax),%eax
 804d765:	25 ff 00 00 00       	and    $0xff,%eax
 804d76a:	83 f8 02             	cmp    $0x2,%eax
 804d76d:	0f 94 c0             	sete   %al
 804d770:	0f b6 c0             	movzbl %al,%eax
}
 804d773:	5d                   	pop    %ebp
 804d774:	c3                   	ret    

0804d775 <cJSON_IsBool>:


CJSON_PUBLIC(cJSON_bool) cJSON_IsBool(const cJSON * const item)
{
 804d775:	55                   	push   %ebp
 804d776:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d778:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d77c:	75 07                	jne    804d785 <cJSON_IsBool+0x10>
    {
        return false;
 804d77e:	b8 00 00 00 00       	mov    $0x0,%eax
 804d783:	eb 11                	jmp    804d796 <cJSON_IsBool+0x21>
    }

    return (item->type & (cJSON_True | cJSON_False)) != 0;
 804d785:	8b 45 08             	mov    0x8(%ebp),%eax
 804d788:	8b 40 0c             	mov    0xc(%eax),%eax
 804d78b:	83 e0 03             	and    $0x3,%eax
 804d78e:	85 c0                	test   %eax,%eax
 804d790:	0f 95 c0             	setne  %al
 804d793:	0f b6 c0             	movzbl %al,%eax
}
 804d796:	5d                   	pop    %ebp
 804d797:	c3                   	ret    

0804d798 <cJSON_IsNull>:
CJSON_PUBLIC(cJSON_bool) cJSON_IsNull(const cJSON * const item)
{
 804d798:	55                   	push   %ebp
 804d799:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d79b:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d79f:	75 07                	jne    804d7a8 <cJSON_IsNull+0x10>
    {
        return false;
 804d7a1:	b8 00 00 00 00       	mov    $0x0,%eax
 804d7a6:	eb 14                	jmp    804d7bc <cJSON_IsNull+0x24>
    }

    return (item->type & 0xFF) == cJSON_NULL;
 804d7a8:	8b 45 08             	mov    0x8(%ebp),%eax
 804d7ab:	8b 40 0c             	mov    0xc(%eax),%eax
 804d7ae:	25 ff 00 00 00       	and    $0xff,%eax
 804d7b3:	83 f8 04             	cmp    $0x4,%eax
 804d7b6:	0f 94 c0             	sete   %al
 804d7b9:	0f b6 c0             	movzbl %al,%eax
}
 804d7bc:	5d                   	pop    %ebp
 804d7bd:	c3                   	ret    

0804d7be <cJSON_IsNumber>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsNumber(const cJSON * const item)
{
 804d7be:	55                   	push   %ebp
 804d7bf:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d7c1:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d7c5:	75 07                	jne    804d7ce <cJSON_IsNumber+0x10>
    {
        return false;
 804d7c7:	b8 00 00 00 00       	mov    $0x0,%eax
 804d7cc:	eb 14                	jmp    804d7e2 <cJSON_IsNumber+0x24>
    }

    return (item->type & 0xFF) == cJSON_Number;
 804d7ce:	8b 45 08             	mov    0x8(%ebp),%eax
 804d7d1:	8b 40 0c             	mov    0xc(%eax),%eax
 804d7d4:	25 ff 00 00 00       	and    $0xff,%eax
 804d7d9:	83 f8 08             	cmp    $0x8,%eax
 804d7dc:	0f 94 c0             	sete   %al
 804d7df:	0f b6 c0             	movzbl %al,%eax
}
 804d7e2:	5d                   	pop    %ebp
 804d7e3:	c3                   	ret    

0804d7e4 <cJSON_IsString>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsString(const cJSON * const item)
{
 804d7e4:	55                   	push   %ebp
 804d7e5:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d7e7:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d7eb:	75 07                	jne    804d7f4 <cJSON_IsString+0x10>
    {
        return false;
 804d7ed:	b8 00 00 00 00       	mov    $0x0,%eax
 804d7f2:	eb 14                	jmp    804d808 <cJSON_IsString+0x24>
    }

    return (item->type & 0xFF) == cJSON_String;
 804d7f4:	8b 45 08             	mov    0x8(%ebp),%eax
 804d7f7:	8b 40 0c             	mov    0xc(%eax),%eax
 804d7fa:	25 ff 00 00 00       	and    $0xff,%eax
 804d7ff:	83 f8 10             	cmp    $0x10,%eax
 804d802:	0f 94 c0             	sete   %al
 804d805:	0f b6 c0             	movzbl %al,%eax
}
 804d808:	5d                   	pop    %ebp
 804d809:	c3                   	ret    

0804d80a <cJSON_IsArray>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsArray(const cJSON * const item)
{
 804d80a:	55                   	push   %ebp
 804d80b:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d80d:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d811:	75 07                	jne    804d81a <cJSON_IsArray+0x10>
    {
        return false;
 804d813:	b8 00 00 00 00       	mov    $0x0,%eax
 804d818:	eb 14                	jmp    804d82e <cJSON_IsArray+0x24>
    }

    return (item->type & 0xFF) == cJSON_Array;
 804d81a:	8b 45 08             	mov    0x8(%ebp),%eax
 804d81d:	8b 40 0c             	mov    0xc(%eax),%eax
 804d820:	25 ff 00 00 00       	and    $0xff,%eax
 804d825:	83 f8 20             	cmp    $0x20,%eax
 804d828:	0f 94 c0             	sete   %al
 804d82b:	0f b6 c0             	movzbl %al,%eax
}
 804d82e:	5d                   	pop    %ebp
 804d82f:	c3                   	ret    

0804d830 <cJSON_IsObject>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
{
 804d830:	55                   	push   %ebp
 804d831:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d833:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d837:	75 07                	jne    804d840 <cJSON_IsObject+0x10>
    {
        return false;
 804d839:	b8 00 00 00 00       	mov    $0x0,%eax
 804d83e:	eb 14                	jmp    804d854 <cJSON_IsObject+0x24>
    }

    return (item->type & 0xFF) == cJSON_Object;
 804d840:	8b 45 08             	mov    0x8(%ebp),%eax
 804d843:	8b 40 0c             	mov    0xc(%eax),%eax
 804d846:	25 ff 00 00 00       	and    $0xff,%eax
 804d84b:	83 f8 40             	cmp    $0x40,%eax
 804d84e:	0f 94 c0             	sete   %al
 804d851:	0f b6 c0             	movzbl %al,%eax
}
 804d854:	5d                   	pop    %ebp
 804d855:	c3                   	ret    

0804d856 <cJSON_IsRaw>:

CJSON_PUBLIC(cJSON_bool) cJSON_IsRaw(const cJSON * const item)
{
 804d856:	55                   	push   %ebp
 804d857:	89 e5                	mov    %esp,%ebp
    if (item == NULL)
 804d859:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d85d:	75 07                	jne    804d866 <cJSON_IsRaw+0x10>
    {
        return false;
 804d85f:	b8 00 00 00 00       	mov    $0x0,%eax
 804d864:	eb 16                	jmp    804d87c <cJSON_IsRaw+0x26>
    }

    return (item->type & 0xFF) == cJSON_Raw;
 804d866:	8b 45 08             	mov    0x8(%ebp),%eax
 804d869:	8b 40 0c             	mov    0xc(%eax),%eax
 804d86c:	25 ff 00 00 00       	and    $0xff,%eax
 804d871:	3d 80 00 00 00       	cmp    $0x80,%eax
 804d876:	0f 94 c0             	sete   %al
 804d879:	0f b6 c0             	movzbl %al,%eax
}
 804d87c:	5d                   	pop    %ebp
 804d87d:	c3                   	ret    

0804d87e <cJSON_Compare>:

CJSON_PUBLIC(cJSON_bool) cJSON_Compare(const cJSON * const a, const cJSON * const b, const cJSON_bool case_sensitive)
{
 804d87e:	55                   	push   %ebp
 804d87f:	89 e5                	mov    %esp,%ebp
 804d881:	83 ec 28             	sub    $0x28,%esp
    if ((a == NULL) || (b == NULL) || ((a->type & 0xFF) != (b->type & 0xFF)) || cJSON_IsInvalid(a))
 804d884:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804d888:	74 2c                	je     804d8b6 <cJSON_Compare+0x38>
 804d88a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804d88e:	74 26                	je     804d8b6 <cJSON_Compare+0x38>
 804d890:	8b 45 08             	mov    0x8(%ebp),%eax
 804d893:	8b 50 0c             	mov    0xc(%eax),%edx
 804d896:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d899:	8b 40 0c             	mov    0xc(%eax),%eax
 804d89c:	31 d0                	xor    %edx,%eax
 804d89e:	25 ff 00 00 00       	and    $0xff,%eax
 804d8a3:	85 c0                	test   %eax,%eax
 804d8a5:	75 0f                	jne    804d8b6 <cJSON_Compare+0x38>
 804d8a7:	8b 45 08             	mov    0x8(%ebp),%eax
 804d8aa:	89 04 24             	mov    %eax,(%esp)
 804d8ad:	e8 52 fe ff ff       	call   804d704 <cJSON_IsInvalid>
 804d8b2:	85 c0                	test   %eax,%eax
 804d8b4:	74 07                	je     804d8bd <cJSON_Compare+0x3f>
 804d8b6:	b8 01 00 00 00       	mov    $0x1,%eax
 804d8bb:	eb 05                	jmp    804d8c2 <cJSON_Compare+0x44>
 804d8bd:	b8 00 00 00 00       	mov    $0x0,%eax
 804d8c2:	84 c0                	test   %al,%al
 804d8c4:	74 0a                	je     804d8d0 <cJSON_Compare+0x52>
    {
        return false;
 804d8c6:	b8 00 00 00 00       	mov    $0x0,%eax
 804d8cb:	e9 f6 02 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
    }

    /* check if type is valid */
    switch (a->type & 0xFF)
 804d8d0:	8b 45 08             	mov    0x8(%ebp),%eax
 804d8d3:	8b 40 0c             	mov    0xc(%eax),%eax
 804d8d6:	25 ff 00 00 00       	and    $0xff,%eax
 804d8db:	83 f8 08             	cmp    $0x8,%eax
 804d8de:	74 3d                	je     804d91d <cJSON_Compare+0x9f>
 804d8e0:	83 f8 08             	cmp    $0x8,%eax
 804d8e3:	7f 11                	jg     804d8f6 <cJSON_Compare+0x78>
 804d8e5:	83 f8 01             	cmp    $0x1,%eax
 804d8e8:	7c 29                	jl     804d913 <cJSON_Compare+0x95>
 804d8ea:	83 f8 02             	cmp    $0x2,%eax
 804d8ed:	7e 31                	jle    804d920 <cJSON_Compare+0xa2>
 804d8ef:	83 f8 04             	cmp    $0x4,%eax
 804d8f2:	74 2f                	je     804d923 <cJSON_Compare+0xa5>
 804d8f4:	eb 1d                	jmp    804d913 <cJSON_Compare+0x95>
 804d8f6:	83 f8 20             	cmp    $0x20,%eax
 804d8f9:	74 2b                	je     804d926 <cJSON_Compare+0xa8>
 804d8fb:	83 f8 20             	cmp    $0x20,%eax
 804d8fe:	7f 07                	jg     804d907 <cJSON_Compare+0x89>
 804d900:	83 f8 10             	cmp    $0x10,%eax
 804d903:	74 24                	je     804d929 <cJSON_Compare+0xab>
 804d905:	eb 0c                	jmp    804d913 <cJSON_Compare+0x95>
 804d907:	83 f8 40             	cmp    $0x40,%eax
 804d90a:	74 20                	je     804d92c <cJSON_Compare+0xae>
 804d90c:	3d 80 00 00 00       	cmp    $0x80,%eax
 804d911:	74 1c                	je     804d92f <cJSON_Compare+0xb1>
        case cJSON_Array:
        case cJSON_Object:
            break;

        default:
            return false;
 804d913:	b8 00 00 00 00       	mov    $0x0,%eax
 804d918:	e9 a9 02 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
        case cJSON_Number:
        case cJSON_String:
        case cJSON_Raw:
        case cJSON_Array:
        case cJSON_Object:
            break;
 804d91d:	90                   	nop
 804d91e:	eb 10                	jmp    804d930 <cJSON_Compare+0xb2>
 804d920:	90                   	nop
 804d921:	eb 0d                	jmp    804d930 <cJSON_Compare+0xb2>
 804d923:	90                   	nop
 804d924:	eb 0a                	jmp    804d930 <cJSON_Compare+0xb2>
 804d926:	90                   	nop
 804d927:	eb 07                	jmp    804d930 <cJSON_Compare+0xb2>
 804d929:	90                   	nop
 804d92a:	eb 04                	jmp    804d930 <cJSON_Compare+0xb2>
 804d92c:	90                   	nop
 804d92d:	eb 01                	jmp    804d930 <cJSON_Compare+0xb2>
 804d92f:	90                   	nop
        default:
            return false;
    }

    /* identical objects are equal */
    if (a == b)
 804d930:	8b 45 08             	mov    0x8(%ebp),%eax
 804d933:	3b 45 0c             	cmp    0xc(%ebp),%eax
 804d936:	75 0a                	jne    804d942 <cJSON_Compare+0xc4>
    {
        return true;
 804d938:	b8 01 00 00 00       	mov    $0x1,%eax
 804d93d:	e9 84 02 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
    }

    switch (a->type & 0xFF)
 804d942:	8b 45 08             	mov    0x8(%ebp),%eax
 804d945:	8b 40 0c             	mov    0xc(%eax),%eax
 804d948:	25 ff 00 00 00       	and    $0xff,%eax
 804d94d:	83 f8 08             	cmp    $0x8,%eax
 804d950:	74 54                	je     804d9a6 <cJSON_Compare+0x128>
 804d952:	83 f8 08             	cmp    $0x8,%eax
 804d955:	7f 18                	jg     804d96f <cJSON_Compare+0xf1>
 804d957:	83 f8 01             	cmp    $0x1,%eax
 804d95a:	0f 8c 61 02 00 00    	jl     804dbc1 <cJSON_Compare+0x343>
 804d960:	83 f8 02             	cmp    $0x2,%eax
 804d963:	7e 37                	jle    804d99c <cJSON_Compare+0x11e>
 804d965:	83 f8 04             	cmp    $0x4,%eax
 804d968:	74 32                	je     804d99c <cJSON_Compare+0x11e>
 804d96a:	e9 52 02 00 00       	jmp    804dbc1 <cJSON_Compare+0x343>
 804d96f:	83 f8 20             	cmp    $0x20,%eax
 804d972:	0f 84 a6 00 00 00    	je     804da1e <cJSON_Compare+0x1a0>
 804d978:	83 f8 20             	cmp    $0x20,%eax
 804d97b:	7f 0a                	jg     804d987 <cJSON_Compare+0x109>
 804d97d:	83 f8 10             	cmp    $0x10,%eax
 804d980:	74 4e                	je     804d9d0 <cJSON_Compare+0x152>
 804d982:	e9 3a 02 00 00       	jmp    804dbc1 <cJSON_Compare+0x343>
 804d987:	83 f8 40             	cmp    $0x40,%eax
 804d98a:	0f 84 16 01 00 00    	je     804daa6 <cJSON_Compare+0x228>
 804d990:	3d 80 00 00 00       	cmp    $0x80,%eax
 804d995:	74 39                	je     804d9d0 <cJSON_Compare+0x152>
 804d997:	e9 25 02 00 00       	jmp    804dbc1 <cJSON_Compare+0x343>
    {
        /* in these cases and equal type is enough */
        case cJSON_False:
        case cJSON_True:
        case cJSON_NULL:
            return true;
 804d99c:	b8 01 00 00 00       	mov    $0x1,%eax
 804d9a1:	e9 20 02 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>

        case cJSON_Number:
            if (a->valuedouble == b->valuedouble)
 804d9a6:	8b 45 08             	mov    0x8(%ebp),%eax
 804d9a9:	dd 40 18             	fldl   0x18(%eax)
 804d9ac:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d9af:	dd 40 18             	fldl   0x18(%eax)
 804d9b2:	d9 c9                	fxch   %st(1)
 804d9b4:	df e9                	fucomip %st(1),%st
 804d9b6:	dd d8                	fstp   %st(0)
 804d9b8:	75 0c                	jne    804d9c6 <cJSON_Compare+0x148>
 804d9ba:	7a 0a                	jp     804d9c6 <cJSON_Compare+0x148>
            {
                return true;
 804d9bc:	b8 01 00 00 00       	mov    $0x1,%eax
 804d9c1:	e9 00 02 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
            }
            return false;
 804d9c6:	b8 00 00 00 00       	mov    $0x0,%eax
 804d9cb:	e9 f6 01 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>

        case cJSON_String:
        case cJSON_Raw:
            if ((a->valuestring == NULL) || (b->valuestring == NULL))
 804d9d0:	8b 45 08             	mov    0x8(%ebp),%eax
 804d9d3:	8b 40 10             	mov    0x10(%eax),%eax
 804d9d6:	85 c0                	test   %eax,%eax
 804d9d8:	74 0a                	je     804d9e4 <cJSON_Compare+0x166>
 804d9da:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d9dd:	8b 40 10             	mov    0x10(%eax),%eax
 804d9e0:	85 c0                	test   %eax,%eax
 804d9e2:	75 0a                	jne    804d9ee <cJSON_Compare+0x170>
            {
                return false;
 804d9e4:	b8 00 00 00 00       	mov    $0x0,%eax
 804d9e9:	e9 d8 01 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
            }
            if (strcmp(a->valuestring, b->valuestring) == 0)
 804d9ee:	8b 45 0c             	mov    0xc(%ebp),%eax
 804d9f1:	8b 50 10             	mov    0x10(%eax),%edx
 804d9f4:	8b 45 08             	mov    0x8(%ebp),%eax
 804d9f7:	8b 40 10             	mov    0x10(%eax),%eax
 804d9fa:	89 54 24 04          	mov    %edx,0x4(%esp)
 804d9fe:	89 04 24             	mov    %eax,(%esp)
 804da01:	e8 fe bc ff ff       	call   8049704 <strcmp@plt>
 804da06:	85 c0                	test   %eax,%eax
 804da08:	75 0a                	jne    804da14 <cJSON_Compare+0x196>
            {
                return true;
 804da0a:	b8 01 00 00 00       	mov    $0x1,%eax
 804da0f:	e9 b2 01 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
            }

            return false;
 804da14:	b8 00 00 00 00       	mov    $0x0,%eax
 804da19:	e9 a8 01 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>

        case cJSON_Array:
        {
            cJSON *a_element = a->child;
 804da1e:	8b 45 08             	mov    0x8(%ebp),%eax
 804da21:	8b 40 08             	mov    0x8(%eax),%eax
 804da24:	89 45 e8             	mov    %eax,-0x18(%ebp)
            cJSON *b_element = b->child;
 804da27:	8b 45 0c             	mov    0xc(%ebp),%eax
 804da2a:	8b 40 08             	mov    0x8(%eax),%eax
 804da2d:	89 45 ec             	mov    %eax,-0x14(%ebp)

            for (; (a_element != NULL) && (b_element != NULL);)
 804da30:	eb 3c                	jmp    804da6e <cJSON_Compare+0x1f0>
            {
                if (!cJSON_Compare(a_element, b_element, case_sensitive))
 804da32:	8b 45 10             	mov    0x10(%ebp),%eax
 804da35:	89 44 24 08          	mov    %eax,0x8(%esp)
 804da39:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804da3c:	89 44 24 04          	mov    %eax,0x4(%esp)
 804da40:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804da43:	89 04 24             	mov    %eax,(%esp)
 804da46:	e8 33 fe ff ff       	call   804d87e <cJSON_Compare>
 804da4b:	85 c0                	test   %eax,%eax
 804da4d:	0f 94 c0             	sete   %al
 804da50:	84 c0                	test   %al,%al
 804da52:	74 0a                	je     804da5e <cJSON_Compare+0x1e0>
                {
                    return false;
 804da54:	b8 00 00 00 00       	mov    $0x0,%eax
 804da59:	e9 68 01 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
                }

                a_element = a_element->next;
 804da5e:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804da61:	8b 00                	mov    (%eax),%eax
 804da63:	89 45 e8             	mov    %eax,-0x18(%ebp)
                b_element = b_element->next;
 804da66:	8b 45 ec             	mov    -0x14(%ebp),%eax
 804da69:	8b 00                	mov    (%eax),%eax
 804da6b:	89 45 ec             	mov    %eax,-0x14(%ebp)
        case cJSON_Array:
        {
            cJSON *a_element = a->child;
            cJSON *b_element = b->child;

            for (; (a_element != NULL) && (b_element != NULL);)
 804da6e:	83 7d e8 00          	cmpl   $0x0,-0x18(%ebp)
 804da72:	74 0d                	je     804da81 <cJSON_Compare+0x203>
 804da74:	83 7d ec 00          	cmpl   $0x0,-0x14(%ebp)
 804da78:	74 07                	je     804da81 <cJSON_Compare+0x203>
 804da7a:	b8 01 00 00 00       	mov    $0x1,%eax
 804da7f:	eb 05                	jmp    804da86 <cJSON_Compare+0x208>
 804da81:	b8 00 00 00 00       	mov    $0x0,%eax
 804da86:	84 c0                	test   %al,%al
 804da88:	75 a8                	jne    804da32 <cJSON_Compare+0x1b4>
                a_element = a_element->next;
                b_element = b_element->next;
            }

            /* one of the arrays is longer than the other */
            if (a_element != b_element) {
 804da8a:	8b 45 e8             	mov    -0x18(%ebp),%eax
 804da8d:	3b 45 ec             	cmp    -0x14(%ebp),%eax
 804da90:	74 0a                	je     804da9c <cJSON_Compare+0x21e>
                return false;
 804da92:	b8 00 00 00 00       	mov    $0x0,%eax
 804da97:	e9 2a 01 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
            }

            return true;
 804da9c:	b8 01 00 00 00       	mov    $0x1,%eax
 804daa1:	e9 20 01 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
        }

        case cJSON_Object:
        {
            cJSON *a_element = NULL;
 804daa6:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
            cJSON *b_element = NULL;
 804daad:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
            cJSON_ArrayForEach(a_element, a)
 804dab4:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
 804dab8:	74 08                	je     804dac2 <cJSON_Compare+0x244>
 804daba:	8b 45 08             	mov    0x8(%ebp),%eax
 804dabd:	8b 40 08             	mov    0x8(%eax),%eax
 804dac0:	eb 05                	jmp    804dac7 <cJSON_Compare+0x249>
 804dac2:	b8 00 00 00 00       	mov    $0x0,%eax
 804dac7:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804daca:	eb 63                	jmp    804db2f <cJSON_Compare+0x2b1>
            {
                /* TODO This has O(n^2) runtime, which is horrible! */
                b_element = get_object_item(b, a_element->string, case_sensitive);
 804dacc:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804dacf:	8b 40 20             	mov    0x20(%eax),%eax
 804dad2:	8b 55 10             	mov    0x10(%ebp),%edx
 804dad5:	89 54 24 08          	mov    %edx,0x8(%esp)
 804dad9:	89 44 24 04          	mov    %eax,0x4(%esp)
 804dadd:	8b 45 0c             	mov    0xc(%ebp),%eax
 804dae0:	89 04 24             	mov    %eax,(%esp)
 804dae3:	e8 8a e7 ff ff       	call   804c272 <_ZL15get_object_itemPK5cJSONPKci>
 804dae8:	89 45 f4             	mov    %eax,-0xc(%ebp)
                if (b_element == NULL)
 804daeb:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804daef:	75 0a                	jne    804dafb <cJSON_Compare+0x27d>
                {
                    return false;
 804daf1:	b8 00 00 00 00       	mov    $0x0,%eax
 804daf6:	e9 cb 00 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>
                }

                if (!cJSON_Compare(a_element, b_element, case_sensitive))
 804dafb:	8b 45 10             	mov    0x10(%ebp),%eax
 804dafe:	89 44 24 08          	mov    %eax,0x8(%esp)
 804db02:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804db05:	89 44 24 04          	mov    %eax,0x4(%esp)
 804db09:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804db0c:	89 04 24             	mov    %eax,(%esp)
 804db0f:	e8 6a fd ff ff       	call   804d87e <cJSON_Compare>
 804db14:	85 c0                	test   %eax,%eax
 804db16:	0f 94 c0             	sete   %al
 804db19:	84 c0                	test   %al,%al
 804db1b:	74 0a                	je     804db27 <cJSON_Compare+0x2a9>
                {
                    return false;
 804db1d:	b8 00 00 00 00       	mov    $0x0,%eax
 804db22:	e9 9f 00 00 00       	jmp    804dbc6 <cJSON_Compare+0x348>

        case cJSON_Object:
        {
            cJSON *a_element = NULL;
            cJSON *b_element = NULL;
            cJSON_ArrayForEach(a_element, a)
 804db27:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804db2a:	8b 00                	mov    (%eax),%eax
 804db2c:	89 45 f0             	mov    %eax,-0x10(%ebp)
 804db2f:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804db33:	0f 95 c0             	setne  %al
 804db36:	84 c0                	test   %al,%al
 804db38:	75 92                	jne    804dacc <cJSON_Compare+0x24e>
                }
            }

            /* doing this twice, once on a and b to prevent true comparison if a subset of b
             * TODO: Do this the proper way, this is just a fix for now */
            cJSON_ArrayForEach(b_element, b)
 804db3a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
 804db3e:	74 08                	je     804db48 <cJSON_Compare+0x2ca>
 804db40:	8b 45 0c             	mov    0xc(%ebp),%eax
 804db43:	8b 40 08             	mov    0x8(%eax),%eax
 804db46:	eb 05                	jmp    804db4d <cJSON_Compare+0x2cf>
 804db48:	b8 00 00 00 00       	mov    $0x0,%eax
 804db4d:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804db50:	eb 5d                	jmp    804dbaf <cJSON_Compare+0x331>
            {
                a_element = get_object_item(a, b_element->string, case_sensitive);
 804db52:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804db55:	8b 40 20             	mov    0x20(%eax),%eax
 804db58:	8b 55 10             	mov    0x10(%ebp),%edx
 804db5b:	89 54 24 08          	mov    %edx,0x8(%esp)
 804db5f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804db63:	8b 45 08             	mov    0x8(%ebp),%eax
 804db66:	89 04 24             	mov    %eax,(%esp)
 804db69:	e8 04 e7 ff ff       	call   804c272 <_ZL15get_object_itemPK5cJSONPKci>
 804db6e:	89 45 f0             	mov    %eax,-0x10(%ebp)
                if (a_element == NULL)
 804db71:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
 804db75:	75 07                	jne    804db7e <cJSON_Compare+0x300>
                {
                    return false;
 804db77:	b8 00 00 00 00       	mov    $0x0,%eax
 804db7c:	eb 48                	jmp    804dbc6 <cJSON_Compare+0x348>
                }

                if (!cJSON_Compare(b_element, a_element, case_sensitive))
 804db7e:	8b 45 10             	mov    0x10(%ebp),%eax
 804db81:	89 44 24 08          	mov    %eax,0x8(%esp)
 804db85:	8b 45 f0             	mov    -0x10(%ebp),%eax
 804db88:	89 44 24 04          	mov    %eax,0x4(%esp)
 804db8c:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804db8f:	89 04 24             	mov    %eax,(%esp)
 804db92:	e8 e7 fc ff ff       	call   804d87e <cJSON_Compare>
 804db97:	85 c0                	test   %eax,%eax
 804db99:	0f 94 c0             	sete   %al
 804db9c:	84 c0                	test   %al,%al
 804db9e:	74 07                	je     804dba7 <cJSON_Compare+0x329>
                {
                    return false;
 804dba0:	b8 00 00 00 00       	mov    $0x0,%eax
 804dba5:	eb 1f                	jmp    804dbc6 <cJSON_Compare+0x348>
                }
            }

            /* doing this twice, once on a and b to prevent true comparison if a subset of b
             * TODO: Do this the proper way, this is just a fix for now */
            cJSON_ArrayForEach(b_element, b)
 804dba7:	8b 45 f4             	mov    -0xc(%ebp),%eax
 804dbaa:	8b 00                	mov    (%eax),%eax
 804dbac:	89 45 f4             	mov    %eax,-0xc(%ebp)
 804dbaf:	83 7d f4 00          	cmpl   $0x0,-0xc(%ebp)
 804dbb3:	0f 95 c0             	setne  %al
 804dbb6:	84 c0                	test   %al,%al
 804dbb8:	75 98                	jne    804db52 <cJSON_Compare+0x2d4>
                {
                    return false;
                }
            }

            return true;
 804dbba:	b8 01 00 00 00       	mov    $0x1,%eax
 804dbbf:	eb 05                	jmp    804dbc6 <cJSON_Compare+0x348>
        }

        default:
            return false;
 804dbc1:	b8 00 00 00 00       	mov    $0x0,%eax
    }
}
 804dbc6:	c9                   	leave  
 804dbc7:	c3                   	ret    

0804dbc8 <cJSON_malloc>:

CJSON_PUBLIC(void *) cJSON_malloc(size_t size)
{
 804dbc8:	55                   	push   %ebp
 804dbc9:	89 e5                	mov    %esp,%ebp
 804dbcb:	83 ec 18             	sub    $0x18,%esp
    return global_hooks.allocate(size);
 804dbce:	a1 04 04 05 08       	mov    0x8050404,%eax
 804dbd3:	8b 55 08             	mov    0x8(%ebp),%edx
 804dbd6:	89 14 24             	mov    %edx,(%esp)
 804dbd9:	ff d0                	call   *%eax
}
 804dbdb:	c9                   	leave  
 804dbdc:	c3                   	ret    

0804dbdd <cJSON_free>:

CJSON_PUBLIC(void) cJSON_free(void *object)
{
 804dbdd:	55                   	push   %ebp
 804dbde:	89 e5                	mov    %esp,%ebp
 804dbe0:	83 ec 18             	sub    $0x18,%esp
    global_hooks.deallocate(object);
 804dbe3:	a1 08 04 05 08       	mov    0x8050408,%eax
 804dbe8:	8b 55 08             	mov    0x8(%ebp),%edx
 804dbeb:	89 14 24             	mov    %edx,(%esp)
 804dbee:	ff d0                	call   *%eax
}
 804dbf0:	c9                   	leave  
 804dbf1:	c3                   	ret    
 804dbf2:	90                   	nop
 804dbf3:	90                   	nop
 804dbf4:	90                   	nop
 804dbf5:	90                   	nop
 804dbf6:	90                   	nop
 804dbf7:	90                   	nop
 804dbf8:	90                   	nop
 804dbf9:	90                   	nop
 804dbfa:	90                   	nop
 804dbfb:	90                   	nop
 804dbfc:	90                   	nop
 804dbfd:	90                   	nop
 804dbfe:	90                   	nop
 804dbff:	90                   	nop

0804dc00 <__libc_csu_fini>:
 804dc00:	55                   	push   %ebp
 804dc01:	89 e5                	mov    %esp,%ebp
 804dc03:	5d                   	pop    %ebp
 804dc04:	c3                   	ret    
 804dc05:	66 66 2e 0f 1f 84 00 	data32 nopw %cs:0x0(%eax,%eax,1)
 804dc0c:	00 00 00 00 

0804dc10 <__libc_csu_init>:
 804dc10:	55                   	push   %ebp
 804dc11:	89 e5                	mov    %esp,%ebp
 804dc13:	57                   	push   %edi
 804dc14:	56                   	push   %esi
 804dc15:	53                   	push   %ebx
 804dc16:	e8 4f 00 00 00       	call   804dc6a <__i686.get_pc_thunk.bx>
 804dc1b:	81 c3 75 27 00 00    	add    $0x2775,%ebx
 804dc21:	83 ec 1c             	sub    $0x1c,%esp
 804dc24:	e8 1b b9 ff ff       	call   8049544 <_init>
 804dc29:	8d bb fc fe ff ff    	lea    -0x104(%ebx),%edi
 804dc2f:	8d 83 fc fe ff ff    	lea    -0x104(%ebx),%eax
 804dc35:	29 c7                	sub    %eax,%edi
 804dc37:	c1 ff 02             	sar    $0x2,%edi
 804dc3a:	85 ff                	test   %edi,%edi
 804dc3c:	74 24                	je     804dc62 <__libc_csu_init+0x52>
 804dc3e:	31 f6                	xor    %esi,%esi
 804dc40:	8b 45 10             	mov    0x10(%ebp),%eax
 804dc43:	89 44 24 08          	mov    %eax,0x8(%esp)
 804dc47:	8b 45 0c             	mov    0xc(%ebp),%eax
 804dc4a:	89 44 24 04          	mov    %eax,0x4(%esp)
 804dc4e:	8b 45 08             	mov    0x8(%ebp),%eax
 804dc51:	89 04 24             	mov    %eax,(%esp)
 804dc54:	ff 94 b3 fc fe ff ff 	call   *-0x104(%ebx,%esi,4)
 804dc5b:	83 c6 01             	add    $0x1,%esi
 804dc5e:	39 fe                	cmp    %edi,%esi
 804dc60:	72 de                	jb     804dc40 <__libc_csu_init+0x30>
 804dc62:	83 c4 1c             	add    $0x1c,%esp
 804dc65:	5b                   	pop    %ebx
 804dc66:	5e                   	pop    %esi
 804dc67:	5f                   	pop    %edi
 804dc68:	5d                   	pop    %ebp
 804dc69:	c3                   	ret    

0804dc6a <__i686.get_pc_thunk.bx>:
 804dc6a:	8b 1c 24             	mov    (%esp),%ebx
 804dc6d:	c3                   	ret    
 804dc6e:	90                   	nop
 804dc6f:	90                   	nop

0804dc70 <__do_global_ctors_aux>:
 804dc70:	55                   	push   %ebp
 804dc71:	89 e5                	mov    %esp,%ebp
 804dc73:	53                   	push   %ebx
 804dc74:	8d 64 24 fc          	lea    -0x4(%esp),%esp
 804dc78:	a1 90 02 05 08       	mov    0x8050290,%eax
 804dc7d:	83 f8 ff             	cmp    $0xffffffff,%eax
 804dc80:	74 12                	je     804dc94 <__do_global_ctors_aux+0x24>
 804dc82:	bb 90 02 05 08       	mov    $0x8050290,%ebx
 804dc87:	90                   	nop
 804dc88:	8d 5b fc             	lea    -0x4(%ebx),%ebx
 804dc8b:	ff d0                	call   *%eax
 804dc8d:	8b 03                	mov    (%ebx),%eax
 804dc8f:	83 f8 ff             	cmp    $0xffffffff,%eax
 804dc92:	75 f4                	jne    804dc88 <__do_global_ctors_aux+0x18>
 804dc94:	8d 64 24 04          	lea    0x4(%esp),%esp
 804dc98:	5b                   	pop    %ebx
 804dc99:	5d                   	pop    %ebp
 804dc9a:	c3                   	ret    
 804dc9b:	90                   	nop

Disassembly of section .fini:

0804dc9c <_fini>:
 804dc9c:	55                   	push   %ebp
 804dc9d:	89 e5                	mov    %esp,%ebp
 804dc9f:	53                   	push   %ebx
 804dca0:	83 ec 04             	sub    $0x4,%esp
 804dca3:	e8 00 00 00 00       	call   804dca8 <_fini+0xc>
 804dca8:	5b                   	pop    %ebx
 804dca9:	81 c3 e8 26 00 00    	add    $0x26e8,%ebx
 804dcaf:	e8 9c ba ff ff       	call   8049750 <__do_global_dtors_aux>
 804dcb4:	59                   	pop    %ecx
 804dcb5:	5b                   	pop    %ebx
 804dcb6:	c9                   	leave  
 804dcb7:	c3                   	ret    
